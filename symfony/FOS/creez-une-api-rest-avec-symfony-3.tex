\documentclass[big]{zmdocument}

\usepackage{blindtext}
\title{Créez une API REST avec Symfony 3}
\author{BestCoder}
\licence[/opt/zds/app/dist/licenses/copyright.svg]{Tous droits réservés}{}

\smileysPath{/opt/zds/app/dist/smileys}
\makeglossaries

\begin{document}
\maketitle
\tableofcontents

REST s'est imposé dans le monde du web comme étant un paradigme approuvé et éprouvé pour concevoir des APIs (Application Programming Interface).



De grandes entreprises comme \externalLink{Github}{https://developer.github.com/}, Facebook (\externalLink{Graph}{https://developers.facebook.com/docs/graph-api/using-graph-api}) ou \externalLink{YouTube}{https://www.youtube.com/yt/dev/fr/api-resources.html} l'utilisent pour fournir des APIs largement utilisées pour accéder à leurs services.



À l’ère des sites web en Single Page Applications et des applications mobiles (Android, IOS ou encore Windows Phone), savoir développer une API est devenu incontournable.



Pourquoi utiliser REST plutôt qu'une autre technologie ou architecture ? Quels avantages cela peut-il nous apporter ? Comment développer une API REST avec Symfony ?



Tout au long de ce cours, nous allons apprendre à mettre en œuvre les principes de REST pour développer rapidement une application web fiable et extensible avec le framework Symfony et l'un de ses bundles phares \textit{FOSRestBundle}.



\levelOneTitle{Un tour d'horizon des concepts REST}


Nous allons explorer les origines de REST et l'ensemble des concepts et contraintes qui sont autour.



\begin{Question}
Pourquoi utiliser REST plutôt qu'une autre technologie ou architecture ? Quelles avantages cela peut-il nous apporter ?
\end{Question}


\levelTwoTitle{REST en quelques mots}


\levelThreeTitle{Origine de REST}


REST (Representational State Transfer) est un style d'architecture pour les systèmes hypermédia distribués, créé par un dénommé Roy Thomas Fielding en 2000 et décrit dans le chapitre 5 de sa thèse de doctorat intitulée \externalLink{Architectural Styles and the Design of Network-based Software Architectures}{http://www.ics.uci.edu/\textasciitilde{}fielding/pubs/dissertation/top.htm} (Les styles d'architecture et la conception de l'architecture des applications réseaux).



\externalLink{Roy Fielding}{https://fr.wikipedia.org/wiki/Roy\_Fielding} est un ingénieur en informatique qui a notamment travaillé sur les spécifications du protocole HTTP Hypertext Transfert Protocol. Il est aussi connu comme l'un des membres fondateur de la fondation Apache.



\levelThreeTitle{Présentation de REST}


\levelFourTitle{Principes REST}


Le style d'architecture REST représente un ensemble de contraintes qui régissent une application réseau. Chacune de ces contraintes décrit un concept qu'une application qui se veut RESTful doit implémenter.



\begin{Information}
Le terme RESTful (anglicisme) est un adjectif qui qualifie une application qui suit les principes REST.
\end{Information}


\levelFiveTitle{Client-Serveur (Client-Server)}


La première contrainte est la séparation des responsabilités entre le client et le serveur. Le serveur s'occupe de la gestion des règles métier et des données et le client se concentre sur l'interface utilisateur (une interface peut être une page web, une application mobile etc.).
En séparant le client et le serveur, la portabilité et la scalabilité de notre application sont grandement améliorées. Chaque composant pourra aussi évoluer séparément.
Nous pouvons imaginer un site web qui refait toute sa charte graphique sans que le code côté serveur ne soit modifié.



\levelFiveTitle{Sans état (Stateless)}


Une autre contrainte est la notion de "Sans état" ou Stateless en anglais.
La communication entre le client et le serveur doit se faire sans dépendre d'un contexte lié au serveur. Chaque requête du client contient toutes les informations nécessaires à son traitement.
Ainsi, plusieurs instances de serveurs peuvent traiter indifféremment les requêtes de chaque client.



\levelFiveTitle{Cache}


Afin d'améliorer les performances de l'application, le serveur doit ajouter \textit{une étiquette de cache} à toutes les réponses.
Cette étiquette décrit les possibilités de mise en cache ou non des données renvoyées par le serveur.



\levelFiveTitle{Interface uniforme (Uniform Interface)}


Une des fonctionnalités clés qui permet de distinguer une architecture REST est la mise en valeur d'une interface uniforme entre les différents composants.



REST repose sur 4 contraintes d'interface :



\begin{itemize}
\item l'identification de manière unique des ressources;
\item l'interaction avec les ressources via des représentations, chaque ressource disposant de sa présentation;
\item les messages auto-descriptifs, une réponse ou une requête contient toutes les informations permettant de décrire la nature des données qu'elle contient et les interactions possibles;
\item et, l'hypermédia en tant que moteur de l'état de l'application \textit{HATEOAS}. L'état de l'application, les différentes interactions possibles entre client et le serveur doivent être décrites à travers les liens hypermédia dans les réponses du serveur.
\end{itemize}


Le terme lien hypermédia englobe des formulaires, les liens hypertextes ou plus généralement tout support numérique permettant une interaction.



En définissant une interface uniformisée, les différentes interactions avec le serveur sont facilement identifiables.



\levelFiveTitle{Organisation en couches (Layered System)}


Les couches dans une application consistent en l'isolation des différents composants de l'application pour bien organiser leurs responsabilités.
Chaque couche représente alors un système borné qui traite une problématique spécifique de notre application.
Nous pouvons prendre comme exemple une couche dédiée au stockage des données mais qui n'a pas conscience de leur origine. Son unique rôle consiste à stocker des informations qui lui sont passées.



\levelFiveTitle{Code à la demande (Code-On-Demand)}


Cette contrainte \textbf{optionnelle} permet l'extension des fonctionnalités du client en fournissant du code téléchargeable et exécutable.
Cela nécessite quand même une certaine connaissance des clients qui exploitent l'application REST.
Par exemple, une API pourrait fournir du code JavaScript que tous les clients web peuvent télécharger et exécuter pour effectuer des tâches complexes.
Cela permet de faire évoluer un client sans avoir à le redéployer vu que le code exécuté vient du serveur. Il suffira juste de mettre à jour le serveur et le tour est joué.



\levelFourTitle{Un peu de vocabulaire autour de REST}


Ce style d'architecture introduit et utilise par la même occasion quelques notions qu'il faut impérativement comprendre.



\levelFiveTitle{Ressources et identifiants}


Une interface REST gravite autour de ressources. À partir du moment où vous devez interagir avec une entité de votre application, créer une entité, la modifier, la consulter ou encore l'identifier de manière unique, vous avez pour la plupart des cas une ressource.
Si par exemple, nous développons une application de commerce en ligne, un article disponible à la vente est une ressource. Une image décrivant cet article peut être une ressource. 
Pour référencer de manière unique cette ressource, REST utilise un identifiant. Cet identifiant sera alors utilisé par \textit{tous} les différents composants de notre application afin d'interagir avec cette ressource.
Notre article pourra ainsi avoir un numéro unique que les composants du panier, de paiement ou autres utiliseront pour désigner cet article.



\levelFiveTitle{Représentation d'une ressource}


Une représentation désigne toutes les informations (données et métadonnées) utiles qui décrivent une ressource.



Notre article pourra donc être représenté par une page HTML (Hypertext Markup langage) contenant le nom de l'article, son prix, sa disponibilité etc. Et notre image décrivant un article, sa représentation désignera simplement les données en base64 et les métadonnées qui décrivent l'encodage utilisée pour l'image, le type de compression, etc.



\begin{Information}
En résumé, REST est un style d'architecture défini par un ensemble de contraintes qui régissent l'organisation d'une application et les procédés de communication entre un fournisseur de services (le serveur) et le consommateur (le client).
\end{Information}


\levelTwoTitle{Pourquoi utiliser REST}


\begin{Question}
Pourquoi utiliser REST plutôt d'une autre technologie ou architecture ?
\end{Question}


Il existe plusieurs moyens permettant de communiquer entre des composants dans le cadre d'une architecture de type SOA (Service oriented Archictecture). On peut citer le protocole SOAP (Simple Object Access Protocol) ou encore XML-RPC.



Ces technologies sont largement utilisées surtout dans un cadre d'entreprise, mais avec l'essor du web, elles ont commencé à montrer leurs limites.



REST étant conçu pour répondre à ce besoin spécifique - le web - ce style d'architecture théorisé par Roy Fielding présente intrinsèquement beaucoup d'avantages pour ce cas d'usage.



Dans cette partie de ce cours, nous allons donc voir les facilités et l'intérêt que REST pourrait nous apporter dans le cadre du développement d'une API web.



\levelThreeTitle{Pourquoi REST}


\levelFourTitle{Les avantages de l'architecture REST}


Comme les différentes règles et design pattern appliqués en génie logiciel, les différentes contraintes qu'impose l'architecture REST permettent d'obtenir des applications de meilleure qualité.



On peut citer entre autres :



\begin{itemize}
\item un couplage plus faible entre le client et le serveur comparé aux méthodes du type RPC Remote Procedure Call comme SOAP;
\item une uniformisation des APIs (Application Programming Interface) pour une facilité d'utilisation;
\item une plus grande tolérance à la panne;
\item ou encore une application facilement portable et extensible.
\end{itemize}


\levelFourTitle{Popularisation}


Bien que la publication de la thèse de Roy Fielding date des années 2000, un livre de Leonard Richardson et Sam Ruby \textit{RESTful Web Services}, sorti le 22 mai 2007, a popularisé le style d’architecture REST en proposant une méthodologie pour l'implémenter en utilisant le protocole HTTP Hypertext Transfert Protocol.



Comme vous l'aurez déjà remarqué, plus nous avançons dans les principes REST, plus le modèle devient contraignant. Dès lors, une application peut suivre ces principes sans pour autant remplir toutes les contraintes du REST.



Ainsi, lors de la conférence \externalLink{QCon du 20 novembre 2008}{http://www.crummy.com/writing/speaking/2008-QCon/}, Richardson a présenté un modèle qui permet d'évaluer son application selon les principes REST. Ce modèle est connu sous le nom de: Modèle de maturité de Richardson.



\levelFiveTitle{Niveau 0 : RPC (Remote Procedure Call) via HTTP}


Le protocole HTTP est utilisé pour appeler des méthodes du serveur. C'est le niveau des API Json RPC ou encore SOAP.



\levelFiveTitle{Niveau 1 : Identification des ressources}


Les entités avec lesquels les interactions ont lieu sont identifiées en tant que ressources.



\levelFiveTitle{Niveau 2 : Utilisation des verbes HTTP}


Les interactions avec le serveur se font avec plusieurs verbes HTTP différents en \textbf{respectant} leurs sémantiques. Les opérations avec une ressource se font via un même identifiant mais avec des verbes différents.



Par exemple, le verbe \textit{GET} pour récupérer du contenu ou \textit{DELETE} pour le supprimer. En l'occurrence, le Json RPC utilise le verbe \textit{POST} pour toutes ces opérations et par conséquent ne respecte pas ce modèle.



\begin{Information}
Les verbes HTTP appelés aussi méthodes permettent de décrire avec une sémantique claire l'opération que nous voulons effectuer. Nous pouvons citer les plus courantes qui sont \textit{GET}, \textit{POST}, \textit{PUT} et \textit{DELETE}.
\end{Information}


Pour finir les codes de statut du protocole permettent d'avoir des réponses plus expressives. Une réponse avec un code 404 permettra au client d'identifier que la ressource demandée n'existe pas.
Nous verrons plus en détails quelles sont les méthodes et codes de statut que nous pouvons utiliser dans la suite de ce cours.



\levelFiveTitle{Niveau 3 : Contrôles hypermédia.}


Comme déjà décrit dans la partie \textit{Présentation de REST > Interface uniforme}, le contrôle hypermédia désigne l'état d'une application ou API avec un seul point d'entrée mais qui propose des éléments permettant de l'explorer et d'interagir avec elle.
Un bon exemple est le site web. Si par exemple, nous accédons à YouTube, la page d'accueil nous propose des liens vers des vidéos ou encore un formulaire de recherche. Ces éléments hypermédia permettent ainsi de visualiser toutes sortes de contenus sans connaitre au préalable les liens directs les identifiants.



\image{http://zestedesavoir.com/media/galleries/3183/8d8d9732-3b64-4832-ac8e-e1ac642c10e6.png}[Modèle de maturité de Richardson]


Notre objectif sera de se rapprocher le plus possible de l'architecture REST sans oublier les contraintes que le monde réel va nous imposer.



\levelThreeTitle{REST appliqué au WEB avec le protocole HTTP}


Comme l'a dit Roy Fielding dans le chapitre 6 de sa thèse, l'objectif de REST était de créer un model architectural décrivant comment le web devrait fonctionner, le permettant de devenir ainsi une référence pour les protocoles web. REST a été conçu en évitant de violer les contraintes principales qui régissent le web.



\begin{Quotation}
As described in Chapter 4, the motivation for developing REST was to create an architectural model for how the Web should work, such that it could serve as the guiding framework for the Web protocol standards. REST has been applied to describe the desired Web architecture, help identify existing problems, compare alternative solutions, and ensure that protocol extensions would not violate the core constraints that make the Web successful.
\end{Quotation}



Le protocole de transfert HTTP dispose de beaucoup de spécificités que nous pouvons donc mettre en oeuvre avec le style d'architecture REST. Nous verrons comment mettre à profit ces spécifications afin de remplir les exigences d'une application dite RESTful.



\levelFourTitle{La séparation Client-Serveur}


L'essence même du HTTP - protocole de transfert hypertexte - comme son nom l'indique est de permettre le transfert de données entre un client et un serveur. Dès lors, les applications web remplissent de-facto cette contrainte d'architecture.



L'utilisation de HTTP dans le cadre de REST pour une bonne isolation client-serveur est donc un choix judicieux et très largement répandu.



\levelFourTitle{Sans état (Stateless)}


Il suffit de consulter le résumé de la même \externalLink{RFC 7231}{http://tools.ietf.org/html/rfc7231} pour voir que :



\begin{Quotation}
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.
\end{Quotation}



Le protocole de transfert hypertexte (HTTP) est un protocol \textbf{sans état} de la \externalLink{couche application}{https://fr.wikipedia.org/wiki/Couche\_application} (se référer au modèle OSI) pour les systèmes d'informations hypermédia distribuées et collaboratifs.



Le protocole HTTP est stateless (sans état) par définition. Même si nous pouvons retrouver des applications web qui dérogent à cette contrainte, il faut retenir que HTTP a été pensé pour fonctionner sans état.



\levelFourTitle{Le Cache}


Là aussi, le protocole HTTP supporte nativement \externalLink{la gestion du cache}{http://tools.ietf.org/html/rfc7234} via les entêtes comme \textit{Cache-Control}, \textit{Expires}, etc.
Ces entêtes permettent de réutiliser une même réponse si le contenu est considéré comme étant à jour comme le préconise le style d'architecture REST afin d'améliorer les performances de notre application.



\levelFourTitle{La gestion des ressources}


\levelFiveTitle{Identification}


Nous avons déjà défini une ressource dans le cadre de REST et pourquoi il fallait l'identifier de manière unique.
Le protocole HTTP utilise là aussi une notion bien connue: l'URI (Uniform Resource Identifier). En effet, lorsque nous consultons la \externalLink{RFC 2731}{http://tools.ietf.org/html/rfc7231} de HTTP 1.1, nous pouvons voir que une ressource est définie comme étant:



\begin{Quotation}
The target of an HTTP request is called a "resource".  HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources.  Each resource is identified by a Uniform Resource Identifier (URI), as described in Section 2.7 of [RFC7230].
\end{Quotation}



La cible d'une requête HTTP est appelé une « ressource ». HTTP ne met pas de limitation sur la nature d'une ressource; il définit seulement une interface qui peut être utilisé pour interagir avec des ressources.  Chacune de ces ressources est identifiée par une URI (Uniform Resource Identifier), comme décrit dans la section 2.7 de la [RFC7230].



\levelFiveTitle{Représentation}


Une représentation est toute information destinée à refléter l'état passé, actuel ou voulu d'une ressource donnée.



\begin{Quotation}[\externalLink{RFC 7231}{http://tools.ietf.org/html/rfc7231}]
For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, ...
\end{Quotation}



Ainsi avec les URI et les représentations des réponses HTTP (html, xml, json, etc.), nous pouvons satisfaire la contrainte 4 d'interface uniforme de REST pour mettre en place notre application.



\levelThreeTitle{Ce cours}


\levelFourTitle{Notre application Web}


Durant ce cours, nous allons développer une API permettant de gérer des idées et suggestions de sorties récréatives en se basant sur les concepts REST. Cette application va nous servir de fil conducteur pour ce cours et toutes ses fonctionnalités seront détailllées plus tard.



Les prérequis pour suivre ce cours, il faut des connaissances minimum de Symfony 2.7 à 3.* :



\begin{itemize}
\item créer une application avec Symfony ;
\item Utiliser Doctrine 2 avec Symfony ;
\item Utiliser l'injection de dépendances de Symfony.
\end{itemize}


Les objectifs de ce cours sont entre autres de :



\begin{itemize}
\item Comprendre l'architecture REST ;
\item Mettre en place une API RESTful (Créer une API uniforme et facile à utiliser) ;
\item Apprendre comment sécuriser une API (REST en particulier) ;
\item Savoir utiliser les avantages de Symfony dans ses développements (Composants et Bundles).
\end{itemize}


\levelFourTitle{Description du besoin}


Nous allons mettre en place une application permettant de gérer des idées et suggestions de sorties récréatives. 
L'application dispose de plusieurs lieux (restaurants, centre de loisirs, cinéma etc) connus et réputés et de plusieurs utilisateurs avec leurs centres d'intérêt.
L'objectif est de proposer un mécanisme permettant de proposer à chaque utilisateur une idée de sortie la plus pertinente en se basant sur ses préférences.



\levelFourTitle{Technologies utilisées}


Les exemples présentés se baseront sur Symfony 3 avec \textit{FOSRestBundle}. Les tests de l'API se feront avec cURL (utilitaire en ligne de commande) et le logiciel Postman (extension du navigateur Chrome).



\horizontalLine



Le protocole HTTP se prête bien au jeu de REST. À l'heure actuelle, la plupart des API RESTful l'utilisent vu que les technologies pour l'exploiter sont très largement répandues.



Ici prend fin l'aparté sur la partie théorique de ce cours. La suite sera grandement axée sur la pratique, tous les concepts seront abordés en se basant sur des exemples concrets.



Nous allons donc voir comment appliquer les concepts et contraintes REST dans une application web. Cela nous offrira une API uniforme avec une prise en main facile. L'objectif est d'avoir à la fin de ce cours une API pleinement fonctionnelle.



\levelOneTitle{Développement de l'API REST}


\levelTwoTitle{Notre environnement de développement}


Afin d'avoir un environnement de développement de référence pendant ce cours, nous allons voir ensemble les technologies qui seront utilisées et surtout à quelles versions.



Vous pourrez ainsi tester les différents codes qui seront fournis.
Il est utile de rappeler que pour suivre ce cours vous devez avoir un minimum de connaissances en PHP et Symfony. Certains aspects de configuration comme l'installation de MySQL, Apache ou autres ne seront pas abordés.
Si vous n'avez jamais procédé à l'installation de Symfony, il est préférable de se documenter sur le sujet avant de commencer ce cours.



\levelThreeTitle{Environnement technique}


\levelFourTitle{Plateforme}


Nous avons ci-dessous un tableau récapitulatif des différentes technologies et la version utilisée. Le système d'exploitation utilisé importe peu et vous pouvez donc utiliser celui de votre choix pour suivre le reste du cours.
Sur Windows, vous avez la suite \externalLink{WAMP}{http://www.wampserver.com/} et son équivalent \externalLink{LAMP}{https://doc.ubuntu-fr.org/lamp} sur Ubuntu.



\begin{longtabu} spread 0pt {|X[-1]|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Technologie & Version & Exemples \\ \hline
\rowfont[l]{}
PHP & 7.0.x & 7.0.0, 7.0.3 \\ \hline
MySQL & 5.7.x & 5.7.0, 5.7.9 \\ \hline
Apache & 2.4.x & 2.4.0, 2.4.17 \\ \hline
\end{longtabu}


\levelFourTitle{Symfony Installer}


La méthode recommandée pour installer un projet Symfony est d'utiliser \externalLink{l'installateur}{http://symfony.com/doc/current/book/installation.html\#installing-the-symfony-installer}. Cet utilitaire nous permettra d'installer Symfony avec la version que nous souhaitons.



\levelFiveTitle{Installation sur Linux}


Il suffit de lancer dans la console:



\begin{CodeBlock}{bash}
 curl -LsS https://symfony.com/installer -o ~/bin/symfony
 chmod a+x ~/bin/symfony
\end{CodeBlock}



Cela téléchargera l'installateur et le placera dans le répertoire bin de l'utilisateur connecté.



\levelFiveTitle{Installation sous Windows:}


Avant tout, il faut s'assurer que l'exécutable de PHP est bien disponible dans l'invite de commande. Des consignes d'installation sont disponibles sur \externalLink{le site officiel de PHP}{http://php.net/manual/fr/faq.installation.php\#faq.installation.addtopath}.
Ensuite, Il suffit exécuter dans l'invite de commande :



\begin{CodeBlock}{bash}
c:\> php -r "readfile('https://symfony.com/installer');" > symfony
\end{CodeBlock}



Ensuite, il est judicieux de créer un fichier \CodeInline{symfony.bat} contenant \CodeInline{@php "\%\textasciitilde{}dp0symfony" \%*}.



\begin{Information}
Il est possible de placer les fichiers symfony et symfony.bat dans un même dossier que vous rajouter dans le PATH avec les variables d'environnement de Windows afin d'accéder à la commande partout.
\end{Information}


Une fois l'installation finie, lancer la commande symfony pour vérifier le bon fonctionnement du tout.



\begin{CodeBlock}{bash}
symfony
# réponse attendue
 Symfony Installer (1.5.0)
 =========================

 This is the official installer to start new projects based on the
 Symfony full-stack framework.
\end{CodeBlock}



\levelFourTitle{Composer}


Nous utiliserons \externalLink{Composer}{https://getcomposer.org} pour rajouter de nouvelles dépendances à notre projet.



Il suffit d'utiliser l'installateur disponible sur \externalLink{le site officiel}{https://getcomposer.org/download/}.



Pour tester le bon fonctionnement, il faut lancer la commande \CodeInline{composer}:



\begin{CodeBlock}{bash}
composer
# réponse attendue
#   ______
#  / ____/___  ____ ___  ____  ____  ________  _____
# / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
#/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
#\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
#                    /_/             
\end{CodeBlock}



\levelFourTitle{Installation de Git}


Si vous  n'avez pas déjà Git sur votre machine, il va falloir l'installer car Composer peut être amené à l'utiliser pour télécharger des dépendances. L'installation est bien détaillée sur le site \externalLink{Git SCM}{https://git-scm.com/book/fr/v1/D\%C3\%A9marrage-rapide-Installation-de-Git}.
Il faudra juste vous assurer que l’exécutable \CodeInline{git} est disponible dans votre path.



\levelThreeTitle{Création d'un projet Symfony}


\levelFourTitle{Utilisons l'installateur de Symfony}


\levelFiveTitle{Création du projet}


Maintenant que nous avons un environnement de développement bien configuré, il ne reste plus qu'à créer un nouveau projet basé sur Symfony 3.



\begin{CodeBlock}{bash}
symfony new rest_api 3.1
# Réponse attendue
Preparing project...
OK  Symfony 3.1.1 was successfully installed.
\end{CodeBlock}



Après un long moment de chargement, nous avons un dossier nommé \CodeInline{rest\_api} contenant une installation toute neuve de Symfony 3.1.X (3.1.1 pour mon cas). Ça sera notre point de départ pour nos développements.
Testons la création du projet en lançant le serveur de développement intégré à PHP:



\begin{CodeBlock}{bash}
cd rest_api
php bin/console server:run

[OK] Server running on http://127.0.0.1:8000
// Quit the server with CONTROL-C.
\end{CodeBlock}



Accédez à l'URL de vérification de Symfony et effectuez les correctifs si nécessaires \externalLink{http://localhost:8000/config.php}{http://localhost:8000/config.php}.



\image{http://zestedesavoir.com/media/galleries/3183/06a08293-1a2a-43cf-b320-3252a09443c1.png}[Page de vérification de la configuration de Symfony]


\levelFiveTitle{Problème de certificats SSL}


Sous Windows, il est possible de rencontrer des problèmes de certificats.



\begin{CodeBlock}{text}
[GuzzleHttp\Exception\RequestException]
cURL error 60: SSL certificate problem: unable to get local issuer certificate
\end{CodeBlock}



Pour corriger ce problème, il faut s'assurer que l'extension OpenSSL est activée et définir le chemin d'accès vers le fichier contenant les certificats racines.



Une liste de certificats est disponible sur \externalLink{https://curl.haxx.se/ca/cacert.pem}{https://curl.haxx.se/ca/cacert.pem}. Pensez à le télécharger.



Commençons par identifier le fichier de configuration de PHP. Avec WAMP, ce fichier se situe dans le dossier d'installation (par exemple, \CodeInline{D:\textbackslash{}wamp64\textbackslash{}bin\textbackslash{}php\textbackslash{}php7.0.0\textbackslash{}php.ini}). Il suffit maintenant de vérifier que la ligne concernant l'extension OpenSSL n'est pas commenté et de spécifier le chemin du fichier contenant les certificats racines.



\begin{CodeBlock}{ini}
extension=php_openssl.dll
[openssl]
openssl.cafile=D:\wamp64\bin\php\php7.0.0\cacert.pem
;openssl.capath=
\end{CodeBlock}



\levelFourTitle{Configuration de Apache}


Durant le reste du cours, j'accéderai à l'API en utilisant un virtual host apache personnalisé. Notre API sera donc disponible sur l'URL \CodeInline{http://rest-api.local}.



Pour ce faire, il faut \externalLink{configurer un virtual host apache}{http://symfony.com/doc/current/cookbook/configuration/web\_server\_configuration.html} et modifier le fichier host du système pour renseigner l'URL \CodeInline{rest-api.local}.



\begin{Information}
Le virtual host fourni est compatible avec Windows. Penser à remplacer \CodeInline{D:/wamp64/www/rest\_api} par votre dossier d'installation et à effectuer les adaptations nécessaires pour un autre système d'exploitation.
\end{Information}


\begin{CodeBlock}{xml}
<VirtualHost *:80>
    ServerName rest-api.local

    DocumentRoot "D:/wamp64/www/rest_api/web"

    <Directory "D:/wamp64/www/rest_api/web">
      DirectoryIndex app_dev.php
      Require all granted
      AllowOverride None

      RewriteEngine On
      RewriteCond %{REQUEST_FILENAME} -f
      RewriteRule ^ - [L]
      RewriteRule ^ app_dev.php [L]
    </Directory>

    # Ajuster le chemin vers les fichiers de logs à votre convenance
    ErrorLog logs/rest-api-error.log 
    CustomLog logs/rest-api-access.log combined
</VirtualHost>
\end{CodeBlock}



\begin{Warning}
Le mode rewrite d'apache est obligatoire pour que ce virtual host fonctionne. Notez aussi que les requêtes seront redirigées directement vers \CodeInline{app\_dev.php} avec cette configuration.
\end{Warning}


Ensuite sous Windows, éditez en tant qu'administrateur le fichier \CodeInline{C:\textbackslash{}Windows\textbackslash{}System32\textbackslash{}drivers\textbackslash{}etc\textbackslash{}hosts} et sous Linux, éditez avec les droits root le fichier \CodeInline{/etc/hosts}, et rajouter une ligne:



\begin{CodeBlock}{text}
127.0.0.1 rest-api.local
::1 rest-api.local
\end{CodeBlock}



Sous Windows, l’astuce consiste à lancer votre éditeur de texte en tant qu'administrateur avant d'ouvrir le fichier à éditer.



Maintenant en accédant à l'URL \externalLink{http://rest-api.local/}{http://rest-api.local/}, nous atteignons notre page web de bienvenue.



\image{http://zestedesavoir.com/media/galleries/3183/0b0c54a1-8272-4159-bd51-eacbe8aa8a0f.png}[Page d'accueil de notre futur site]


\horizontalLine



Maintenant que nous avons un environnement de développement fonctionnel, nous allons mettre en place toutes les briques nécessaires pour avoir une API REST complète. Les choses sérieuses peuvent maintenant commencer.
L'outil \externalLink{Postman}{https://www.getpostman.com/} sera utilisé pour effectuer tous les tests de notre API. Il est donc grandement recommandé de l'installer avant de continuer.



\levelTwoTitle{Premières interactions avec les ressources}


\begin{Question}
Pourquoi parle-t-on tant des ressources ?
\end{Question}


Au-delà de connaitre la définition d'une ressource en REST, un des principaux problèmes lorsque nous développons une API est de savoir quelles sont les entités de notre projet qui sont éligibles.
Dans cette partie du cours, nous allons donc voir comment bien identifier une ressource avec une expression du besoin plus claire et aussi comment les exposer avec une URI (Uniform Resource Identifier).



\levelThreeTitle{Lire une collection}


\levelFourTitle{Notre première ressource}


\begin{Quotation}
Une interface REST gravite autour de ressources. À partir du moment où vous devez interagir avec une entité de votre application, créer une entité, la modifier, la consulter ou encore l'identifier de manière unique, vous avez pour la plupart des cas une ressource.
\end{Quotation}



L'application que nous devons développer enregistre plusieurs \textbf{lieux} (monuments, centres de loisirs, châteaux, etc.) et fait des suggestions de sorties/visites à des \textbf{utilisateurs}.



Dans notre application, nous aurons donc un lieu avec éventuellement les informations permettant de le décrire (nom, adresse, thème, réputation, etc.).



Nous serons surement appelés à le consulter ou à l'éditer. Voici donc notre première ressource : un lieu.



Le choix des ressources dans une API REST est très important mais leur nommage l'est autant car c'est cela qui permettra d'avoir une API cohérente.



\levelFourTitle{Les collections dans REST}


A ce stade du cours, la notion de ressource doit être bien comprise. Mais il existe aussi une autre notion qui sera utile dans la conception d'une API REST : les collections.



Une collection désigne simplement un ensemble de ressources d'un même type. Dans notre cas, la liste de tous les lieux référencés dans l'application représente une collection. Et c'est idem pour la liste des utilisateurs.



\levelFourTitle{Le nommage d'une ressource}


Une règle d'or à respecter, c'est la cohérence. Il faut choisir des noms de ressources simples et suivre une même logique de nommage. 
Si par exemple, une ressource est nommée au pluriel alors elle doit l'être sur toute l'API et toutes les ressources doivent être aussi au pluriel. La casse est également très importante pour la cohérence. Il faudra ainsi respecter la même casse pour toutes les ressources.



Pour le cas de notre exemple, toutes nos ressources seront en minuscule, au pluriel et en anglais. C'est un choix assez répandu dans les différentes API publiques à notre disposition.



Donc pour une collection représentant les lieux à visiter, nous aurons \textbf{places}. Dans notre URL, nous aurons alors \CodeInline{rest-api.local/places}.



\levelFourTitle{Accéder aux lieux déclarés dans l'application}


Pour commencer, nous considérons qu'un lieu a un nom et une adresse. L'objectif est d'avoir un appel de notre API permettant d'afficher tous les lieux connus par notre application.



\levelFiveTitle{La sémantique HTTP}


La ressource avec laquelle nous souhaitons interagir est \textbf{places}. Notre requête HTTP doit donc se faire sur l'URL \CodeInline{rest-api.local/places}.



\begin{Question}
Quelle méthode (ou verbe) HTTP utiliser : \textit{GET}, \textit{POST}, ou \textit{DELETE} ?
\end{Question}


Comme expliqué dans le modèle de maturité de Ridcharson, une API qui se veut RESTful doit utiliser les méthodes HTTP à bon escient pour interagir avec les ressources. 
Dans notre cas, nous voulons lire des données disponibles sur le serveur. Le protocole HTTP nous propose la méthode \CodeInline{GET} qui, selon la \externalLink{RFC 7231}{http://tools.ietf.org/html/rfc7231\#section-4.3.1}, est la méthode de base pour récupérer des informations.



\image{http://zestedesavoir.com/media/galleries/3183/ee574ab6-52b9-46fa-bf42-8d8cf7c5483b.png}[Cinématique de récupération des lieux]


\levelFiveTitle{Implémentation}


Nous allons commencer par mettre en place notre appel API avec de fausses données, ensuite nous mettrons en place la persistance de celles-ci avec Doctrine.



Tout d'abord, il faut créer une entité nommée \textbf{\textit{Place}} contenant un nom et une adresse :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/Place.php
<?php
namespace AppBundle\Entity;

class Place
{
    public $name;

    public $address;

    public function __construct($name, $address)
    {
        $this->name = $name;
        $this->address = $address;
    }
}
\end{CodeBlock}



Créons maintenant un nouveau contrôleur nommé \textbf{\textit{PlaceController}} qui s'occupera de la gestions des lieux avec, pour l'instant, une seule méthode permettant de les lister.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
    /**
     * @Route("/places", name="places_list")
     * @Method({"GET"})
     */
    public function getPlacesAction(Request $request)
    {
        return new JsonResponse([
            new Place("Tour Eiffel", "5 Avenue Anatole France, 75007 Paris"),
            new Place("Mont-Saint-Michel", "50170 Le Mont-Saint-Michel"),
            new Place("Château de Versailles", "Place d'Armes, 78000 Versailles"),
        ]);
    }
}
\end{CodeBlock}



Un appel de type \CodeInline{GET} sur l'URL \externalLink{rest-api.local/places}{http://rest-api.local/places} permet d'obtenir notre liste de lieux.



\begin{CodeBlock}{json}
[
  {
    "name": "Tour Eiffel",
    "address": "5 Avenue Anatole France, 75007 Paris"
  },
  {
    "name": "Mont-Saint-Michel",
    "address": "50170 Le Mont-Saint-Michel"
  },
  {
    "name": "Château de Versailles",
    "address": "Place d'Armes, 78000 Versailles"
  }
]
\end{CodeBlock}



Avec Postman :



\image{http://zestedesavoir.com/media/galleries/3183/19a74c07-7f93-45e4-a2ff-40fd61b7edea.png}[Récupération des lieux avec Postman]


Nous allons maintenant récupérer nos lieux depuis la base de données avec Doctrine. Rajoutons un identifiant aux lieux et mettons en place les annotations sur l'entité \textbf{\textit{Place}}.



\begin{CodeBlock}{php}
# src/AppBundle/Entity/Place.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="places")
 */
class Place
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $name;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $address;

    public function getId()
    {
        return $this->id;
    }

    public function getName()
    {
        return $this->name;
    }

    public function getAddress()
    {
        return $this->address;
    }

    public function setId($id)
    {
        $this->id = $id;
        return $this;
    }

    public function setName($name)
    {
        $this->name = $name;
        return $this;
    }

    public function setAddress($address)
    {
        $this->address = $address;
        return $this;
    }
}
\end{CodeBlock}



Pour des raisons de clarté, nous allons aussi modifier le nom de notre base de données.



\begin{CodeBlock}{yaml}
# app/config/parameters.yml
parameters:
    database_host: 127.0.0.1
    database_port: null
    database_name: rest_api
    database_user: root
    database_password: null
\end{CodeBlock}



Il ne reste plus qu'à créer la base de données et la table pour stocker les lieux.



\begin{CodeBlock}{bash}
php bin/console doctrine:database:create
# Réponse
# Created database `rest_api` for connection named default

php bin/console doctrine:schema:update --dump-sql --force
# Réponse
CREATE TABLE places (id INT AUTO_INCREMENT NOT NULL, name VARCHAR(255) NOT NULL, address VARCHAR(255) NOT NULL, PRIMARY KEY(id)) DE

Updating database schema...
Database schema updated successfully! "1" query was executed
\end{CodeBlock}



Le jeu de données de test :



\begin{CodeBlock}{sql}
INSERT INTO `places` (`id`, `name`, `address`) VALUES (NULL, 'Tour Eiffel', '5 Avenue Anatole France, 75007 Paris'), (NULL, 'Mont-Saint-Michel', '50170 Le Mont-Saint-Michel'), (NULL, 'Château de Versailles', 'Place d''Armes, 78000 Versailles')
\end{CodeBlock}



Nous disposons maintenant d'une base de données pour gérer les informations de l'application. Il ne reste plus qu'à changer l'implémentation dans notre contrôleur pour charger les données avec Doctrine.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
    /**
     * @Route("/places", name="places_list")
     * @Method({"GET"})
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */
        
        $formatted = [];
        foreach ($places as $place) {
            $formatted[] = [
               'id' => $place->getId(),
               'name' => $place->getName(),
               'address' => $place->getAddress(),
            ];
        }
        
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



En testant à nouveau notre appel, nous obtenons :



\begin{CodeBlock}{json}
[
  {
    "id": 1,
    "name": "Tour Eiffel",
    "address": "5 Avenue Anatole France, 75007 Paris"
  },
  {
    "id": 2,
    "name": "Mont-Saint-Michel",
    "address": "50170 Le Mont-Saint-Michel"
  },
  {
    "id": 3,
    "name": "Château de Versailles",
    "address": "Place d'Armes, 78000 Versailles"
  }
]
\end{CodeBlock}



Avec Postman :



\image{http://zestedesavoir.com/media/galleries/3183/cbd47021-75d9-4a32-a9fa-bf487e010f55.png}[Récupération des lieux avec Postman]


\levelFourTitle{Pratiquons avec les utilisateurs}


\levelFiveTitle{Objectif}


Maintenant que le principe pour récupérer les informations d'une liste est expliqué, nous allons faire de même avec les utilisateurs. 
Nous considérerons que les utilisateurs ont un nom, un prénom et une adresse mail et que la ressource pour désigner une liste d'utilisateur est \textbf{users}.



L'objectif est de mettre en place un appel permettant de générer la liste des utilisateurs enregistrés en base.
Voici le format de la réponse attendue :



\begin{CodeBlock}{json}
[
  {
    "id": 1,
    "firstname": "Ab",
    "lastname": "Cde",
    "email": "ab.cde@test.local"
  },
  {
    "id": 2,
    "firstname": "Ef",
    "lastname": "Ghi",
    "email": "ef.ghi@test.local"
  }
]
\end{CodeBlock}



\levelFiveTitle{Implémentation}


\levelSixTitle{Configuration de doctrine}


Comme pour les lieux, nous allons commencer par créer l'entité \textbf{\textit{User}} et la configuration doctrine qui va avec:



\begin{CodeBlock}{php}
# src/AppBundle/Entity/User.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
* @ORM\Entity()
* @ORM\Table(name="users")
*/
class User
{
   /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $firstname;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $lastname;

    /**
     * @ORM\Column(type="string")
     */
    protected $email;

    public function getId()
    {
        return $this->id;
    }
     
    public function setId($id)
    {
        $this->id = $id;
    }
     
    public function getFirstname()
    {
        return $this->firstname;
    }
     
    public function setFirstname($firstname)
    {
        $this->firstname = $firstname;
    }
     
    public function getLastname()
    {
        return $this->lastname;
    }
     
    public function setLastname($lastname)
    {
        $this->lastname = $lastname;
    }
     
    public function getEmail()
    {
        return $this->email;
    }
     
    public function setEmail($email)
    {
        $this->email = $email;
    }
}
\end{CodeBlock}



Mettons à jour la base de données :



\begin{CodeBlock}{bash}
php bin/console doctrine:schema:update --dump-sql --force
# Réponse
#> CREATE TABLE users (id INT AUTO_INCREMENT NOT NULL, firstname VARCHAR(255) NOT NULL, lastname VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL, PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;

#>Updating database schema...
#>Database schema updated successfully! "1" query was executed
\end{CodeBlock}



N'oublions pas le jeu de données de test :



\begin{CodeBlock}{sql}
INSERT INTO `users` (`id`, `firstname`, `lastname`, `email`) VALUES (NULL, 'Ab', 'Cde', 'ab.cde@test.local'), (NULL, 'Ef', 'Ghi', 'ef.ghi@test.local');
\end{CodeBlock}



\levelSixTitle{Création du contrôleur pour les utilisateurs}


Nous allons créer un contrôleur dédié aux utilisateurs. Pour l'instant, nous aurons une seule méthode permettant de les lister.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use AppBundle\Entity\User;

class UserController extends Controller
{
    /**
     * @Route("/users", name="users_list")
     * @Method({"GET"})
     */
    public function getUsersAction(Request $request)
    {
        $users = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->findAll();
        /* @var $users User[] */
        
        $formatted = [];
        foreach ($users as $user) {
            $formatted[] = [
               'id' => $user->getId(),
               'firstname' => $user->getFirstname(),
               'lastname' => $user->getLastname(),
               'email' => $user->getEmail(),
            ];
        }
        
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



En regardant le code, nous pouvons déjà remarqué que le contrôleur \textbf{\textit{UserController}} ressemble à quelques lignes prés au contrôleur \textbf{\textit{PlaceController}}. Vu qu'avec REST nous utilisons une interface uniforme pour interagir avec nos ressources, si l'opération que nous voulons effectuer est identique, il y a de forte chance que le code pour l'implémentation le soit aussi. Cela nous permettra donc de gagner du temps dans les développements.



En testant avec Postman :



\image{http://zestedesavoir.com/media/galleries/3183/d2153521-5879-472a-b592-104f25f32a7a.png}[Récupération des utilisateurs avec Postman]


\levelThreeTitle{Lire une ressource}


\levelFourTitle{Accéder à un seul lieu}


\levelFiveTitle{Un peu de conception}


\begin{Question}
Maintenant que nous savons comment accéder à un ensemble de ressource (une collection), comment faire pour récupérer un seul lieu ?
\end{Question}


D'un point de vue sémantique HTTP, nous savons que pour lire du contenu, il faut utiliser la méthode \CodeInline{GET}. Le problème maintenant est de savoir comment identifier la ressource parmi toutes celles dans la collection.



Le point de départ est, en général, le nom de la collection (\textbf{places} pour notre cas). Nous devons donc trouver un moyen permettant d'identifier de manière unique un élément de cette collection. Il a une relation entre la collection et chacune de ses ressources.



Pour le cas des lieux, nous pouvons choisir l'identifiant auto-incrémenté pour désigner de manière unique un lieu. Nous pourrons dire alors que l'identifiant \CodeInline{1} désigne la ressource \CodeInline{Tour Eiffel}.



Pour la représenter dans une URL, nous avons deux choix :



\begin{itemize}
\item rest-api.local/places?id=1
\item rest-api.local/places/1
\end{itemize}


On pourrait être tenté par la première méthode utilisant le query string \CodeInline{id}. Mais la \externalLink{RFC 3986}{https://tools.ietf.org/html/rfc3986\#section-3.4} spécifie clairement les query strings comme étant des composants qui contiennent des données \textit{non-hiérarchiques}.
Pour notre cas, il y a une relation hiérarchique claire entre une collection et une de \textit{ses} ressources. Donc cette méthode est à proscrire.



Notre URL pour désigner un seul lieu sera alors \CodeInline{rest-api.local/places/1}. Et pour généraliser, pour accéder à un lieu, on aura \CodeInline{rest-api.local/places/\{place\_id\}} où \CodeInline{\{place\_id\}} désigne l'identifiant de notre lieu.



\levelFiveTitle{Implémentation}


Mettons maintenant en œuvre un nouvel appel permettant de récupérer un lieu. Nous allons utiliser le contrôleur \textbf{\textit{PlaceController}}.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    // code de getPlacesAction

    /**
     * @Route("/places/{place_id}", name="places_one")
     * @Method({"GET"})
     */
    public function getPlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('place_id'));
        /* @var $place Place */
        
        $formatted = [
           'id' => $place->getId(),
           'name' => $place->getName(),
           'address' => $place->getAddress(),
        ];
         
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



Cette action est particulièrement simple et se passe de commentaires. Ce qu'il faut retenir c'est que la méthode renvoie une seule entité et pas une liste.



En testant, nous avons comme réponse :



\begin{CodeBlock}{json}
{
  "id": 1,
  "name": "Tour Eiffel",
  "address": "5 Avenue Anatole France, 75007 Paris"
}
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/735983f9-9fb7-4275-9e58-e4d533ed195d.png}[Récupération d'un lieu avec Postman]


Nous pouvons rendre la configuration de la route plus stricte en utilisant l'attribut \CodeInline{requirements} de l'annotation \CodeInline{Route}. Puisque les identifiants des lieux sont des entiers, la déclaration de la route pourrait être \CodeInline{@Route("/places/\{place\_id\}", requirements=\{"place\_id" = "\textbackslash{}d+"\}, name="places\_one")}.



\levelFiveTitle{Pratiquons avec les utilisateurs}


\textit{Bis repetita}, nous allons mettre en place une méthode permettant de récupérer les informations d'un seul utilisateur.



Comme pour les lieux, pour récupérer un utilisateur, il suffit de créer un nouvel appel \CodeInline{GET} sur l'URL \CodeInline{rest-api.local/users/\{id\}} où \CodeInline{\{id\}} désigne l'identifiant de l'utilisateur.



Pour cela, éditons le contrôleur \textbf{\textit{UserController}} pour rajouter cette méthode.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use AppBundle\Entity\User;

class UserController extends Controller
{
    
     // code de getUsersAction

    /**
     * @Route("/users/{id}", name="users_one")
     * @Method({"GET"})
     */
    public function getUserAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id'));
        /* @var $user User */
        
        $formatted = [
           'id' => $user->getId(),
           'firstname' => $user->getFirstname(),
           'lastname' => $user->getLastname(),
           'email' => $user->getEmail(),
        ];
        
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



Nous obtenons une belle réponse JSON :



\begin{CodeBlock}{json}
{
  "id": 1,
  "firstname": "Ab",
  "lastname": "Cde",
  "email": "ab.cde@test.local"
}
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/30720646-d698-4b89-95c7-45d00ffec28b.png}[Récupération d'un utilisateur]


\levelThreeTitle{Les codes de statut (status code) pour des messages plus expressifs}


\levelFourTitle{Quel code de statut utilisé ?}


Que se passe-t-il si nous essayons de récupérer un lieu inexistant ?



Vous remarquerez qu'avec le code actuel si le lieu recherché n'existe pas (par exemple \externalLink{rest-api.local/places/42}{http://rest-api.local/places/42}), nous avons une belle erreur nous signifiant que la méthode getId ne peut être appelée sur l'objet \CodeInline{null} (\CodeInline{Fatal error: Call to a member function getId() on null}) et le code de statut de la réponse est une erreur \CodeInline{500}.



\image{http://zestedesavoir.com/media/galleries/3183/f9dfd919-5f11-4104-a11c-a2493afa58f0.png}[Récupération d'un lieu inexistant]


Ce comportement ne respecte pas la sémantique HTTP. En effet dans n'importe quel site, si vous essayez d'accéder à une page inexistante, vous recevez la fameuse erreur \CodeInline{404 Not Found} qui signifie que la ressource n'existe pas. Pour que notre API soit le plus RESTful possible, nous devons implémenter un comportement similaire.



Nous ne devons avoir une erreur \CodeInline{500} que dans le cas d'une erreur interne du serveur. Par exemple, s'il est impossible de se connecter à la base de données, il est légitime de renvoyer une erreur \CodeInline{500}.



De la même façon, lorsque la ressource est trouvée, nous devons renvoyer un code \CodeInline{200} pour signifier que tout s'est bien passé. Par chance, ce code est le code par défaut lorsqu'on utilise l'objet \textbf{\textit{JsonResponse}} de Symfony. Nous avons donc déjà ce comportement en place.



\image{http://zestedesavoir.com/media/galleries/3183/483910ed-0da7-4ad9-a00d-3e2f9360855e.png}[Cinématique de récupération des lieux avec le code de statut]


\levelFourTitle{Gérer une erreur 404}


Pour notre cas, il est facile de gérer ce type d'erreurs. Nous devons juste vérifier que la réponse du repository n'est pas nulle. Au cas contraire, il faudra renvoyer une erreur \CodeInline{404} avec éventuellement un message détaillant le problème.



Pour un lieu, nous aurons donc :



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
    // ...

    /**
     * @Route("/places/{place_id}", name="places_one")
     * @Method({"GET"})
     */
    public function getPlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('place_id'));
        /* @var $place Place */

        if (empty($place)) {
            return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
        }
        
        $formatted = [
           'id' => $place->getId(),
           'name' => $place->getName(),
           'address' => $place->getAddress(),
        ];
         
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



Maintenant, une requête \CodeInline{GET} sur l'URL \externalLink{rest-api.local/places/42}{rest-api.local/places/42} nous renvoie une erreur \CodeInline{404} avec un message bien formaté en JSON. 
La constante \CodeInline{Response::HTTP\_NOT\_FOUND} vaut \CodeInline{404} et est une constante propre à Symfony.



La réponse contient un message en JSON :



\begin{CodeBlock}{json}
{
  "message": "Place not found"
}
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/dc186ce3-69c6-4ba6-bafc-592745420efe.png}[Récupération d'un lieu inexistant avec Postman]


Pour un utilisateur, les modifications à effectuer restent identiques :



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use AppBundle\Entity\User;

class UserController extends Controller
{
    // ...

    /**
     * @Route("/users/{id}", name="users_one")
     * @Method({"GET"})
     */
    public function getUserAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id'));
        /* @var $user User */

        if (empty($user)) {
            return new JsonResponse(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
        }
        
        $formatted = [
           'id' => $user->getId(),
           'firstname' => $user->getFirstname(),
           'lastname' => $user->getLastname(),
           'email' => $user->getEmail(),
        ];
        
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



Avec ces modifications, nous avons maintenant une gestion des erreurs propres et l'API respecte au mieux la sémantique HTTP.



\horizontalLine



Après cette première introduction, nous pouvons retenir qu'en REST les interactions ont lieu avec soit une collection soit une instance de celle-ci : une ressource.



Chaque opération peut alors être décrite comme étant une requête sur une URL bien identifiée avec un verbe HTTP adéquat. Le type de la réponse est décrit par un code de statut.



Voici un petit récapitulatif du mode de fonctionnement :



\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Opération souhaitée & Verbe HTTP \\ \hline
\rowfont[l]{}
Lecture & GET \\ \hline
\end{longtabu}


\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Code statut & Signification \\ \hline
\rowfont[l]{}
200 & Tout s'est bien passé \\ \hline
404 & La ressource demandée n'existe pas \\ \hline
500 & Une erreur interne a eu lieu sur le serveur \\ \hline
\end{longtabu}


En résumé, chaque verbe est destiné à une action et la réponse est décrite en plus des données explicitées par un code de statut.



Pour concevoir une bonne API RESTful, il faut donc toujours se poser ces questions :



\begin{itemize}
\item Sur quelle ressource mon opération doit s'effectuer ?
\item Quel verbe HTTP décrit le mieux cette opération ?
\item Quelle URL permet d'identifier la ressource ?
\item Et quel code de statut doit décrire la réponse ?
\end{itemize}


\levelTwoTitle{FOSRestBundle et Symfony à la rescousse}


Force est de constater que le code dans nos contrôleurs est assez répétitifs. Toutes les réponses sont en JSON via l'objet \textbf{\textit{JsonResponse}}, la logique de formatage de celles-ci est dupliqué et toutes les routes suivent un même modèle.



Nous avons là un schéma classique de code facilement factorisable et justement Symfony nous propose beaucoup d'outils via les composants et les bundles afin de gérer ce genre de tâches courantes et/ou répétitifs.



Nous allons donc utiliser les avantages qu'offre le framework Symfony à travers le bundle \textit{FOSRestBundle} afin de mieux gérer les problématiques d'implémentation liées au contrainte REST et gagner ainsi en productivité.



\levelThreeTitle{Installation de FOSRestBundle}


Comme pour tous les bundles de Symfony, la méthode la plus simple pour l'installateur est d'utiliser le gestionnaire de dépendances \textit{Composer}. 
Pour les besoins du cours, nous allons installer la version \textasciicircum{}2.1 (2.1.0 pour mon cas) qui apporte un support plus complet de Symfony 3.
Depuis la console, il suffit de lancer la commande :



\begin{CodeBlock}{bash}
composer require friendsofsymfony/rest-bundle "^2.1"

# Réponse
#> ./composer.json has been updated
#> Loading composer repositories with package informatio
#> Updating dependencies (including require-dev)
#>   - Installing willdurand/jsonp-callback-validator (v
#>     Downloading: 100%
#> 
#>   - Installing willdurand/negotiation (1.5.0)
#>     Downloading: 100%
#> 
#>   - Installing friendsofsymfony/rest-bundle (2.1.0)
#>     Downloading: 100%
\end{CodeBlock}



Ensuite, il suffit d'activer le bundle dans Symfony en éditant le fichier \textbf{\textit{AppKernel}}.



\begin{CodeBlock}{php}
# app/AppKernel.php
<?php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = [
            // ... D'autres bundles déjà présents
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new FOS\RestBundle\FOSRestBundle(),
            new AppBundle\AppBundle(),
        ];
        // ...
    }

    // ...
}
\end{CodeBlock}



À l'état actuel, l'installation n'est pas encore complète. Si nous lançons la commande \CodeInline{php bin/console debug:config fos\_rest} une belle exception est affichée.



\begin{CodeBlock}{text}
 [InvalidArgumentException]
  Neither a service called "jms_serializer.serializer" nor "serializer" is available and no serializer is explicitly configured. You must either enable the JMSSerializerBundle, enable the Framework
  Bundle serializer or configure a custom serializer.
\end{CodeBlock}



En effet, pour traiter les réponses, ce bundle a besoin d'un outil de sérialisation.



\begin{Information}
La sérialisation est un processus permettant de convertir des données (une instance d'une classe, un tableau, etc.) en un format prédéfini. Pour le cas de notre API, la sérialisation est le mécanisme par lequel nos objets PHP seront transformés en un format textuel (JSON, XML, etc.).
\end{Information}


Heureusement pour nous, l'installation standard de Symfony contient un composant de sérialisation que nous pouvons utiliser.



Par ailleurs, \textit{FOSRestBundle} supporte le sérialiseur fourni par le bundle \externalLink{JMSSerializerBundle}{https://github.com/schmittjoh/JMSSerializerBundle} qui fournit plus de possibilités.



Mais pour nos besoins, le sérialiseur standard suffira largement. Nous allons donc l'activer en modifiant la configuration de base dans le fichier \textbf{\textit{app/config/config.yml}}.



\begin{CodeBlock}{yaml}
# app/config/config.yml
framework:
    # ...
    serializer:
        enabled: true
\end{CodeBlock}



Maintenant en retapant la commande \CodeInline{php bin/console debug:config fos\_rest}, nous obtenons :



\begin{CodeBlock}{text}
php bin/console debug:config fos_rest
Current configuration for extension with alias "fos_rest"
=========================================================

fos_rest:
    disable_csrf_role: null
    access_denied_listener:
        enabled: false
        service: null
        formats: {  }
    unauthorized_challenge: null
    param_fetcher_listener:
        enabled: false
    ...
\end{CodeBlock}



Et voilà !



Le bundle \textit{FOSRestBundle} fournit un ensemble de fonctionnalités permettant de développer une API REST. Nous allons en explorer une bonne partie tout au long de ce cours. Mais commençons d'abord par le système de routage et de gestion des réponses.



\levelThreeTitle{Routage avec FOSRestBundle}


Le système de \externalLink{routage}{http://symfony.com/doc/1.7/bundles/FOSRestBundle/5-automatic-route-generation\_single-restful-controller.html} avec ce bundle est assez complet et facile à prendre en main. Il existe un système basé sur des conventions de nommages des méthodes et un autre basé sur des annotations.



\levelFourTitle{Routage automatique}


Afin de bien voir les effets de nos modifications, nous allons d'abord afficher les routes existantes avec la commande \CodeInline{php bin/console debug:router}.



\begin{CodeBlock}{text}
php bin/console debug:router
 -------------------------- -------- -------- ------ -----------------------------------
  Name                       Method   Scheme   Host   Path
 -------------------------- -------- -------- ------ -----------------------------------
  _wdt                       ANY      ANY      ANY    /_wdt/{token}
  _profiler_home             ANY      ANY      ANY    /_profiler/
  ...
  _twig_error_test           ANY      ANY      ANY    /_error/{code}.{_format}
  homepage                   ANY      ANY      ANY    /
  tests_list                 GET      ANY      ANY    /tests
  places_list                GET      ANY      ANY    /places
  places_one                 GET      ANY      ANY    /places/{place_id}
  users_list                 GET      ANY      ANY    /users
  users_one                  GET      ANY      ANY    /users/{user_id}
 -------------------------- -------- -------- ------ -----------------------------------
\end{CodeBlock}



Les routes qui nous intéressent ici sont au nombre de 4 :



\begin{itemize}
\item GET /places
\item GET /places/\{place\_id\}
\item GET /users
\item GET /users/\{user\_id\}
\end{itemize}


\textit{FOSRestBundle} nous permet d'obtenir le même résultat avec beaucoup moins de code. Nous allons donc commencer par supprimer toutes les annotations dans notre contrôleur \textbf{\textit{PlaceController}}.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */
        
        $formatted = [];
        foreach ($places as $place) {
            $formatted[] = [
               'id' => $place->getId(),
               'name' => $place->getName(),
               'address' => $place->getAddress(),
            ];
        }
        
        return new JsonResponse($formatted);
    }

    public function getPlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('place_id'));
        /* @var $place Place */

        if (empty($place)) {
            return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
        }
        
        $formatted = [
           'id' => $place->getId(),
           'name' => $place->getName(),
           'address' => $place->getAddress(),
        ];
         
        return new JsonResponse($formatted);
    }
}
\end{CodeBlock}



En relançant la commande \CodeInline{php bin/console debug:router}, nous voyons maintenant qu'il n'existe aucune route pour les lieux. 
Nous allons donc configurer Symfony pour que \textit{FOSRestBundle} s'occupe du routage. Les routes seront directement déclarées dans \textbf{\textit{app/config/routing.yml}}.
\textit{FOSRestBundle} introduit un RouteLoader qui supporte les routes de type \CodeInline{rest}. C'est donc la seule nouveauté dans la configuration des routes dans Symfony.



\begin{CodeBlock}{yaml}
# app/config/routing.yml
app:
    resource: "@AppBundle/Controller/DefaultController.php"
    type:     annotation

places:
    type:     rest
    resource: AppBundle\Controller\PlaceController
\end{CodeBlock}



\begin{Warning}
Dans la clé \CodeInline{app}, la déclaration a été changée pour dire à Symfony de ne plus charger nos contrôleurs REST, la clé \CodeInline{app.resource} passe ainsi de \CodeInline{@AppBundle/Controller} à \CodeInline{@AppBundle/Controller/DefaultController.php}.
\end{Warning}


Nous pouvons constater avec la commande \CodeInline{php bin/console debug:router} que deux routes ont été générées pour les lieux :



\begin{itemize}
\item get\_places /places.\{\_format\}
\item get\_place  /place.\{\_format\}
\end{itemize}


Nous reviendrons plus tard sur la présence de l'attribut \CodeInline{\_format} dans la route.



Il suffit de tester les nouvelles routes générées pour nous rendre compte que le fonctionnement de l'application reste entièrement le même.



\begin{Question}
Mais comment \textit{FOSRestBundle} génère-t-il nos routes ?
\end{Question}


Tout le secret réside dans des conventions de nommage. Les noms que nous avons utilisé pour le contrôleur et les actions permettent de générer des routes RESTful sans efforts de notre part.



Ainsi, le nom du contrôleur sans le suffixe \textbf{\textit{Controller}} permet d'identifier le nom de notre ressource. \textbf{\textit{PlaceController}} permet de désigner la ressource \textbf{places}. Il faut noter aussi que si le contrôleur s'appelait \textbf{\textit{PlacesController}} (avec un « s »), la ressource serait aussi \textbf{places}. Ce nom constitue donc le début de notre URL.



Ensuite, pour le reste de l'URL et surtout le verbe HTTP, \textit{FOSRestBundle} se base sur le nom de la méthode. La méthode \textit{getPlacesAction} peut être vu en deux parties : \textit{get} qui désigne le verbe HTTP à utiliser \CodeInline{GET}, et \textit{Places} au pluriel qui correspond exactement au même nom que notre ressource.



Cette méthode dit donc à \textit{FOSRestBundle} que nous voulons récupérer la collection de lieux de notre application qui le traduit en REST par \textit{GET /places}.



\begin{Information}
Le paramètre \CodeInline{Request \$request} est propre à Symfony et donc est ignoré par \textit{FOSRestBundle}.
\end{Information}


De la même façon, la méthode \textit{getPlaceAction} (sans un ­­­« s » à « Place ») dit à \textit{FOSRestBundle} que nous voulons récupérer un seul lieu.



Mais la différence ici réside dans le fait que nous avons besoin d'un paramètre pour identifier le lieu que nous voulons récupérer. Pour que la route générée soit correcte, il est obligatoire de rajouter un paramètre identifiant la ressource.



La signature de la méthode devient alors :



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
public function getPlaceAction($id, Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($id); // L'identifiant est utilisé directement
        /* @var $place Place */
        // ...
         
        return new JsonResponse($formatted);
    }
\end{CodeBlock}



Les nouvelles routes deviennent :



\begin{itemize}
\item \textit{get\_places GET /places.\{\_format\}} qui permet de récupérer tous les lieux de l'application (\textit{get\_places} est le nom de la route générée) ;
\item \textit{get\_place GET /places/\{id\}.\{\_format\}} qui permet de récupérer un seul lieu de l'application (\textit{get\_place} est le nom de la route générée).
\end{itemize}


Nous retrouvons deux routes totalement opérationnelles. En suivant cet ensemble de normes, les routes sont alors générées automatiquement avec les bonnes URL, les bons paramètres et les bons verbes HTTP.



\levelFourTitle{Routage manuel}


Bien que très pratique, le routage automatique peut rapidement montrer ses limites. 
D'abord, il nous impose des règles de nommage pour nos méthodes. Si nous voulons nommer autrement nos actions dans le contrôleur, nous faisons face à une limitation vu que les URL et les verbes HTTP peuvent être impactés. 
Ensuite, pour avoir des routes correctes, il faudra connaitre l'ensemble des règles de nommage qu'utilise \textit{FOSTRestBundle}, ce qui est loin d'être évident.



Heureusement, nous avons à disposition une méthode manuelle permettant de définir nos routes facilement.



L'avantage du routage manuel réside dans le fait qu'il se rapproche au plus du système de routage natif de Symfony avec \textit{SensioFrameworkExtraBundle} et permet donc de moins se perdre en tant que débutant. En plus, les annotations permettant de déclarer les routes sont plus lisibles.



\textit{FOSRestBundle} propose donc plusieurs annotations de routage :



\begin{itemize}
\item FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}Get;
\item FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}Head;
\item FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}Put;
\item FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}Delete;
\item FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}Post;
\item FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}Patch;
\end{itemize}


Chacune de ces annotations désigne une méthode HTTP et prend exactement les mêmes paramètres que l'annotation \externalLink{Route}{http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/routing.html} que nous avions déjà utilisée.



Pour l'appliquer dans le cas du contrôleur \textbf{\textit{PlaceController}}, nous aurons :



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations\Get; // N'oublons pas d'inclure Get
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        // ...
    }

    /**
     * @Get("/places/{id}")
     */
    public function getPlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id')); // L'identifiant en tant que paramétre n'est plus nécessaire
        // ...
    }
}
\end{CodeBlock}



Les nouvelles routes restent inchangées :



\begin{itemize}
\item get\_places GET /places.\{\_format\}
\item get\_place GET /places/\{id\}.\{\_format\}
\end{itemize}


\begin{Error}
Si une de ces annotations est utilisée sur une action du contrôleur, le système de routage automatique abordé précédemment n'est plus utilisable sur cette même action.
\end{Error}


\levelThreeTitle{Quid de l'attribut \_format ?}


Dans chacune des routes générées, nous avons un attribut \CodeInline{\_format} qui apparaît. \textit{FOSRestBundle} introduit automatiquement ce paramètre afin de gérer le format des réponses. Vu que pour notre cas nous forçons toujours une réponse JSON, les URL \externalLink{rest-api.local/places}{http://rest-api.local/places}, \externalLink{rest-api.local/places.json}{http://rest-api.local/places.json}, \externalLink{rest-api.local/places.nimportequoi}{rest-api.local/places.nimportequoi} correspondent toutes à la même route et renvoient du JSON.



Pour gérer plusieurs formats de réponse, HTTP propose une solution plus élégante avec l'entête \CodeInline{Accept} que nous aborderons plus tard. Nous allons donc désactiver l'ajout automatique de cet attribut en reconfigurant \textit{FOSRestBundle}.



Il faut rajouter une entrée dans le fichier de configuration :



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...

fos_rest:
    routing_loader:
        include_format: false
\end{CodeBlock}



Si nous relançons \CodeInline{php bin/console debug:config fos\_rest}, le format n'est plus présent dans les routes :



\begin{itemize}
\item get\_places GET /places
\item get\_place  GET /places/\{id\}
\end{itemize}


Pratiquons en redéfinissant les routes du contrôleur \textbf{\textit{UserController}} avec les annotations de \textit{FOSRestBundle}.



\begin{CodeBlock}{php}
# src/AppBunble/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations\Get;
use AppBundle\Entity\User;

class UserController extends Controller
{
    /**
     * @Get("/users")
     */
    public function getUsersAction(Request $request)
    {
        // ...
    }

    /**
     * @Get("/users/{user_id}")
     */
    public function getUserAction(Request $request)
    {
        // ...
    }
}
\end{CodeBlock}



Et n'oublions pas de déclarer dans notre fichier de routage :



\begin{CodeBlock}{yaml}
# app/config/routing.yml
app:
    resource: "@AppBundle/Controller/DefaultController.php"
    type:     annotation

places:
    type:     rest
    resource: AppBundle\Controller\PlaceController

users:
    type:     rest
    resource: AppBundle\Controller\UserController
\end{CodeBlock}



Voyons maintenant les outils que ce bundle nous propose pour la gestion des vues.



\levelThreeTitle{Gestion des réponses avec FOSRestBundle}


\levelFourTitle{Configuration du gestionnaire de vue}


Avec \textit{FOSRestBundle}, nous disposons d'un service appelé \CodeInline{fos\_rest.view\_handler} qui nous permet de gérer nos réponses.
Pour l'utiliser, il suffit d'instancier une vue \textit{FOSRestBundle}, la configurer et laisser le gestionnaire de vue (le view handler) s'occuper du reste.
Voyez par vous-même :



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations\Get;
use FOS\RestBundle\View\ViewHandler;
use FOS\RestBundle\View\View; // Utilisation de la vue de FOSRestBundle
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */
        
        $formatted = [];
        foreach ($places as $place) {
            $formatted[] = [
               'id' => $place->getId(),
               'name' => $place->getName(),
               'address' => $place->getAddress(),
            ];
        }

         // Récupération du view handler
        $viewHandler = $this->get('fos_rest.view_handler');

        // Création d'une vue FOSRestBundle
        $view = View::create($formatted);
        $view->setFormat('json');
        
        // Gestion de la réponse
        return $viewHandler->handle($view);
    }
}
\end{CodeBlock}



L'intérêt d'utiliser un bundle réside aussi dans le fait de réduire les lignes de codes que nous avons à écrire (et par la même occasion, les sources de bogues). N'hésitez pas à retester notre appel afin de vérifier que la réponse est toujours la même.



FOSRestBundle introduit aussi un listener (ViewResponseListener) qui nous permet, à l'instar de Symfony via l'annotation \CodeInline{Template} du \externalLink{SensioFrameworkExtraBundle}{http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/view.html}, de renvoyer juste une instance de View et laisser le bundle appelait le gestionnaire de vue lui-même.



\begin{Error}
Pour utiliser l'annotation \CodeInline{View}, il faut que le SensioFrameworkExtraBundle soit activé. Mais si vous avez utilisé l'installateur de Symfony pour créer ce projet, c'est déjà le cas.
\end{Error}


Nous allons donc activer le listener en modifiant notre configuration :



\begin{CodeBlock}{yaml}
# app/config/config.yml
fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
\end{CodeBlock}



Ensuite, il ne reste plus qu'à adapter le code (toutes les annotations de FOSRestBundle seront aliasées par \CodeInline{Rest}):



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use FOS\RestBundle\View\ViewHandler;
use FOS\RestBundle\View\View; // Utilisation de la vue de FOSRestBundle
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Rest\View()
     * @Rest\Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */
        
        $formatted = [];
        foreach ($places as $place) {
            $formatted[] = [
               'id' => $place->getId(),
               'name' => $place->getName(),
               'address' => $place->getAddress(),
            ];
        }

        // Création d'une vue FOSRestBundle
        $view = View::create($formatted);
        $view->setFormat('json');

        return $view;
    }
}
\end{CodeBlock}



La simplicité qu'apporte ce bundle ne s'arrête pas là. Les données assignées à la vue sont sérialisées au bon format en utilisant le sérialiseur que nous avions configuré au début.
Ce sérialiseur supporte aussi bien les tableaux que les objets. Si vous voulez approfondir le sujet, il est préférable de consulter \externalLink{la documentation complète}{http://symfony.com/doc/current/components/serializer.html}.



Ce qu'il faut retenir dans notre cas, c'est qu'avec nos objets actuels (accesseurs en visibilité public), le sérialiseur de Symfony peut les transformer pour nous. 
Au lieu de passer un tableau formaté par nos soins, nous allons passer directement une liste d'objets au view handler. Notre code peut être réduit à :



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use FOS\RestBundle\View\ViewHandler;
use FOS\RestBundle\View\View; // Utilisation de la vue de FOSRestBundle
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Rest\View()
     * @Rest\Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */
        
        // Création d'une vue FOSRestBundle
        $view = View::create($places);
        $view->setFormat('json');

        return $view;
    }
}
\end{CodeBlock}



Et là, nous voyons vraiment l’intérêt d'utiliser les composants que nous propose le framework. L'objectif est d'être le plus concis et productif possible.



\levelFourTitle{La cerise sur le gâteau : Format automatique et réponse sans l'objet View}


Pour l'instant, notre API ne supporte qu'un seul format : le JSON. Donc au lieu de le mettre dans tous les contrôleurs, \textit{FOSRestBundle} propose un mécanisme permettant de gérer les formats et la \externalLink{négociation  de contenu}{https://fr.wikipedia.org/wiki/N\%C3\%A9gociation\_de\_contenu} : \externalLink{le format listener}{http://symfony.com/doc/1.7/bundles/FOSRestBundle/format\_listener.html}.



Il y aura un chapitre dédié à la gestion de plusieurs formats et la négociation  de contenu.



Pour l'instant, nous allons juste configurer le format listener de \textit{FOSRestBundle} pour que toutes les URL renvoient du JSON.



\begin{CodeBlock}{yaml}
# src/app/config/config.yml
fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
    format_listener:
        rules:
            - { path: '^/', priorities: ['json'], fallback_format: 'json' }
\end{CodeBlock}



La seule règle déclarée dit que pour toutes les URL (\CodeInline{path: \textasciicircum{}/}), le format prioritaire est le JSON (\CodeInline{priorities: ['json']}) et si aucun format n'est demandé par le client, il faudra utiliser le JSON quand même (\CodeInline{fallback\_format: 'json'}).



Vu que maintenant nous n'avons plus à définir le format dans les actions de nos contrôleurs, nous avons même la possibilité de renvoyer directement nos objets sans utiliser l'objet \textit{View} de \textit{FOSRestBundle}.



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Rest\View()
     * @Rest\Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */

        return $places;
    }
}
\end{CodeBlock}



Un dernier test juste pour la forme :



\image{http://zestedesavoir.com/media/galleries/3183/e31b47b5-ceaa-4b08-bacf-242339e6c700.png}[Récupération des lieux avec Postman]


\levelThreeTitle{Pratiquons avec notre code}


Maintenant que nous pouvons produire plus en écrivant moins de lignes de code, nous allons transformer toutes nos actions à l'image de \textit{getPlacesAction}.



\begin{CodeBlock}{php}
# src/AppBunble/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Rest\View()
     * @Rest\Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */

        return $places;
    }

    /**
     * @Rest\View()
     * @Rest\Get("/places/{id}")
     */
    public function getPlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id')); // L'identifiant en tant que paramétre n'est plus nécessaire
        /* @var $place Place */

        if (empty($place)) {
            return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
        }
         
        return $place;
    }
}
\end{CodeBlock}



\begin{CodeBlock}{php}
# src/AppBunble/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\User;

class UserController extends Controller
{
    /**
     * @Rest\View()
     * @Rest\Get("/users")
     */
    public function getUsersAction(Request $request)
    {
        $users = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->findAll();
        /* @var $users User[] */
        
        return $users;
    }

    /**
     * @Rest\View()
     * @Rest\Get("/users/{user_id}")
     */
    public function getUserAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('user_id'));
        /* @var $user User */

        if (empty($user)) {
            return new JsonResponse(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
        }
        
        return $user;
    }
}
\end{CodeBlock}



\horizontalLine



\textit{FOSRestBundle} est l'un des bundles les plus connus pour faire une API REST avec Symfony. Bien qu'ayant abordé pas mal de points dans cette partie du cours, il reste encore beaucoup de fonctionnalités à découvrir et durant ce cours une bonne partie sera présentée. Mais la référence reste la \externalLink{documentation officielle}{http://symfony.com/doc/current/bundles/FOSRestBundle/index.html} qui vous sera d'une grande aide dans vos futurs développements.



Pour le reste du cours, nous utiliserons ce bundle pour faciliter le travail et ne pas réinventer la roue. Le routage et la gestion des réponses seront calqués sur les cas que nous venons de voir.



\levelTwoTitle{Créer et supprimer des ressources}


Notre API ne permet pour l'instant que la lecture de données. Une API en lecture seule étant loin d'être courante (ni amusante à développer), nous allons voir comment créer et supprimer une ressource en suivant les principes REST.



\levelThreeTitle{Création d'une ressource}


Le schéma que nous allons adopter doit maintenant être familier. Plus tôt dans ce cours, nous avions :



\begin{Quotation}
Pour concevoir une bonne API RESTful, il faut donc toujours se poser ces questions :

\begin{itemize}
\item Sur quelle ressource mon opération doit s'effectuer ?
\item Quel verbe HTTP décrit le mieux cette opération ?
\item Quelle URL permet d'identifier la ressource ?
\item et quel code de statut doit décrire la réponse ?
\end{itemize}
\end{Quotation}



Nous allons donc suivre ce conseil, et rajouter une action permettant de créer un lieu dans notre application.



\levelFourTitle{Quelle est la ressource cible ?}


\begin{Question}
La première question que nous devons nous poser est sur quelle ressource pouvons-nous faire un appel de création ?
\end{Question}


De point de vue sémantique, nous pouvons considérer qu'une entité dans une application est accessible en utilisant la collection (\textbf{places}) ou en utilisant directement la ressource à travers son identifiant (\textbf{places/1}). Mais comme vous vous en doutez, une ressource que nous n'avons pas encore créé ne peut pas avoir d'identifiant.



Il faut donc voire la \textit{création} d'une ressource comme étant \textit{l'ajout} de celle-ci dans une \textit{collection}.



Créer un lieu revient donc à rajouter un lieu à notre liste déjà existante. Pour créer une ressource, il faudra donc utiliser la collection associée.



\levelFourTitle{Quel verbe HTTP ?}


Pour identifier notre collection, nous utiliserons l'URL \CodeInline{rest-api.local/places}. Mais quel appel doit-on faire ?
Les verbes HTTP ont chacun une signification et une utilisation bien définie. Pour la création, la méthode \CodeInline{POST} est bien appropriée. Pour s'en convaincre, il suffit de consulter la \externalLink{RFC 7231}{http://tools.ietf.org/html/rfc7231\#section-4.3.3} qui dit :



\begin{Quotation}
For example, POST is used for the following functions (among others

\begin{itemize}
\item Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;
\item Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;
\item \textbf{Creating a new resource that has yet to be identified by the origin server;}
\end{itemize}
\end{Quotation}



-



\begin{Quotation}
POST est utilisé pour les fonctions suivantes (entre autres) :

\begin{itemize}
\item ...
\item ...
\item \textbf{Création d'une nouvelle ressource qui n'a pas encore été identifiée par le serveur d'origine;}
\end{itemize}
\end{Quotation}



\levelFourTitle{Le corps de notre requête}


Maintenant que nous savons qu'il faudra une requête du type \CodeInline{POST rest-api.local/places}, nous allons nous intéresser au corps de notre requête : \textbf{le payload} (dans le jargon API).



Lorsque nous soumettons un formulaire sur une page web avec la méthode \CodeInline{POST}, le contenu est encodé en utilisant les encodages \textit{application/x-www-form-urlencoded} ou encore \textit{multipart/form-data} que vous avez sûrement déjà rencontrés.



Pour le cas d'une API, nous pouvons utiliser le format que nous voulons dans le corps de nos requêtes tant que le serveur supporte ce format. Nous allons donc choisir le JSON comme format.



\begin{Information}
Ce choix n'est en aucun cas lié au format de sortie de nos réponses. Le JSON reste un format textuel largement utilisé et supporté et représente souvent le minimum à supporter par une API REST. Ceci étant dit, supporter le format JSON n'est pas une contrainte REST.
\end{Information}


\levelFourTitle{Quel code de statut HTTP ?}


Pour rappels, les codes de statut HTTP peuvent être regroupés par \textit{famille}. Le premier chiffre permet d'identifier la famille de chaque code. Ainsi les codes de la famille \textit{2XX} (200, 201, 204, etc.) décrivent une requête qui s'est effectué avec succès, la famille \textit{4XX} (400, 404, etc.) pour une erreur côté client et enfin la famille \textit{5XX} (500, etc.) pour une erreur serveur.
La liste complète des codes de statut et leur signification est disponible dans la \externalLink{section 6 de la RFC 7231}{http://tools.ietf.org/html/rfc7231\#section-6}.
Mais pour notre cas, une seule nous intéresse: \CodeInline{201 Created}. Le message associé à ce code parle de lui-même, si une ressource a été créée avec succès, nous utiliserons donc le code \CodeInline{201}.



\image{http://zestedesavoir.com/media/galleries/3183/4501d22f-8e63-4fd7-945f-e5f010e2200e.png}[Cinématique de création d'un lieu]


\levelFourTitle{Créer un nouveau lieu}


Mettons en pratique tout cela en donnant la possibilité aux utilisateurs de notre API de créer un lieu.
Un utilisateur devra faire une requête \CodeInline{POST} sur l'URL \CodeInline{rest-api.local/places} avec comme payload :



\begin{CodeBlock}{json}
{
    "name": "ici un nom",
    "address": "ici une adresse"
}
\end{CodeBlock}



\begin{Warning}
Le corps de la requête ne contient pas l'identifiant vu que nous allons le créer côté serveur.
\end{Warning}


Pour des soucis de clarté, les méthodes déjà existantes dans le contrôleur \textbf{\textit{PlaceController}} ne seront pas visibles dans les extraits de code. 
Commençons donc par créer une route et en configurant le routage comme il faut:



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     /**
     * @Rest\View()
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
        
    }
}
\end{CodeBlock}



Pour tester la méthode, nous allons tout d'abord simplement renvoyer les informations qui seront dans le payload.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     /**
     * @Rest\View()
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
         return [
            'payload' => [
                $request->get('name'),
                $request->get('address')
             ]
        ];
    }
}
\end{CodeBlock}



Pour tester cette méthode, nous allons utiliser Postman.



\image{http://zestedesavoir.com/media/galleries/3183/58e5ce2a-a985-48d9-adec-8805c5c4eea1.png}[Payload pour la création d'un lieu]


Il faut choisir comme contenu JSON, Postman rajoutera automatiquement l'entête \CodeInline{Content-Type} qu'il faut à la requête. Nous explorerons plus en détails ces entêtes plus tard dans ce cours.



\image{http://zestedesavoir.com/media/galleries/3183/c9d13097-2262-44a6-b513-a01af246dd34.png}[Entête rajoutée par Postman]


La réponse obtenue est :



\image{http://zestedesavoir.com/media/galleries/3183/362c4618-3f04-40f5-ab94-f203e8645c30.png}[Réponse temporaire pour la création d'un lieu]


Nous avons maintenant un système opérationnel pour récupérer les informations pour créer notre lieu. Mais avant de continuer, un petit aparté sur \textit{FOSRestBundle} s'impose.



\levelFiveTitle{Le body listener de FOSRestBundle}


Il faut savoir que de base, Symfony ne peut pas peupler les paramétres de l'objet \CodeInline{Request} avec le payload \CodeInline{JSON}. Dans une application n'utilisant pas \textit{FOSRestBundle}, il faudrait parser manuellement le contenu en faisant \CodeInline{json\_decode(\$request->getContent(), true)} pour accéder au nom et à l'adresse du lieu.



Pour s'en convaincre, nous allons désactiver le body listener qui est activé par défaut.



\begin{CodeBlock}{yaml}
# app/config/config.yml
fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
    format_listener:
        rules:
            - { path: '^/', priorities: ['json'], fallback_format: 'json', prefer_extension: false }
    # configuration à rajouter pour désactiver le body listener
    body_listener:
        enabled: false
\end{CodeBlock}



La réponse que nous obtenons est tout autre :



\image{http://zestedesavoir.com/media/galleries/3183/f9011b00-8695-4edd-86f7-a347692b81ed.png}[Réponse sans le body listener de FOSRestBundle]


En remplaçant, le code actuel par :



\begin{CodeBlock}{php}
<?php
return [
    'payload' => json_decode($request->getContent(), true)
];
\end{CodeBlock}



Nous retrouvons la première réponse.



Là aussi \textit{FOSRestBundle} nous facilite le travail et tout parait transparent pour nous. Il faut juste garder en tête que ce listener existe et fait la transformation nécessaire pour nous.



Avant de continuer, nous allons le réactiver :



\begin{CodeBlock}{yaml}
    body_listener:
        enabled: true
\end{CodeBlock}



\levelFiveTitle{Sauvegarde en base}


Maintenant que nous avons les informations nécessaires pour créer un lieu, nous allons juste l'insérer en base avec Doctrine. Pour définir le bon code de statut, il suffit de mettre un paramètre \CodeInline{statusCode=Response::HTTP\_CREATED} dans l'annotation \CodeInline{View}.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED)
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
        $place = new Place();
        $place->setName($request->get('name'))
            ->setAddress($request->get('address'));

        $em = $this->get('doctrine.orm.entity_manager');
        $em->persist($place);
        $em->flush();

        return $place;
    }
}
\end{CodeBlock}



Ici, en renvoyant la ressource qui vient d'être créée, nous suivons la \externalLink{RFC 7231}{http://tools.ietf.org/html/rfc7231\#section-6.3.2}.



\begin{Quotation}
The 201 response payload typically describes and links to the resource(s) created.
\end{Quotation}



Pour les tester notre implémentation, nous allons utiliser :



\begin{CodeBlock}{json}
{
    "name": "Disneyland Paris",
    "address": "77777 Marne-la-Vallée"
}
\end{CodeBlock}



La réponse renvoyée avec le bon code de statut.



\image{http://zestedesavoir.com/media/galleries/3183/fbc7a46d-e668-4372-8d4c-6d9ca5748534.png}[Code de statut de la réponse]


\image{http://zestedesavoir.com/media/galleries/3183/f566322a-64b8-4093-a9f8-0529360c4ade.png}[Réponse de la création d'un lieu dans Postman]


\levelFiveTitle{Validation des données}


Bien que nous puissions créer avec succès un lieu, nous n'effectuons aucune validation. Dans cette partie, nous allons voir comment valider les informations en utilisant les formulaires de Symfony.



Nous allons commencer par créer un formulaire pour les lieux :



\begin{CodeBlock}{php}
# src/AppBundle/Form/Type/PlaceType.php
<?php
namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class PlaceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('name');
        $builder->add('address');
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Place',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



Dans une API, il faut obligatoirement désactiver la protection CSRF (Cross-Site Request Forgery). Nous n'utilisons pas de session et l'utilisateur de l'API peut appeler cette méthode sans se soucier de l'état de l'application : l'API doit rester sans état : stateless.



Nous allons maintenant rajouter des contraintes simples pour notre lieu.
Le nom et l'adresse ne doivent pas être nulles et en plus, le nom doit être unique.
Nous utiliserons le format YAML pour les règles de validations.



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml
AppBundle\Entity\Place:
    constraints:
        - Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity: name
    properties:
        name:
            - NotBlank: ~
            - Type: string
        address:
            - NotBlank: ~
            - Type: string
\end{CodeBlock}



Jusque-là rien de nouveau avec les formulaires Symfony. Si ce code ne vous parait pas assez claire. Il est préférable de consulter \externalLink{la documentation officielle}{http://symfony.com/doc/current/book/validation.html} avant de continuer ce cours.



\begin{Information}
Vu que nous avons une contrainte d'unicité sur le champ \CodeInline{name}. Il est plus logique de rajouter cela dans les annotations Doctrine.
\end{Information}


\begin{CodeBlock}{php}
# src/AppBundle/Entity/Place.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="places",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="places_name_unique",columns={"name"})}
 * )
 */
class Place
{
    // ...
}
\end{CodeBlock}



Il ne reste plus qu'à exploiter le formulaire dans notre contrôleur.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED)
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
        $place = new Place();
        $form = $this->createForm(PlaceType::class, $place);

        $form->submit($request->request->all()); // Validation des données

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($place);
            $em->flush();
            return $place;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



Le format des données attendu lorsqu'on utilise la méthode \CodeInline{handleRequest} des formulaires Symfony est un peu différent de celui que nous utilisons pour créer un lieu.
Avec \CodeInline{handleRequest}, nous aurions dû utiliser :



\begin{CodeBlock}{json}
{
    "place":
        {
            "name": "ici un nom",
            "address": "ici une adresse"
        }
}
\end{CodeBlock}



Où l'attribut \CodeInline{place} est le nom de notre formulaire Symfony.



Donc pour mieux répondre aux contraintes REST, au lieu d'utiliser la méthode \CodeInline{handleRequest} pour soumettre le formulaire, nous avons opté pour \externalLink{la soumission manuelle}{http://symfony.com/doc/current/cookbook/form/direct\_submit.html} avec \CodeInline{submit}. Nous adaptons Symfony à REST et pas l'inverse.



\levelFiveTitle{Gestion des erreurs avec FOSRestBundle}


Lorsque le formulaire n'est pas valide, nous nous contentons juste de renvoyer le formulaire. Le ViewHandler de FOSRestBundle est conçu pour gérer nativement les formulaires invalides.



Non seulement, il est en mesure de formater les erreurs dans le formulaire mais en plus, il renvoie le bon code de statut lorsque les données soumises sont invalide: \CodeInline{400}.
Le code de statut \CodeInline{400} permet de signaler au client de l'API que sa requête est invalide.



Pour s'en assurer, essayons de recréer un autre lieu avec les mêmes informations que le précédent.



\image{http://zestedesavoir.com/media/galleries/3183/03a6892f-a3b1-46b4-904b-a6f6f5d15400.png}[Code de statut pour un formulaire invalide]


\begin{CodeBlock}{json}
{
  "code": 400,
  "message": "Validation Failed",
  "errors": {
    "children": {
      "name": {
        "errors": [
          "This value is already used."
        ]
      },
      "address": []
    }
  }
}
\end{CodeBlock}



Si la clé \CodeInline{errors} d'un attribut existe, alors il y a des erreurs de validation sur cet attribut.



\levelFourTitle{Pratiquons avec les utilisateurs}


Comme pour les lieux, nous allons créer une action permettant de rajouter un utilisateur à notre application. Nous aurons comme contraintes :



\begin{itemize}
\item le prénom, le nom et l'adresse mail de l'utilisateur ne doivent pas être nuls ;
\item et l'adresse mail doit être unique.
\end{itemize}


Pour créer un utilisateur, un client de l'API devra envoyer une requête au format :



\begin{CodeBlock}{json}
{
    "firstname": "",
    "lastname": "",
    "email": ""
}
\end{CodeBlock}



Comme pour les lieux, pour créer un utilisateur il faudra une requête \CodeInline{POST} sur l'URL \CodeInline{rest-api.local/users} qui désigne notre collection d'utilisateurs.



Allons-y !



Configuration du formulaire et des contraintes de validation :



\begin{CodeBlock}{php}
# src/AppBundle/Form/Type/UserType.php
<?php
namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Form\Extension\Core\Type\EmailType;

class UserType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('firstname');
        $builder->add('lastname');
        $builder->add('email', EmailType::class);
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\User',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml

# ...

AppBundle\Entity\User:
    constraints:
        - Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity: email
    properties:
        firstname:
            - NotBlank: ~
            - Type: string
        lastname:
            - NotBlank: ~
            - Type: string
        email:
            - NotBlank: ~
            - Email: ~
\end{CodeBlock}



Rajout d'une contrainte d'unicité dans Doctrine :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/User.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
* @ORM\Entity()
* @ORM\Table(name="users",
*      uniqueConstraints={@ORM\UniqueConstraint(name="users_email_unique",columns={"email"})}
* )
*/
class User
{
    // ...
}
\end{CodeBlock}



Utilisation de notre formulaire dans le contrôleur :



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\UserType;
use AppBundle\Entity\User;

class UserController extends Controller
{
    // ...  

    /**
     * @Rest\View(statusCode=Response::HTTP_CREATED)
     * @Rest\Post("/users")
     */
    public function postUsersAction(Request $request)
    {
        $user = new User();
        $form = $this->createForm(UserType::class, $user);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($user);
            $em->flush();
            return $user;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



Nous pouvons maintenant créer des utilisateurs grâce à l'API.



\levelThreeTitle{Suppression d'une ressource}


La suppression d'une ressource reste une action très facile à appréhender.
Le protocole HTTP dispose d'une méthode appelée \CodeInline{DELETE} qui comme son nom l'indique permet de supprimer une ressource.
Quant à l'URL de la ressource, il suffit de se poser une seule question :



\begin{Question}
Que voulons-nous supprimer ?
\end{Question}


La méthode \CodeInline{DELETE} s'appliquera sur la ressource à supprimer.
Si par exemple nous voulons supprimer le lieu avec comme identifiant \CodeInline{3}, il suffira de faire une requête sur l'URL \CodeInline{rest-api.local/places/3}.



Une fois n'est pas de coutume, nous allons consulter la \externalLink{RFC 7312}{http://tools.ietf.org/html/rfc7231\#section-4.3.5}



\begin{Quotation}
If a DELETE method is successfully applied, the origin server SHOULD send a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted, a 204 (No Content) status code if the action has been enacted and no further information is to be supplied, or a 200 (OK) status code if the action has been enacted and the response message includes a representation describing the status.
\end{Quotation}



Cette citation est bien longue mais ce qui nous intéresse ici se limite à \CodeInline{a 204 (No Content) status code if the action has been enacted and no further information is to be supplied}. Pour notre cas, lorsque la ressource sera supprimée, nous allons renvoyer aucune information. Le code de statut à utiliser est donc : \CodeInline{204}.



\image{http://zestedesavoir.com/media/galleries/3183/55ce3035-f686-488f-96ef-00034ff32f64.png}[Cinématique de suppression d'une ressource]


\levelFourTitle{Suppression d'un lieu}


Nous allons, sans plus attendre, créer une méthode pour supprimer un lieu de notre application.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
    // ...

     /**
     * @Rest\View(statusCode=Response::HTTP_NO_CONTENT)
     * @Rest\Delete("/places/{id}")
     */
    public function removePlaceAction(Request $request)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $place = $em->getRepository('AppBundle:Place')
                    ->find($request->get('id'));
        /* @var $place Place */

        $em->remove($place);
        $em->flush();
    }
}
\end{CodeBlock}



Un petit test rapide avec Postman nous donne :



\image{http://zestedesavoir.com/media/galleries/3183/6da11766-ae50-49e7-ad63-80f8ede4e64c.png}[Suppression d'un lieu avec Postman]


Le code de statut est aussi correct :



\image{http://zestedesavoir.com/media/galleries/3183/5618dab6-6251-4e93-b3c8-ba9af743de92.png}[Code de statut pour la suppression d'une ressource]


\begin{Question}
Que faire si nous essayons de supprimer une ressource qui n'existe pas ou plus ?
\end{Question}


Si nous essayons de supprimer à nouveau la même ressource, nous obtenons une erreur interne. Mais, il se trouve que dans \externalLink{les spécifications}{http://tools.ietf.org/html/rfc7231\#section-8.1.3} de la méthode \CodeInline{DELETE}, il est dit que cette méthode doit être idempotente.



\begin{Information}
Une action idempotente est une action qui produit le même résultat et ce, peu importe le nombre de fois qu'elle est exécutée.
\end{Information}


Pour suivre ces spécifications HTTP, nous allons modifier notre code pour gérer le cas où le lieu à supprimer n'existe pas ou plus. En plus, l'objectif d'un client qui fait un appel de suppression est de supprimer une ressource, donc si elle l'est déjà, nous pouvons considérer que tout c'est bien passé.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     /**
     * @Rest\View(statusCode=Response::HTTP_NO_CONTENT)
     * @Rest\Delete("/places/{id}")
     */
    public function removePlaceAction(Request $request)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $place = $em->getRepository('AppBundle:Place')
                    ->find($request->get('id'));
        /* @var $place Place */

        if ($place) {
            $em->remove($place);
            $em->flush();
        }
    }
}
\end{CodeBlock}



\levelFourTitle{Pratiquons avec les utilisateurs}


Rajoutons une méthode pour supprimer un utilisateur.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\UserType;
use AppBundle\Entity\User;

class UserController extends Controller
{
    // ...

     /**
     * @Rest\View(statusCode=Response::HTTP_NO_CONTENT)
     * @Rest\Delete("/users/{id}")
     */
    public function removeUserAction(Request $request)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $user = $em->getRepository('AppBundle:User')
                    ->find($request->get('id'));
        /* @var $user User */

        if ($user) {
            $em->remove($user);
            $em->flush();
        }
    }
}
\end{CodeBlock}



\horizontalLine



Pour revenir sur nos tableaux récapitulatifs, voici le mode de fonctionnement simplifié d'une API REST :



\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Opération souhaitée & Verbe HTTP \\ \hline
\rowfont[l]{}
Lecture & GET \\ \hline
Création & POST \\ \hline
Suppression & DELETE \\ \hline
\end{longtabu}


\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Code statut & Signification \\ \hline
\rowfont[l]{}
200 & Tout s'est bien passé et la réponse a du contenu \\ \hline
204 & Tout s'est bien passé mais la réponse est vide \\ \hline
400 & Les données envoyées par le client sont invalides \\ \hline
404 & La ressource demandée n'existe pas \\ \hline
500 & Une erreur interne a eu lieu sur le serveur \\ \hline
\end{longtabu}


\levelTwoTitle{Mettre à jour des ressources}


Maintenant que nous pouvons lire, écrire et supprimer des ressources, il ne reste plus qu'à apprendre à les modifier et le CRUD\textsuperscript{\ref{footnote:1}} (Créer, Lire, Mettre à jour et Supprimer ) en REST n'aura plus de secret pour nous.



Dans cette partie, nous aborderons les concepts liés à la mise à jour de ressources REST et nous ferons un petit détour sur la gestion des erreurs avec \textit{FOSRestBundle}.



\footnotetext[1]{\label{footnote:1} \textbf{C}reate \textbf{R}ead \textbf{U}pdate \textbf{D}elete}

\levelThreeTitle{Mise à jour complète d'une ressource}


Afin de gérer la mise à jour des ressources, nous devons différencier la mise à jour complète (le client de l'API veut changer toute la ressource) de la mise à jour partielle (le client de l'API veut changer juste quelques attributs de la ressource).



Déroulons notre schéma classique pour trouver les mécanismes qu'offre HTTP pour gérer la mise à jour complète d'une ressource.



\levelFourTitle{Quelle est la ressource cible ?}


Lorsque nous voulons modifier une ressource, la question ne se pose pas. La cible de notre requête est la ressource à mettre à jour.
Donc pour mettre à jour un lieu, nous devrons faire une requête sur l'URL de celle-ci (par exemple rest-api.local/places/1).



\levelFourTitle{Quel verbe HTTP ?}


La différenciation entre la mise à jour complète ou partielle d'une ressource se fait avec le choix du verbe HTTP utilisé. Donc le verbe est ici d'\textbf{une importance capitale}.



Notre fameuse \externalLink{RFC 7231}{http://tools.ietf.org/html/rfc7231\#section-4.3.3} décrit la méthode \CodeInline{PUT} comme :



\begin{Quotation}
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.
\end{Quotation}



La méthode \CodeInline{PUT} permet de créer ou de remplacer une ressource.



Le cas d'utilisation de \CodeInline{PUT} pour créer une ressource est très rare et nous ne l'aborderons pas. Il faut juste retenir que pour que cet verbe soit utilisé pour créer une ressource, il faudrait laisser au client de l'API le choix des URL de nos ressources.
Nous l'utiliserons donc juste afin de remplacer le contenu d'une ressource par le payload de la requête, bref pour la mettre à jour en entier.



\levelFourTitle{Le corps de notre requête}


Le corps de la requête sera donc la nouvelle valeur que nous voulons affecter à notre ressource (toujours au format JSON comme pour la création).



\levelFourTitle{Quel code de statut HTTP ?}


Dans la description même de la requête \CodeInline{PUT}, le code de statut à utiliser est explicité: \CodeInline{200}.



\begin{Quotation}
A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response.
\end{Quotation}



\image{http://zestedesavoir.com/media/galleries/3183/1773ddb0-eaed-4427-a3ed-c01c51cb56a9.png}[Cinématique de la mise à jour complète]


\begin{Information}
Juste pour rappel, comme pour la récupération d'une ressource, si le client essaye de mettre à jour une ressource inexistante, nous aurons un \CodeInline{404}.
\end{Information}


\levelFourTitle{Mise à jour d'un lieu}


Pour une mise à jour complète, un utilisateur devra faire une requête \CodeInline{PUT} sur l'URL \CodeInline{rest-api.local/places/\{id\}} où \CodeInline{\{id\}} représente l'identifiant du lieu avec comme payload, le même qu'à la création :



\begin{CodeBlock}{json}
{
    "name": "ici un nom",
    "address": "ici une adresse"
}
\end{CodeBlock}



\begin{Error}
Le corps de la requête ne contient pas l'identifiant de la ressource vu qu'elle sera disponible dans l'URL.
\end{Error}


Le routage dans notre contrôleur se rapproche beaucoup de celle pour récupérer un lieu :



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     /**
     * @Rest\View()
     * @Rest\Put("/places/{id}")
     */
    public function putPlaceAction(Request $request)
    {
    
    }
}
\end{CodeBlock}



Les règles de validation des informations sont exactement les mêmes qu'à la création d'un lieu. Nous allons donc exploiter le même formulaire Symfony.
La seule différence ici réside dans le fait que nous devons d'abord récupérer une instance du lieu dans la base de données avant d'appliquer les mises à jour.



\begin{CodeBlock}{php}
# src/AppController/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
    // ...

     /**
     * @Rest\View()
     * @Rest\Put("/places/{id}")
     */
    public function updatePlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id')); // L'identifiant en tant que paramètre n'est plus nécessaire
        /* @var $place Place */

        if (empty($place)) {
            return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
        }

        $form = $this->createForm(PlaceType::class, $place);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            // l'entité vient de la base, donc le merge n'est pas nécessaire.
            // il est utilisé juste par soucis de clarté
            $em->merge($place);
            $em->flush();
            return $place;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



Pour tester cette méthode, nous allons utiliser Postman.



\image{http://zestedesavoir.com/media/galleries/3183/0fe63dd0-4c38-4458-aacc-520d61f007c9.png}[Requête de mise à jour complète avec Postman]


La réponse est :



\begin{CodeBlock}{json}
  {
    "id": 2,
    "name": "Mont-Saint-Michel",
    "address": "Autre adresse Le Mont-Saint-Michel"
  }
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/f643d594-d20e-4c71-8a1c-b4cd4bc071ae.png}[Réponse à la requête de mise à jour dans Postman]


\levelFourTitle{Pratiquons avec les utilisateurs}


La mise à jour complète d'un utilisateur suit exactement le même modèle que celle d'un lieu. Les contraintes de validation sont identiques à celles de la création d'un utilisateur.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\UserType;
use AppBundle\Entity\User;

class UserController extends Controller
{
    // ...

     /**
     * @Rest\View()
     * @Rest\Put("/users/{id}")
     */
    public function updateUserAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id')); // L'identifiant en tant que paramètre n'est plus nécessaire
        /* @var $user User */

        if (empty($user)) {
            return new JsonResponse(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
        }

        $form = $this->createForm(UserType::class, $user);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            // l'entité vient de la base, donc le merge n'est pas nécessaire.
            // il est utilisé juste par soucis de clarté
            $em->merge($user);
            $em->flush();
            return $user;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



\begin{Question}
Que se passe-t-il si nous faisons une requête en omettant le champ \CodeInline{address} ?
\end{Question}


Modifions notre requête en supprimant le champ \CodeInline{address} :



\begin{CodeBlock}{json}
{
    "name": "Autre-Mont-Saint-Michel"
}
\end{CodeBlock}



La réponse est une belle erreur 400:



\begin{CodeBlock}{json}
{
  "code": 400,
  "message": "Validation Failed",
  "errors": {
    "children": {
      "name": [],
      "address": {
        "errors": [
          "This value should not be blank."
        ]
      }
    }
  }
}
\end{CodeBlock}



Cela nous permet de bien valider les données envoyées par le client mais avec cette méthode, il est dans l'obligation de connaitre tous les champs afin d'effectuer sa mise à jour.



\levelThreeTitle{Mise à jour partielle d'une ressource}


\begin{Question}
Que faire alors si nous voulons modifier par exemple que le nom d'un lieu ?
\end{Question}


Jusqu'à présent, nos appels API pour modifier une ressource se contente de la remplacer par une nouvelle (en gardant l'identifiant). Mais dans une API plus complète avec des ressources avec beaucoup d'attributs, nous pouvons rapidement sentir le besoin de modifier juste quelques-uns de ces attributs.



Pour cela, la seule chose que nous devons changer dans notre API c'est le verbe HTTP utilisé.



\levelFourTitle{À la rencontre de PATCH}


Parmi toutes les méthodes que nous avons déjà pu utiliser, \CodeInline{PATCH} est la seule qui n'est pas spécifiée dans la RFC 7231 mais plutôt dans la \externalLink{RFC 5789}{https://tools.ietf.org/html/rfc5789}.



Ce standard n'est pas encore validé - \CodeInline{PROPOSED STANDARD} (au moment où ces lignes sont écrites) - mais est déjà largement utilisé.



Cette méthode doit être utilisée pour décrire \textit{un ensemble de changements} à appliquer à la ressource identifiée par son URI.



\begin{Question}
Comment décrire les changements à appliquer ?
\end{Question}


Vu que nous utilisons du JSON dans nos payload. Il existe une \externalLink{RFC 6902}{http://tools.ietf.org/html/rfc6902}, elle aussi pas encore adoptée, qui essaye de formaliser le payload d'une requête \CodeInline{PATCH} utilisant du JSON.



Par exemple, dans la \externalLink{section 4.3}{http://tools.ietf.org/html/rfc6902\#section-4.3}, nous pouvons lire la description d'une opération consistant à remplacer un champ d'une ressource :



\begin{CodeBlock}{json}
{ "op": "replace", "path": "/a/b/c", "value": 42 }
\end{CodeBlock}



Pour le cas de notre lieu, si nous voulions un correctif (patch) pour ne changer que l'adresse, il faudrait :



\begin{CodeBlock}{json}
{ "op": "replace", "path": "/address", "value": "Ma nouvelle adresse" }
\end{CodeBlock}



Outre le fait que cette méthode n'est pas beaucoup utilisée, sa mise en œuvre par un client est complexe et son traitement coté serveur l'est autant.



Donc par \textit{pragmatisme}, nous n'allons pas utiliser \CodeInline{PATCH} de cette façon.



Dans notre API, une requête \CodeInline{PATCH} aura comme payload le même que celui d'une requête \CodeInline{POST} à une grande différence près : Si un attribut n'existe pas dans le corps de la requête, nous devons conserver son ancienne valeur.



Notre requête avec comme payload :



\begin{CodeBlock}{json}
{
    "name": "Autre-Mont-Saint-Michel"
}
\end{CodeBlock}



... ne devra pas renvoyer une erreur mais juste modifier le nom de notre lieu.



\image{http://zestedesavoir.com/media/galleries/3183/1f16cb61-82f3-4e08-adf8-c4496f052c9a.png}[Cinématique de la mise à jour partielle d'une ressource]


\levelFourTitle{Mise à jour partielle d'un lieu}


L'implémentation de la mise à jour partielle avec Symfony est très proche de la mise à jour complète. Il suffit de rajouter un paramètre dans la méthode \CodeInline{submit} (\CodeInline{clearMissing = false}) et le tour est joué.
Comme son nom l'indique, avec \CodeInline{clearMissing} à \CodeInline{false}, Symfony conservera tous les attributs de l'entité \CodeInline{Place} qui ne sont pas présents dans le payload de la requête.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
    // ...

    /**
     * @Rest\View()
     * @Rest\Patch("/places/{id}")
     */
    public function patchPlaceAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id')); // L'identifiant en tant que paramètre n'est plus nécessaire
        /* @var $place Place */

        if (empty($place)) {
            return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
        }

        $form = $this->createForm(PlaceType::class, $place);

         // Le paramètre false dit à Symfony de garder les valeurs dans notre 
         // entité si l'utilisateur n'en fournit pas une dans sa requête
        $form->submit($request->request->all(), false);

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            // l'entité vient de la base, donc le merge n'est pas nécessaire.
            // il est utilisé juste par soucis de clarté
            $em->merge($place);
            $em->flush();
            return $place;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



\begin{Error}
Nous avons ici un gros copier-coller de la méthode \CodeInline{updatePlace}, un peu de refactoring ne sera pas de mal.
\end{Error}


\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{
     // ...

     /**
     * @Rest\View()
     * @Rest\Put("/places/{id}")
     */
    public function updatePlaceAction(Request $request)
    {
        return $this->updatePlace($request, true);
    }

    /**
     * @Rest\View()
     * @Rest\Patch("/places/{id}")
     */
    public function patchPlaceAction(Request $request)
    {
        return $this->updatePlace($request, false);
    }

    private function updatePlace(Request $request, $clearMissing)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id')); // L'identifiant en tant que paramètre n'est plus nécessaire
        /* @var $place Place */

        if (empty($place)) {
            return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
        }

        $form = $this->createForm(PlaceType::class, $place);

        // Le paramètre false dit à Symfony de garder les valeurs dans notre
        // entité si l'utilisateur n'en fournit pas une dans sa requête
        $form->submit($request->request->all(), $clearMissing);

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($place);
            $em->flush();
            return $place;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



En relançant notre requête, la réponse est bien celle attendue :



\image{http://zestedesavoir.com/media/galleries/3183/12a79295-03b5-4554-a3b2-952651aa5301.png}[Requête de mise à jour partielle avec Postman]


\image{http://zestedesavoir.com/media/galleries/3183/d8b54e56-0727-4582-aa87-8e6c70903d2f.png}[Réponse de la mise à jour dans Postman]


\levelFourTitle{Pratiquons avec les utilisateurs}


\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\UserType;
use AppBundle\Entity\User;

class UserController extends Controller
{
    // ...

    /**
     * @Rest\View()
     * @Rest\Patch("/users/{id}")
     */
    public function patchUserAction(Request $request)
    {
        return $this->updateUser($request, false);
    }

    private function updateUser(Request $request, $clearMissing)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id')); // L'identifiant en tant que paramètre n'est plus nécessaire
        /* @var $user User */

        if (empty($user)) {
            return new JsonResponse(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
        }

        $form = $this->createForm(UserType::class, $user);

        $form->submit($request->request->all(), $clearMissing);

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($user);
            $em->flush();
            return $user;
        } else {
            return $form;
        }
    }
}
\end{CodeBlock}



Au fur et à mesure de nos développements, nous nous rendons compte que notre API est très uniforme, donc facile à utiliser pour un client. Mais aussi l'implémentation serveur l'est autant. Cette uniformité facilite grandement le développement d'une API RESTful et notre productivité est décuplée !



\levelFourTitle{Gestion des erreurs avec FOSRestBundle}


Jusque-là, nous utilisons un objet \CodeInline{JsonResponse} lorsque la ressource recherchée n'existe pas. Cela fonctionne bien mais nous n'utilisons pas FOSRestBundle de manière appropriée.
Au lieu de renvoyer une réponse JSON, nous allons juste renvoyer une vue FOSRestBundle et laisser le view handler le formater en JSON.
En procédant ainsi, nous pourrons plus tard exploiter toutes les fonctionnalités de ce bundle comme par exemple changer le format des réponses (par exemple renvoyer du XML) sans modifier notre code.
Pour ce faire, il suffit de remplacer toutes les lignes :



\begin{CodeBlock}{php}
return new JsonResponse(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
\end{CodeBlock}



Par



\begin{CodeBlock}{php}
return \FOS\RestBundle\View\View::create(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
\end{CodeBlock}



Il faudra aussi faire de même avec le contrôleur \textbf{\textit{UserController}}.



\levelThreeTitle{Notre application vu selon le modèle de Richardson}


Pour rappel, le modèle de Richardson est un modèle qui permet d'évaluer son application selon les principes REST.



\image{http://zestedesavoir.com/media/galleries/3183/3cf6b12a-9169-4215-9465-bcdafb42a5b1.png}[Le niveau de maturité de notre application]


Nous pouvons facilement affirmer que notre application est au niveau 2 vu que nous exploitons les différents verbes que propose le protocole HTTP pour interagir avec des ressources identifiées par des URIs. Nous verrons plus tard comment s'approcher du niveau 3 en exploitant d'autres bundles de Symfony à notre disposition.



\horizontalLine



Nos tableaux récapitulatifs s'étoffent encore plus et nous pouvons rajouter les opérations de mise à jour.



\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Opération souhaitée & Verbe HTTP \\ \hline
\rowfont[l]{}
Lecture & GET \\ \hline
Création & POST \\ \hline
Suppression & DELETE \\ \hline
Modification complète (remplacement) & PUT \\ \hline
Modification partielle & PATCH \\ \hline
\end{longtabu}


\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Code statut & Signification \\ \hline
\rowfont[l]{}
200 & Tout s'est bien passé et la réponse a du contenu \\ \hline
204 & Tout s'est bien passé mais la réponse est vide \\ \hline
400 & Les données envoyées par le client sont invalides \\ \hline
404 & La ressource demandée n'existe pas \\ \hline
500 & Une erreur interne a eu lieu sur le serveur \\ \hline
\end{longtabu}


\levelTwoTitle{Relations entre ressources}


Maintenant que nous pouvons effectuer toutes les opérations CRUD (Créer, Lire, Mettre à jour et Supprimer) sur nos ressources, qu'est ce qui pourrait rester pour avoir une API pleinement fonctionnelle ?



Actuellement, nous avons une liste d'utilisateurs d'un côté et une liste de lieux d'un autre. Mais l'objectif de notre application est de pouvoir proposer à chaque utilisateur, selon ses centres d'intérêts, une idée de sortie en utilisant les différents lieux référencés.



Nous pouvons imaginer qu'un utilisateur passionné d'histoire ou d'architecture irait plutôt visiter un musée, un château, etc. Ou encore, selon le budget dont nous disposons, le tarif pour accéder à ces différents lieux pourrait être un élément important.



En résumé, nos ressources doivent avoir des relations entre elles et c'est ce que nous allons aborder dans cette partie du cours.



\levelThreeTitle{Hiérarchie entre ressources : la notion de sous-ressources}


\levelFourTitle{Un peu de conception}


Supposons qu'un lieu ait un ou plusieurs tarifs par exemple moins de 12 ans et tout public.
En termes de conception de la base de données, une relation \CodeInline{oneToMany} permet de gérer facilement cette situation et donc d'interagir avec les tarifs d'un lieu donné.



\begin{Question}
Comment matérialiser une telle relation avec une API qui suit les contraintes REST ?
\end{Question}


Si nous créons une URI nommée \CodeInline{rest-api.local/prices}, nous pouvons effectivement accéder à nos prix comme pour les lieux ou les utilisateurs. Mais nous aurons accès à \textbf{l'ensemble des tarifs} appliqués pour \textbf{tous les lieux} de notre application.



Pour accéder aux prix d'un lieu \CodeInline{1}, il serait tentant de rajouter un paramètre du style \CodeInline{rest-api.local/prices?place\_id=1} mais, la répétition étant pédagogique, nous allons regarder à nouveau le deuxième chapitre "Premières interactions avec les ressources" :



\begin{Quotation}
la \externalLink{RFC 3986}{https://tools.ietf.org/html/rfc3986\#section-3.4} spécifie clairement les query strings comme étant des composants qui contiennent des données \textit{non-hiérarchiques}.
\end{Quotation}



Nous avons une notion d'hièrarchie entre un lieu et \textbf{ses} tarifs et donc cette relation doit apparaitre dans notre URI.



\CodeInline{rest-api.local/prices/1} ferait-il l'affaire ? Sûrement pas, cette URL désigne le tarif ayant comme identifiant \CodeInline{1}.



Pour trouver la bonne URL, nous devons commencer par le possesseur dans la relation ici c'est un lieu qui a des tarifs, donc \CodeInline{rest-api.local/places/\{id\}} doit être le début de notre URL. Ensuite, il suffit de rajouter l'identifiant de la collection de prix que nous appelerons \CodeInline{prices}.



En définitif, \CodeInline{rest-api.local/places/\{id\}/prices} permet de désigner clairement les tarifs pour le lieu ayant comme identifiant \CodeInline{\{id\}}.



\image{http://zestedesavoir.com/media/galleries/3183/1f03ca59-2b22-4589-8fee-01941d171561.png}[Hiérarchie entre les ressources]


Une fois que nous avons identifié notre ressource, tous les principes déjà abordés pour interagir avec une ressource s'appliquent.




\begin{center}
\begin{longtabu} spread 0pt {|X[-1]|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Opération souhaitée & Verbe HTTP & URI \\ \hline
\rowfont[l]{}
Récupérer tous les prix d'un lieu & GET & /places\{id\}/prices \\ \hline
Récupérer un seul prix d'un lieu & GET & /places/\{id\}/prices/\{price\_id\} \\ \hline
Créer un nouveau prix pour un lieu & POST & /places\{id\}/prices \\ \hline
Suppression d'un prix pour un lieu & DELETE & /places/\{id\}/prices/\{price\_id\} \\ \hline
Mise à jour complète d'un prix d'un lieu & PUT & /places/\{id\}/prices/\{price\_id\} \\ \hline
Mise à jour partielle d'un prix d'un lieu & PATCH & /places/\{id\}/prices/\{price\_id\} \\ \hline
\end{longtabu}

\end{center}


\levelFourTitle{Pratiquons avec les lieux}


Pour mettre en pratique toutes ces informations, nous allons ajouter deux nouveaux appels à notre API :



\begin{itemize}
\item un pour créer un nouveau prix ;
\item un pour lister tous les prix d'un lieu.
\end{itemize}


Nous considérons qu'un prix a deux caractéristiques :



\begin{itemize}
\item un type (tout public, moins de 12 ans, etc.) ;
\item une valeur (10, 15.5, 22.75, 29.99, etc.) qui désigne le tarif en euros.
\end{itemize}


Pour l'instant, seul deux types de prix sont supportés :



\begin{itemize}
\item \textit{less\_than\_12} pour moins de 12 ans ;
\item \textit{for\_all} pour tout public.
\end{itemize}


Commençons par la base de données en créant une nouvelle entité \textbf{\textit{Price}}, nous rajouterons une contrainte d'unicité sur le type et le lieu afin de nous assurer qu'un lieu ne pourra pas avoir deux prix du même type :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/Price.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="prices",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="prices_type_place_unique", columns={"type", "place_id"})}
 * )
 */
class Price
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $type;
    
    /**
     * @ORM\Column(type="float")
     */
    protected $value;

    /**
     * @ORM\ManyToOne(targetEntity="Place", inversedBy="prices")
     * @var Place
     */
    protected $place;
 
    // tous les getters et setters
}
\end{CodeBlock}



Nous utilisons une relation bidirectionnelle car nous voulons afficher les prix d'un lieu en plus des informations de base lorsqu'un client de l'API consulte les informations de ce lieu.



\begin{CodeBlock}{php}
# src/AppBundle/Entity/Place.php
<?php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;

/**
 * @ORM\Entity()
 * @ORM\Table(name="places",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="places_name_unique",columns={"name"})}
 * )
 */
class Place
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $name;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $address;

    /**
     * @ORM\OneToMany(targetEntity="Price", mappedBy="place")
     * @var Price[]
     */
    protected $prices;

    public function __construct()
    {
        $this->prices = new ArrayCollection();
    }
    // tous les getters et setters
}
\end{CodeBlock}



N'oublions pas de mettre à jour la base de données avec :



\begin{CodeBlock}{bash}
php bin/console doctrine:schema:update --dump-sql --force
\end{CodeBlock}



La création d'un prix nécessite quelques règles de validation que nous devons implémenter.



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml

# ...

AppBundle\Entity\Price:
    properties:
        type:
            - NotNull: ~
            - Choice:
                choices: [less_than_12, for_all]
        value:
            - NotNull: ~
            - Type: numeric
            - GreaterThanOrEqual:
                value: 0
\end{CodeBlock}



Il ne reste plus qu'à créer le formulaire associé :



\begin{CodeBlock}{php}
# src/AppBundle/Form/Type/PriceType.php
<?php
namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class PriceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        // Pas besoin de rajouter les options avec ChoiceType vu que nous allons l'utiliser via API.
        // Le formulaire ne sera jamais affiché
        $builder->add('type');
        $builder->add('value');
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Price',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



Les deux appels seront mis en place dans un nouveau contrôleur pour des raisons de clarté. Mais il est parfaitement possible de le mettre dans le contrôleur déjà existant. Nous aurons un nouveau dossier nommé \CodeInline{src/AppBundle/Controller/Place} qui contiendra un contrôleur \CodeInline{PriceController}.



Avec ce découpage des fichiers, nous mettons en évidence la relation hiérarchique entre \textit{Place} et \textit{Price}.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/Place/PriceController.php
<?php
namespace AppBundle\Controller\Place;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations

class PriceController extends Controller
{

    /**
     * @Rest\View()
     * @Rest\Get("/places/{id}/prices")
     */
    public function getPricesAction(Request $request)
    {
       
    }

     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED)
     * @Rest\Post("/places/{id}/prices")
     */
    public function postPricesAction(Request $request)
    {
       
    }
}
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# app/config/routing.yml
app:
    resource: "@AppBundle/Controller/DefaultController.php"
    type:     annotation

places:
    type:     rest
    resource: AppBundle\Controller\PlaceController

prices:
    type:     rest
    resource: AppBundle\Controller\Place\PriceController

users:
    type:     rest
    resource: AppBundle\Controller\UserController
\end{CodeBlock}



Au niveau des URL utilisées dans le routage, il suffit de se référer au tableau plus haut. 
Finissons notre implémentation en ajoutant de la logique aux actions du contrôleur :



\begin{CodeBlock}{php}
# src/AppBundle/Controller/Place/PriceController.php
<?php
namespace AppBundle\Controller\Place;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PriceType;
use AppBundle\Entity\Price;

class PriceController extends Controller
{

    /**
     * @Rest\View()
     * @Rest\Get("/places/{id}/prices")
     */
    public function getPricesAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id')); // L'identifiant en tant que paramétre n'est plus nécessaire
        /* @var $place Place */

        if (empty($place)) {
            return $this->placeNotFound();
        }

        return $place->getPrices();
    }


     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED)
     * @Rest\Post("/places/{id}/prices")
     */
    public function postPricesAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id'));
        /* @var $place Place */

        if (empty($place)) {
            return $this->placeNotFound();
        }

        $price = new Price();
        $price->setPlace($place); // Ici, le lieu est associé au prix
        $form = $this->createForm(PriceType::class, $price);

        // Le paramétre false dit à Symfony de garder les valeurs dans notre
        // entité si l'utilisateur n'en fournit pas une dans sa requête
        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($price);
            $em->flush();
            return $price;
        } else {
            return $form;
        }
    }

    private function placeNotFound()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
    }
}
\end{CodeBlock}



Le principe reste le même qu'avec les différentes actions que nous avons déjà implémentées.
Il faut juste noter que lorsque nous créons un prix, nous pouvons lui associer un lieu en récupérant l'identifiant du lieu qui est dans l'URL de la requête.



Pour tester nos nouveaux appels, nous allons créer un nouveau prix pour le lieu. Voici le payload JSON utilisé :



\begin{CodeBlock}{json}
{
    "type": "less_than_12",
    "value":  5.75
}
\end{CodeBlock}



Requête :



\image{http://zestedesavoir.com/media/galleries/3183/d9e353f5-61e9-4d03-ac7c-221d73368155.png}[Corps de la requête de création d'un lieu avec Postman]


Réponse :



\begin{CodeBlock}{json}
{
  "error": {
    "code": 500,
    "message": "Internal Server Error",
    "exception": [
      {
        "message": "A circular reference has been detected (configured limit: 1).",
        "class": "Symfony\\Component\\Serializer\\Exception\\CircularReferenceException",
        "trace": [ "..." ]
      }
    ]
  }
}
\end{CodeBlock}



\begin{Error}
Nous obtenons une belle erreur interne ! Pourquoi une exception avec comme message \CodeInline{A circular reference has been detected (configured limit: 1).} ?
\end{Error}


\levelThreeTitle{Les groupes avec le sérialiseur de Symfony}


Nous venons de faire face à une erreur assez commune lorsque nous travaillons avec un sérialiseur sur des entités avec des relations.



Le problème que nous avons ici est simple à expliquer. Lorsque le sérialiseur affiche un prix, il doit sérialiser le type, la valeur mais aussi le lieu associé.



Nous aurons donc :



\begin{CodeBlock}{json}
{
    "id": 1,
    "type": "less_than_12",
    "value": 5.75,
    "place": {
        "..." : "..."
    }
}
\end{CodeBlock}



Les choses se gâtent lorsque le sérialiseur va essayer de transformer le lieu contenu dans notre objet. Ce lieu contient lui-même l'objet prix qui devra être sérialisé à nouveau. Et la boucle se répète à l'infini.



\image{http://zestedesavoir.com/media/galleries/3183/8490e0e9-26d3-4f09-947b-7f44be413d3d.png}[Référence circulaire]


Pour prévenir ce genre de problème, le sérialiseur de Symfony utilise \externalLink{la notion de groupe}{http://symfony.com/doc/current/components/serializer.html\#attributes-groups}. L'objectif des groupes est de définir les attributs qui seront sérialisés selon la vue que nous voulons afficher.



Reprenons le cas de notre prix pour mieux comprendre. Lorsque nous affichons les informations sur un prix, ce qui nous intéresse c'est :



\begin{itemize}
\item son identifiant ;
\item son type ;
\item sa valeur ;
\item et son lieu associé.
\end{itemize}


Jusque-là notre problème reste entier. Mais lorsque nous allons afficher ce fameux lieu, nous devons limiter les informations affichées. Ainsi, nous pouvons décider que le lieu embarqué dans la réponse ne doit contenir que :



\begin{itemize}
\item son identifiant ;
\item son nom ;
\item et son adresse.
\end{itemize}


Le champ \CodeInline{prices} doit être ignoré.



Tous ces attributs peuvent représenter un groupe : \CodeInline{price}. À chaque fois que le sérialiseur est utilisé en spécifiant le groupe \CodeInline{price} alors seul ces attributs seront sérialisés.



De la même façon, lorsque nous voudrons afficher un lieu, tous les attributs seront affichés en excluant un seul attribut : le champ \CodeInline{place} de l'objet \CodeInline{Price}.



La configuration Symfony pour obtenir un tel comportement est assez simple :



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serialization.yml
AppBundle\Entity\Place:
    attributes:
        id:
            groups: ['place', 'price']
        name:
            groups: ['place', 'price']
        address:
            groups: ['place', 'price']
        prices:
            groups: ['place']


AppBundle\Entity\Price:
    attributes:
        id:
            groups: ['place', 'price']
        type:
            groups: ['place', 'price']
        value:
            groups: ['place', 'price']
        place:
            groups: ['price']
\end{CodeBlock}



Ce fichier de configuration définit deux choses essentielles:



\begin{itemize}
\item Si nous utilisons le groupe \CodeInline{price} avec le sérialiseur, seuls les attributs dans ce groupe seront affichés ;
\item et de la même façon, seuls les attributs dans le groupe \CodeInline{place} seront affichés si celui-ci est utilisé avec notre sérialiseur.
\end{itemize}


\begin{Information}
Il est aussi possible de déclarer les règles de sérialisations avec des annotations sur nos entités. Pour en savoir plus, il est préférable de consulter \externalLink{la documentation officielle}{http://symfony.com/doc/current/cookbook/serializer.html}. Les fichiers de configuration peuvent aussi être placés dans un dossier \textbf{\textit{src/AppBundle/Resources/config/serialization/}} afin de mieux les isoler.
\end{Information}


Pour l'utiliser dans notre contrôleur avec \textit{FOSRestBundle}, la modification à faire est très simple. Il suffit d'utiliser l'attribut \CodeInline{serializerGroups} de l'annotation \CodeInline{View}.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/Place/PriceController.php
<?php
namespace AppBundle\Controller\Place;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PriceType;
use AppBundle\Entity\Price;

class PriceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"price"})
     * @Rest\Get("/places/{id}/prices")
     */
    public function getPricesAction(Request $request)
    {
         // ...
    }


     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"price"})
     * @Rest\Post("/places/{id}/prices")
     */
    public function postPricesAction(Request $request)
    {
        // ...
    }

    private function placeNotFound()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
    }
}
\end{CodeBlock}



Pour tester cette configuration, récupérons la liste des prix du lieu \CodeInline{1}.



\image{http://zestedesavoir.com/media/galleries/3183/06230df9-2232-4a84-9b5b-e8110b8da881.png}[Requête Postman pour récupérer les prix d'un lieu]


La réponse ne contient que les attributs que nous avons affectés au groupe \CodeInline{price}.



\begin{CodeBlock}{json}
[
  {
    "id": 1,
    "type": "less_than_12",
    "value": 5.75,
    "place": {
      "id": 1,
      "name": "Tour Eiffel",
      "address": "5 Avenue Anatole France, 75007 Paris"
    }
  }
]
\end{CodeBlock}



De la même façon, nous devons modifier le contrôleur des lieux pour définir le ou les groupes à utiliser pour la sérialisation des réponses.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/PlaceController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     */
    public function getPlacesAction(Request $request)
    {
        // ...
    }

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places/{id}")
     */
    public function getPlaceAction(Request $request)
    {
        // ...
    }

     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"place"})
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
        // ...
    }

     /**
     * @Rest\View(statusCode=Response::HTTP_NO_CONTENT, serializerGroups={"place"})
     * @Rest\Delete("/places/{id}")
     */
    public function removePlaceAction(Request $request)
    {
        // ...
    }

     /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Put("/places/{id}")
     */
    public function updatePlaceAction(Request $request)
    {
        // ...
    }

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Patch("/places/{id}")
     */
    public function patchPlaceAction(Request $request)
    {
        // ...
    }

    // ...
}
\end{CodeBlock}



Et récupérons le lieu \CodeInline{1} pour voir la réponse :



\image{http://zestedesavoir.com/media/galleries/3183/cb94598a-6535-470e-ae42-8b818d2bd00a.png}[Requête Postman pour récupérer un lieu]


\begin{CodeBlock}{json}
{
  "id": 1,
  "name": "Tour Eiffel",
  "address": "5 Avenue Anatole France, 75007 Paris",
  "prices": [
    {
      "id": 1,
      "type": "less_than_12",
      "value": 5.75
    }
  ]
}
\end{CodeBlock}



Grâce aux groupes, les références circulaires ne sont plus qu'un mauvais souvenir.



\begin{Warning}
Les groupes du sérialiseur de Symfony ne sont supportés que depuis la version 2.0 de \textit{FOSRestBundle}. Dans le cas où vous utilisez une version de \textit{FOSRestBundle} inférieure à la 2.0, il faudra alors utiliser le \externalLink{JMSSerializerBundle}{http://jmsyst.com/bundles/JMSSerializerBundle} à la place du sérialiseur de base de Symfony.
\end{Warning}


\levelThreeTitle{Mise à jour de la suppression d'une ressource}


Avec la gestion des relations entre ressources, la méthode de suppression des lieux doit être revue. En effet, vu qu'un lieu peut avoir des prix, nous devons nous assurer qu'à sa suppression tous les prix qui lui sont associés le seront aussi. Sans cela, la clé étrangère empêcherait toute suppression d'un lieu ayant des prix.



La modification à effectuer reste cependant assez minime.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...

class PlaceController extends Controller
{
// ...

     /**
     * @Rest\View(statusCode=Response::HTTP_NO_CONTENT, serializerGroups={"place"})
     * @Rest\Delete("/places/{id}")
     */
    public function removePlaceAction(Request $request)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $place = $em->getRepository('AppBundle:Place')
                    ->find($request->get('id'));
        /* @var $place Place */

        if (!$place) {
            return;
        }

        foreach ($place->getPrices() as $price) {
            $em->remove($price);
        }
        $em->remove($place);
        $em->flush();
    }
// ...
}
\end{CodeBlock}



\horizontalLine



Avec ce chapitre, nous venons de faire un tour complet des concepts de base pour développer une API RESTful. 
Les possibilités d'évolution de notre API sont nombreuses et ne dépendent que de notre imagination.



Maintenant que les sous ressources n'ont plus de secrets pour nous, nous allons implémenter la fonctionnalité de base de notre API : Proposer une idée de sortie à un utilisateur.



\levelTwoTitle{TP :  Le clou du spectacle - Proposer des suggestions aux utilisateurs}


Nous allons dans cette partie finaliser notre API en rajoutant un système de suggestion pour les utilisateurs. Tous les concepts de base du style d'architecture qu'est REST ont déjà été abordés. L'objectif est donc de mettre en pratique les connaissances acquises.



\levelThreeTitle{Énoncé}


Afin de gérer les suggestions, nous partons sur un design simple. Dans l'application, nous aurons une notion de préférences et de thèmes. Chaque utilisateur pourra choisir un ou plusieurs préférences avec une note sur 10. Et de la même façon, un lieu sera lié à un ou plusieurs thèmes avec une note sur 10.



Un lieu sera suggéré à un utilisateur si au moins une préférence de l'utilisateur correspond à un des thèmes du lieu et que le niveau de correspondance est supérieur ou égale à 25.



\begin{Information}
Le niveau de correspondance est une valeur calculée qui nous permettra de quantifier à quel point \textbf{un lieu pourrait intéresser un utilisateur}. La méthode de calcul est détaillée ci-dessous.
\end{Information}


Pour un utilisateur donné, il faut d'abord prendre toutes ses préférences.
Ensuite \textbf{pour chaque lieu} enregistré dans l'application, si une des préférences de l'utilisateur correspond au thème du lieu, il faudra calculer le produit : \textbf{valeur de la préférence de l'utilisateur * valeur du thème du lieu}.



La somme de tous ces produits représente le \textit{niveau de correspondance} pour ce lieu .



Un exemple vaut mieux que mille discours :
Un utilisateur a comme préférences (art, 5), (history, 8) et (architecture, 2). Un lieu 1 a comme thèmes (architecture, 3), (sport, 2), (history, 3). et un lieu 2 a comme thèmes (art, 3), (science-fiction, 2).



Pour le lieu 1, nous avons 2 thèmes qui correspondent à ses préférences: history et architecture.




\begin{center}
\begin{longtabu} spread 0pt {|X[-1]|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
 & history & architecture \\ \hline
\rowfont[l]{}
utilisateur & 8 & 2 \\ \hline
lieu 1 & 4 & 3 \\ \hline
\end{longtabu}

\end{center}


La valeur de correspondance est donc : $$8 * 4 + 2 * 3 = 32 + 6 = 38$$
38 est supérieur à 25 donc c'est une suggestion valide.



Pour le lieu 2, nous avons un seul thème qui correspond : art.




\begin{center}
\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
 & art \\ \hline
\rowfont[l]{}
utilisateur & 5 \\ \hline
lieu 2 & 3 \\ \hline
\end{longtabu}

\end{center}


La valeur de correspondance est donc : $$5 * 3 = 15$$
15 étant inférieur à 25 donc ce n'est pas une suggestion valide.



\levelThreeTitle{Détails de l'implémentation}


Comme pour la liste des types de tarifs, nous disposons d'une liste de préférences et de thèmes prédéfinis :



\begin{itemize}
\item Art (art) ;
\item Architecture (architecture) ;
\item Histoire (history) ;
\item Sport (sport) ;
\item Science-fiction (science-fiction).
\end{itemize}


Une préférence associée à un utilisateur doit avoir 3 attributs :



\begin{itemize}
\item id : représente l'identifiant unique de la préférence utilisateur (auto-incrémenté) ;
\item name : une des valeurs parmi la liste des préférences prédéfinies ;
\item value : un entier désignant le niveau de préférence sur 10.
\end{itemize}


Un thème lié à un lieu doit avoir 3 attributs :



\begin{itemize}
\item id : représente l'identifiant unique du thème (auto-incrémenté) ;
\item name : une des valeurs parmi la liste des thèmes prédéfinies ;
\item value : un entier désignant le niveau du thème sur 10.
\end{itemize}


Une préférence associée à un utilisateur doit avoir une relation bidirectionnelle avec cet utilisateur et idem pour les lieux.



Une même préférence ne peut pas être associée deux fois à un même utilisateur ou un même lieu. (ex : un utilisateur ne peut pas avoir 2 fois la préférence art) et idem pour les lieux.



Il faudra 2 tables (donc 2 entités distinctes) :



\begin{itemize}
\item preferences (entité \textbf{\textit{Preference}}) pour stocker les préférences utilisateurs ;
\item themes (entité \textbf{\textit{Theme}}) pour stocker les thèmes sur les lieux.
\end{itemize}


Il faudra 3 appels API :



\begin{itemize}
\item un permettant d'ajouter une préférence pour un utilisateur avec sa valeur ;
\item un permettant d'ajouter un thème à un lieu avec sa valeur ;
\item un pour récupérer les suggestions d'un utilisateur.
\end{itemize}


\begin{Information}
Une ressource REST n'est pas forcément une entité brute de notre modèle de données. Nous pouvons utiliser un appel GET sur l'URL rest-api.local/users/1/suggestions pour récupérer la liste des suggestions pour l'utilisateur 1.
\end{Information}


Une fois que les préférences et les thèmes seront rajoutés, les appels de listing des utilisateurs et des lieux doivent remonter respectivement les informations sur les préférences et les informations sur les thèmes. Il faudra donc penser à gérer les références circulaires.



À vous de jouer !



\levelThreeTitle{Travail préparatoire}


\levelFourTitle{Gestion des thèmes pour les lieux}


Nous allons commencer notre implémentation en mettant en place la gestion des thèmes.



L'entité contiendra les champs cités plus haut avec en plus une contrainte d'unicité sur le nom d'un thème et l'identifiant du lieu.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/Theme.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="themes",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="themes_name_place_unique", columns={"name", "place_id"})}
 * )
 */
class Theme
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $name;
    
    /**
     * @ORM\Column(type="integer")
     */
    protected $value;

    /**
     * @ORM\ManyToOne(targetEntity="Place", inversedBy="themes")
     * @var Place
     */
    protected $place;

    public function getId()
    {
        return $this->id;
    }
     
    public function setId($id)
    {
        $this->id = $id;
    }
     
    public function getName()
    {
        return $this->name;
    }
     
    public function setName($name)
    {
        $this->name = $name;
    }
     
    public function getValue()
    {
        return $this->value;
    }
     
    public function setValue($value)
    {
        $this->value = $value;
    }
     
    public function getPlace()
    {
        return $this->place;
    }
     
    public function setPlace(Place $place)
    {
        $this->place = $place;
    }
}
\end{CodeBlock}



L'entité \CodeInline{Place} doit aussi être modifiée pour avoir une relation bidirectionnelle.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/Place.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;

/**
 * @ORM\Entity()
 * @ORM\Table(name="places",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="places_name_unique",columns={"name"})}
 * )
 */
class Place
{
    // ...

    /**
     * @ORM\OneToMany(targetEntity="Theme", mappedBy="place")
     * @var Theme[]
     */
    protected $themes;

    public function __construct()
    {
        $this->prices = new ArrayCollection();
        $this->themes = new ArrayCollection();
    }
    // ...

    public function getThemes()
    {
        return $this->themes;
    }
     
    public function setThemes($themes)
    {
        $this->themes = $themes;
    }
}
\end{CodeBlock}



Pour supporter la création de thèmes pour les lieux, nous allons créer un formulaire Symfony et les régles de validation associées.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Form/Type/ThemeType.php

namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ThemeType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('name');
        $builder->add('value');
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Theme',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



\begin{Information}
La liste des thèmes prédéfinis est utilisée pour valider le formulaire Symfony.
\end{Information}


\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml

AppBundle\Entity\Theme:
    properties:
        name:
            - NotNull: ~
            - Choice:
                choices: [art, architecture, history, science-fiction, sport]
        value:
            - NotNull: ~
            - Type: numeric
            - GreaterThan:
                value: 0
            - LessThanOrEqual:
                value: 10
\end{CodeBlock}



Pour ajouter un thème, nous allons créer un nouveau contrôleur qui ressemble à quelques lignes près à ce que nous avons déjà fait jusqu'ici.
Nous allons en profiter pour ajouter une méthode pour lister les thèmes d'un lieu donné.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/Place/ThemeController.php

namespace AppBundle\Controller\Place;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\ThemeType;
use AppBundle\Entity\Theme;

class ThemeController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"theme"})
     * @Rest\Get("/places/{id}/themes")
     */
    public function getThemesAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id'));
        /* @var $place Place */

        if (empty($place)) {
            return $this->placeNotFound();
        }

        return $place->getThemes();
    }


     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"theme"})
     * @Rest\Post("/places/{id}/themes")
     */
    public function postThemesAction(Request $request)
    {
        $place = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->find($request->get('id'));
        /* @var $place Place */

        if (empty($place)) {
            return $this->placeNotFound();
        }

        $theme = new Theme();
        $theme->setPlace($place);
        $form = $this->createForm(ThemeType::class, $theme);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($theme);
            $em->flush();
            return $theme;
        } else {
            return $form;
        }
    }

    private function placeNotFound()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'Place not found'], Response::HTTP_NOT_FOUND);
    }
}
\end{CodeBlock}



Le fichier de routage de l'application doit être modifié en conséquence pour charger ce nouveau contrôleur.



\begin{CodeBlock}{yaml}
# app/config/routing.yml

# ...

themes:
    type:     rest
    resource: AppBundle\Controller\Place\ThemeController

# ...
\end{CodeBlock}



Il ne faut pas oublier de rajouter un nouveau groupe de sérialisation pour la gestion de ces thèmes.



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serialization.yml
AppBundle\Entity\Place:
    attributes:
        id:
            groups: ['place', 'price', 'theme']
        name:
            groups: ['place', 'price', 'theme']
        address:
            groups: ['place', 'price', 'theme']
        prices:
            groups: ['place']
        themes:
            groups: ['place']

# ...

AppBundle\Entity\Theme:
    attributes:
        id:
            groups: ['place', 'theme']
        name:
            groups: ['place', 'theme']
        value:
            groups: ['place', 'theme']
        place:
            groups: ['theme']
\end{CodeBlock}



\begin{Information}
Le nouveau groupe est aussi utilisé pour configurer la sérialisation de l'entité \CodeInline{Place}afin  d'éviter les références circulaires.
\end{Information}


\levelFourTitle{Gestions des préférences}


Pour la gestion des utilisateurs, nous allons suivre exactement le même schéma d'implémentation. Les extraits de code fournis se passeront donc de commentaires.



Commençons par l'entité pour la gestion des préférences et le formulaire permettant de le gérer.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/Preference.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="preferences",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="preferences_name_user_unique", columns={"name", "user_id"})}
 * )
 */
class Preference
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $name;
    
    /**
     * @ORM\Column(type="integer")
     */
    protected $value;

    /**
     * @ORM\ManyToOne(targetEntity="User", inversedBy="preferences")
     * @var User
     */
    protected $user;

    public function getId()
    {
        return $this->id;
    }
     
    public function setId($id)
    {
        $this->id = $id;
    }
     
    public function getName()
    {
        return $this->name;
    }
     
    public function setName($name)
    {
        $this->name = $name;
    }
     
    public function getValue()
    {
        return $this->value;
    }
     
    public function setValue($value)
    {
        $this->value = $value;
    }
     
    public function getUser()
    {
        return $this->user;
    }
     
    public function setUser(User $user)
    {
        $this->user = $user;
    }
}
\end{CodeBlock}



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/User.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;

/**
* @ORM\Entity()
* @ORM\Table(name="users",
*      uniqueConstraints={@ORM\UniqueConstraint(name="users_email_unique",columns={"email"})}
* )
*/
class User
{
    // ...

     /**
     * @ORM\OneToMany(targetEntity="Preference", mappedBy="user")
     * @var Preference[]
     */
    protected $preferences;

    public function __construct()
    {
        $this->preferences = new ArrayCollection();
    }

    // ...

    public function getPreferences()
    {
        return $this->preferences;
    }
     
    public function setPreferences($preferences)
    {
        $this->preferences = $preferences;
    }
}
\end{CodeBlock}



Le formulaire associé et les règles de validation sont proches de celui des thèmes.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Form/Type/PreferenceType.php

namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class PreferenceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('name');
        $builder->add('value');
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Preference',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml

# ...

AppBundle\Entity\Preference:
    properties:
        name:
            - NotNull: ~
            - Choice:
                choices: [art, architecture, history, science-fiction, sport]
        value:
            - NotNull: ~
            - Type: numeric
            - GreaterThan:
                value: 0
            - LessThanOrEqual:
                value: 10
\end{CodeBlock}



Un nouveau contrôleur sera aussi créé pour assurer la gestion des préférences utilisateurs via notre API.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/User/PreferenceController.php

namespace AppBundle\Controller\User;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PreferenceType;
use AppBundle\Entity\Preference;

class PreferenceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"preference"})
     * @Rest\Get("/users/{id}/preferences")
     */
    public function getPreferencesAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id'));
        /* @var $user User */

        if (empty($user)) {
            return $this->userNotFound();
        }

        return $user->getPreferences();
    }


     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"preference"})
     * @Rest\Post("/users/{id}/preferences")
     */
    public function postPreferencesAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id'));
        /* @var $user User */

        if (empty($user)) {
            return $this->userNotFound();
        }

        $preference = new Preference();
        $preference->setUser($user);
        $form = $this->createForm(PreferenceType::class, $preference);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($preference);
            $em->flush();
            return $preference;
        } else {
            return $form;
        }
    }

    private function userNotFound()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
    }
}
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# app/config/routing.yml

# ...

preferences:
    type:     rest
    resource: AppBundle\Controller\User\PreferenceController
\end{CodeBlock}



Les groupes de sérialisation doivent aussi être mis à jour afin d'éviter les fameuses références circulaires.



\begin{CodeBlock}{yam}
# src/AppBundle/Resources/config/serialization.yml

# ...

AppBundle\Entity\User:
    attributes:
        id:
            groups: ['user', 'preference']
        firstname:
            groups: ['user', 'preference']
        lastname:
            groups: ['user', 'preference']
        email:
            groups: ['user', 'preference']
        preferences:
            groups: ['user']

AppBundle\Entity\Preference:
    attributes:
        id:
            groups: ['user', 'preference']
        name:
            groups: ['user', 'preference']
        value:
            groups: ['user', 'preference']
        user:
            groups: ['preference']
\end{CodeBlock}



Avec ces modifications que nous venons d'apporter, nous pouvons maintenant associer des thèmes et des préférences respectivement aux lieux et aux utilisateurs.
Nous allons donc finaliser ce chapitre en rajoutant enfin les suggestions.



\levelThreeTitle{Proposer des suggestions aux utilisateurs}


\levelFourTitle{Calcul du niveau de correspondance}


\begin{Information}
La technique utilisée pour trouver les suggestions n'est pas optimale. L'objectif ici est juste de présenter une méthode fonctionnelle et avoir une API complète.
\end{Information}


L'algorithme pour calculer le niveau de correspondance va être implémenté dans l'entité \CodeInline{User}.
À partir des thèmes d'un lieu, nous allons créer une méthode permettant de déterminer le niveau de correspondance (défini plus haut).



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/User.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;

/**
* @ORM\Entity()
* @ORM\Table(name="users",
*      uniqueConstraints={@ORM\UniqueConstraint(name="users_email_unique",columns={"email"})}
* )
*/
class User
{
    const MATCH_VALUE_THRESHOLD = 25;

    // ...

    public function preferencesMatch($themes)
    {
        $matchValue = 0;
        foreach ($this->preferences as $preference) {
            foreach ($themes as $theme) {
                if ($preference->match($theme)) {
                    $matchValue += $preference->getValue() * $theme->getValue();
                }
            }
        }

        return $matchValue >= self::MATCH_VALUE_THRESHOLD;
    }
}
\end{CodeBlock}



La méthode \CodeInline{match} de l'objet \CodeInline{Preference} permet juste de vérifier si le nom du thème est le même que celui de la préférence de l'utilisateur.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/Preference.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="preferences",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="preferences_name_user_unique", columns={"name", "user_id"})}
 * )
 */
class Preference
{
    // ...

    public function match(Theme $theme)
    {
        return $this->name === $theme->getName();
    }
}
\end{CodeBlock}



\levelFourTitle{Appel API pour récupérer les suggestions}


Pour récupérer les suggestions, il nous suffit maintenant de créer un appel dans le contrôleur \textbf{\textit{UserController}}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/UserController.php

namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\UserType;
use AppBundle\Entity\User;

class UserController extends Controller
{
    // ...

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/users/{id}/suggestions")
     */
    public function getUserSuggestionsAction(Request $request)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id'));
        /* @var $user User */

        if (empty($user)) {
            return $this->userNotFound();
        }

        $suggestions = [];

        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();

        foreach ($places as $place) {
            if ($user->preferencesMatch($place->getThemes())) {
                $suggestions[] = $place;
            }
        }
        
        return $suggestions;
    }

    // ...

    private function userNotFound()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
    }
}
\end{CodeBlock}



\begin{Warning}
Un fait important à relever ici est que la méthode, bien qu'étant dans le contrôleur des utilisateurs, renvoie des lieux. Le groupe de sérialisation utilisé est donc \textbf{place}.
\end{Warning}


Pour tester, nous avons un utilisateur défini comme suit :



\begin{CodeBlock}{json}
{
  "id": 1,
  "firstname": "My",
  "lastname": "Bis",
  "email": "my.last@test.local",
  "preferences": [
    {
      "id": 1,
      "name": "history",
      "value": 4
    },
    {
      "id": 2,
      "name": "art",
      "value": 4
    },
    {
      "id": 6,
      "name": "sport",
      "value": 3
    }
  ]
}
\end{CodeBlock}



Et la liste de lieux dans l'application est la suivante :



\begin{CodeBlock}{json}
[
  {
    "id": 1,
    "name": "Tour Eiffel",
    "address": "5 Avenue Anatole France, 75007 Paris",
    "prices": [
      {
        "id": 1,
        "type": "less_than_12",
        "value": 5.75
      }
    ],
    "themes": [
      {
        "id": 1,
        "name": "architecture",
        "value": 7
      },
      {
        "id": 2,
        "name": "history",
        "value": 6
      }
    ]
  },
  {
    "id": 2,
    "name": "Mont-Saint-Michel",
    "address": "50170 Le Mont-Saint-Michel",
    "prices": [],
    "themes": [
      {
        "id": 3,
        "name": "history",
        "value": 3
      },
      {
        "id": 4,
        "name": "art",
        "value": 7
      }
    ]
  }
]
\end{CodeBlock}



Quand nous récupérons les suggestions pour notre utilisateur, nous obtenons :



\image{http://zestedesavoir.com/media/galleries/3183/8e0c74db-049b-424c-b521-918a266cc765.png}[Récupération des suggestions pour l'utilisateur avec Postman]


\begin{CodeBlock}{json}
[
  {
    "id": 2,
    "name": "Mont-Saint-Michel",
    "address": "50170 Le Mont-Saint-Michel",
    "prices": [],
    "themes": [
      {
        "id": 3,
        "name": "history",
        "value": 3
      },
      {
        "id": 4,
        "name": "art",
        "value": 7
      }
    ]
  }
]
\end{CodeBlock}



Nous avons donc un lieu dans notre application qui correspondrait aux gouts de notre utilisateur.



\horizontalLine



Les fonctionnalités que nous voulons pour notre application peuvent être implémentées assez facilement sans se soucier des contraintes imposées par le style d'architecture REST.
REST n'intervient que pour définir l'API à utiliser pour accéder à ces fonctionnalités et nous laisse donc la responsabilité des choix techniques et de conceptions.



Vous pouvez vous entrainer et améliorer l'API en rajoutant encore plus de fonctionnalités. Nous pouvons par exemple imaginer que chaque utilisateur à un budget et que les tarifs des lieux sont pris en compte pour améliorer les suggestions.



\levelTwoTitle{REST à son paroxysme}


Il reste un point sur les contraintes REST que nous n'avons toujours pas abordé : l'Hypermédia. En plus, notre API supporte un seul format le JSON. Toutes les requêtes et toutes les réponses sont en JSON. Nous imposons donc une contrainte aux futurs clients de notre API.



Pour remédier à cela, nous allons voir comment supporter facilement d'autre format de réponse en utilisant \textit{FOSRestBundle} et le sérialiseur de Symfony.
Et pour finir, nous verrons comment mettre en place de l'hypermédia dans une API REST, son utilité et comment l'exploiter (\textit{si cela est possible}) ?



\levelThreeTitle{Supporter plusieurs formats de requêtes et de réponses}


\levelFourTitle{Cas des requêtes}


Depuis que nous avons installé \textit{FOSRestBundle}, notre API supporte déjà trois formats: le JSON, le format \textit{x-www-form-urlencoded} (utilisé par les formulaires) et le XML.



Le body listener que nous avons activé utilise déjà par défaut ces trois formats. Pour déclarer le format utilisé dans la requête, il suffit d'utiliser l'entête HTTP \CodeInline{Content-Type} qui permet de décrire le type du contenu de la requête (et même de la réponse).



Avec Postman, nous pouvons tester la création d'un utilisateur en exploitant cette fonctionnalité. Au lieu d'avoir du JSON, nous devons juste formater la requête en XML.
Le corps de la requête doit être :



\begin{CodeBlock}{xml}
<user>
    <firstname>test</firstname>
    <lastname>XML</lastname>
    <email>test@xml.fr</email>
</user>
\end{CodeBlock}



Chaque format a un type \abbr{MIME}{Multipurpose Internet Mail Extensions} qui permet de le décrire avec l'entête \CodeInline{Content-Type} :



\begin{itemize}
\item JSON: Application/json
\item XML: application/xml
\end{itemize}


\begin{Information}
C'est au client de définir dans sa requête le format utilisé pour que le serveur puisse la traiter correctement.
\end{Information}


Avec Postman, il y a un onglet \keys{Headers} qui permet de rajouter des entêtes HTTP. Pour faciliter le travail, nous pouvons aussi choisir dans l'onglet \keys{Body}, le contenu de la requête. Postman rajoutera automatiquement le bon type \abbr{MIME}{Multipurpose Internet Mail Extensions} de la requête à notre place.



\image{http://zestedesavoir.com/media/galleries/3183/8fb3c712-d2fd-4eda-b63b-9a520bbe4647.png}[Choix du type de contenu avec Postman]


\image{http://zestedesavoir.com/media/galleries/3183/a37ae749-7ad9-46dd-bb93-2a5d74e0ee25.png}[Entête rajoutée par Postman]


En envoyant la requête, l'utilisateur est créé et nous obtenons une réponse en ... JSON ! Nous allons donc voir dans la partie suivante comment autoriser plusieurs formats de réponses comme nous l'avons déjà pour les requêtes.



\begin{Information}
Il est possible de supporter d'autres formats en plus de celle par défaut. Pour en savoir plus, vous pouvez consulter \externalLink{la documentation officielle}{http://symfony.com/doc/1.7/bundles/FOSRestBundle/body\_listener.html}.
\end{Information}


\levelFourTitle{Cas des réponses}


L'utilisation de l'annotation \CodeInline{View} de \textit{FOSRestBundle} permet de créer des réponses qui peuvent être affichées dans différents formats. Dans tous nos contrôleurs, nous nous contentons de renvoyer un objet ou un tableau et ces données sont envoyées au client dans le bon format.



Pour supporter plusieurs formats, les données renvoyées par les contrôleurs ne changent pas. Nous devons juste configurer \textit{FOSRestBundle} correctement.
Ce bundle supporte deux types de réponses :



\begin{itemize}
\item celles ne nécessitant pas de template pour être affichées : celles au format JSON, au format XML, etc. Il suffit d'avoir les données pour les encoder et le sérialiseur fait le reste du travail.
\item celles qui nécessitent un template : le html, etc. Pour ce genre de réponse, nous devons avoir des informations en plus permettant de \textit{décorer} la réponse (mise en page, CSS, etc.) et le moteur de rendu (ici Twig) s'occupe du reste.
\end{itemize}


Dans le cadre du cours, nous allons juste aborder le premier type de réponse. \externalLink{La documentation}{http://symfony.com/doc/current/bundles/FOSRestBundle/2-the-view-layer.html} couvre bien l'ensemble du sujet si cela vous intéresse.



Pour activer ces fonctionnalités, nous devons configurer deux sections. La première nous permettra de déclarer les formats de réponses supportés et la seconde nous permettra de configurer la priorité entre ces formats, le comportement du serveur si aucun format n'est choisi par le client, etc.



Nous allons supporter les formats JSON et XML pour les réponses. La configuration devient maintenant (la clé \CodeInline{formats} a été rajoutée) :



\begin{CodeBlock}{yaml}
# app/config/config.yml
# ...

fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
        formats:
            json: true
            xml: true
    format_listener:
        rules:
            - { path: '^/', priorities: ['json'], fallback_format: 'json', prefer_extension: false }
    body_listener:
        enabled: true
\end{CodeBlock}



En réalité, ces deux formats sont déjà activés par défaut mais par soucis de clarté nous allons les laisser visibles dans le fichier de configuration.



Le reste de la configuration se fait avec la clé \CodeInline{rules}. C'est au niveau des priorités (clé \CodeInline{priorities}) que les formats supportés sont définis. Pour notre configuration, nous avons une seule règle. Mais il est tout à fait possible de définir plusieurs règles différentes selon les URL utilisées. Nous pouvons imaginer par exemple une règle par version de l'api, ou bien encore une règle par ressources.



Il suffit de rajouter le format XML aux priorités et notre API pourra répondre aussi bien en XML qu'en JSON.



\begin{CodeBlock}{yaml}
# app/config/config.yml
# ...

fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
        formats:
            json: true
            xml: true
    format_listener:
        rules:
            - { path: '^/', priorities: ['json', 'xml'], fallback_format: 'json', prefer_extension: false }
    body_listener:
        enabled: true
\end{CodeBlock}



\begin{Information}
C'est maintenant au client d'informer le serveur sur le ou les formats qu'il préfère.
\end{Information}


\begin{Error}
L'ordre de déclaration est très important ici. Si une requête ne spécifie aucun format alors le serveur choisira du JSON.
\end{Error}


\levelFourTitle{La négociation de contenu}


La négociation de contenu est un mécanisme \externalLink{du protocole HTTP}{http://tools.ietf.org/html/rfc7231\#section-4.3.4} qui permet de proposer plusieurs formats pour une même ressource.
Pour sa mise en œuvre, le client doit envoyer un entête HTTP de la famille \CodeInline{Accept}. Nous avons entre autres :




\begin{center}
\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Entête & Utilisation \\ \hline
\rowfont[l]{}
Accept & Pour choisir un média type (text, json, html etc). \\ \hline
Accept-Charset & Pour choisir le jeu de caractères (iso-8859-1, utf8, etc.) \\ \hline
Accept-Language & Pour choisir le langage (français, anglais, etc.) \\ \hline
\end{longtabu}

\end{center}


L'entête qui nous intéresse ici est \CodeInline{Accept}. Comme pour l'entête \CodeInline{Content-Type}, la valeur de cet entête doit contenir un type \abbr{MIME}{Multipurpose Internet Mail Extensions}.



Mais en plus, avec cet entête, nous pouvons déclarer plusieurs formats à la fois en prenant le soin de définir un ordre de préférence en utilisant un facteur de qualité.



\begin{Information}
Le facteur de qualité (\CodeInline{q}) est un nombre compris entre 0 et 1 qui permet de définir l'ordre de préférence. Plus \CodeInline{q} est élevé, plus le type \abbr{MIME}{Multipurpose Internet Mail Extensions} associé est prioritaire.
\end{Information}


Une requête avec comme entête \CodeInline{Accept: application/json;q=0.7, application/xml;q=1,} veut dire que le client préfère du XML et en cas d'indisponibilité du XML alors du JSON.



Une requête avec comme entête \CodeInline{Accept: application/xml} veut dire que le client préfère du XML. Si le facteur de qualité n'est pas spécifié, sa valeur est à \CodeInline{1}.



Pour tester, nous allons ajouter cet entête à une requête pour lister tous les lieux de notre API.



\image{http://zestedesavoir.com/media/galleries/3183/2ea83009-b7f6-46c8-b29b-5adc8c0ef88f.png}[Récupération des lieux en XML avec Postman]


La réponse est bien en XML et nous pouvons tester avec n'importe quelle méthode de notre API.



\begin{CodeBlock}{xml}
<?xml version="1.0"?>
<response>
    <item key="0">
        <id>1</id>
        <name>Tour Eiffel</name>
        <address>5 Avenue Anatole France, 75007 Paris</address>
        <prices>
            <id>1</id>
            <type>less_than_12</type>
            <value>5.75</value>
        </prices>
        <themes>
            <id>1</id>
            <name>architecture</name>
            <value>7</value>
        </themes>
        <themes>
            <id>2</id>
            <name>history</name>
            <value>6</value>
        </themes>
    </item>
    <item key="1">
        <id>2</id>
        <name>Mont-Saint-Michel</name>
        <address>50170 Le Mont-Saint-Michel</address>
        <prices/>
        <themes>
            <id>3</id>
            <name>history</name>
            <value>3</value>
        </themes>
        <themes>
            <id>4</id>
            <name>art</name>
            <value>7</value>
        </themes>
    </item>
    <item key="2">
        <id>4</id>
        <name>Disneyland Paris</name>
        <address>77777 Marne-la-Vall&#xE9;e</address>
        <prices/>
        <themes/>
    </item>
    <item key="3">
        <id>5</id>
        <name>Aquaboulevard</name>
        <address>4-6 Rue Louis Armand, 75015 Paris</address>
        <prices/>
        <themes/>
    </item>
    <item key="4">
        <id>6</id>
        <name>test</name>
        <address>test</address>
        <prices/>
        <themes/>
    </item>
</response>
\end{CodeBlock}



Le serveur renvoie aussi un entête \CodeInline{Content-Type} pour signaler au client le format de la réponse.



\image{http://zestedesavoir.com/media/galleries/3183/c231682c-a71d-4cc1-801d-050b5fba1b11.png}[Entête renvoyée par le serveur pour le format de la réponse]


\begin{Warning}
Attention, certaines API proposent de rajouter un format à une URL pour sélectionner un format de réponse (places.json, places.xml, etc.). Cette technique ne respecte pas les contraintes REST vu que l'URL doit juste servir à identifier une ressource.
\end{Warning}


\levelThreeTitle{L'Hypermédia}


La dernière contrainte du REST que nous n'avons pas encore implémentée est 
l'hypermédia en tant que moteur de l'état de l'application \textit{HATEOAS}. 
Pour rappel, le contrôle hypermédia désigne l'état d'une application ou API avec un seul point d'entrée mais qui propose des éléments permettant de l'explorer et d'interagir avec elle.



Avec un humain qui surfe sur le web, il est facile de suivre cette contrainte. En général, nous utilisons tous des sites web en tapant sur notre navigateur l'URL de la page d'accueil. Ensuite, avec les différents liens et formulaires, nous interagissons avec ledit site. Un site web est l'exemple parfait du concept HATEAOS.



Pour une API, nous avons des outils comme \externalLink{\textit{BazingaHateoasBundle}}{https://github.com/willdurand/BazingaHateoasBundle} qui permettent d'avoir un \textit{semblant} de HATEOS.



Une fois configuré, voici un exemple de réponse lorsqu'on récupère un utilisateur (exemple issu de \externalLink{la documentation du bundle}{https://github.com/willdurand/Hateoas\#introduction}).



\begin{CodeBlock}{json}
{
    "id": 42,
    "first_name": "Adrien",
    "last_name": "Brault",
    "_links": {
        "self": {
            "href": "/api/users/42"
        },
        "manager": {
            "href": "/api/users/23"
        }
    },
    "_embedded": {
        "manager": {
            "id": 23,
            "first_name": "Will",
            "last_name": "Durand",
            "_links": {
                "self": {
                    "href": "/api/users/23"
                }
            }
        }
    }
}
\end{CodeBlock}



Les attributs \CodeInline{\_links} et \CodeInline{\_embedded} sont issus des spécifications \externalLink{Hypertext Application Language (HAL)}{https://tools.ietf.org/html/draft-kelly-json-hal-07}. Ils permettent de décrire notre ressource en suivant les spécifications HAL encore à l'état de brouillon.



Des initiatives identiques comme \externalLink{JSON for Linking Data (json-ld)}{http://json-ld.org/} tentent de traiter le problème mais se heurtent tous face à un même obstacle.



La contrainte HATEOAS de REST nécessite un client très intelligent qui puisse :



\begin{itemize}
\item comprendre les relations déclarées entre ressource ;
\item auto-découvrir notre API à partir d'une seule URL.
\end{itemize}


Malheureusement, il n'existe pas encore de client d'API en mesure de comprendre et d'exploiter une API RESTFul niveau 3 (selon le modèle de Richardson).



Nous n'implémenterons donc pas cette contrainte et c'est le cas pour beaucoup d'API REST. Dans les faits, cela ne pose aucun problème et notre API est pleinement fonctionnelle.



\horizontalLine



Le support de plusieurs formats de requêtes et de réponses se fait en utilisant la négociation de contenu. 
Les entêtes mis en œuvre pour atteindre un tel comportement sont \CodeInline{Accept} et \CodeInline{Content-Type}. \textit{FOSRestBundle} exploite ensuite les capacités de notre sérialiseur afin de produire des réponses pour différents formats en se basant sur les mêmes données.



\levelOneTitle{Amélioration de l'API REST}


\levelTwoTitle{Sécurisation de l'API 1/2}


Jusque-là, les actions disponibles dans notre API sont accessibles pour n'importe quel client. Nous ne disposons d'aucun moyen pour gérer l'identité de ces derniers.



Pour être bref, n'importe qui peut faire n'importe quoi avec notre API.



\begin{Information}
La sécurité n'est pas un sujet adressé par les concepts REST mais nous pouvons adapter les méthodes d'autorisation et d'authentification classiques aux principes REST.
\end{Information}


Il existe beaucoup de techniques et d'outils comme \externalLink{OAuth}{http://oauth.net/} ou \externalLink{JSON Web Tokens}{https://jwt.io/} permettant de mettre en place un système d'authentification.



Cependant nous ne nous baserons sur aucun de ces outils et nous allons mettre en place un système d'authentification totalement personnalisé.



\levelThreeTitle{Connexion et déconnexion avec une API}


Qui dit système d'authentification dit des opérations comme \textit{se connecter} et \textit{se déconnecter}.



\begin{Question}
Comment mettre en place un tel système en se basant sur des concepts REST ?
\end{Question}


Pour bien adapter ses opérations, il faut d'abord bien les comprendre.



En général, lorsque nous nous connectons à un site web, nous fournissons un login et un mot de passe via un formulaire de connexion. Si les informations fournies sont valides, le serveur \textit{crée} \textit{un cookie} qui permettra d'assurer la gestion de la session. Une fois que nous avons fini de naviguer sur le site, il suffit de nous déconnecter pour que \textit{le cookie} de session soit \textit{supprimé}.



\image{http://zestedesavoir.com/media/galleries/3183/4caa0a4f-a12c-44e5-9ec0-2bb6fef9f341.png}[Cycle d'authentification]


Nous avons donc 3 éléments essentiels pour un tel fonctionnement :



\begin{itemize}
\item une méthode pour se connecter ;
\item une méthode pour se déconnecter ;
\item et une entité pour suivre l'utilisateur pendant sa navigation (le cookie).
\end{itemize}


En REST toutes nos opérations doivent se faire sur des \textit{ressources}.



Pour rappel,



\begin{Quotation}
Du moment où vous devez interagir avec une entité de votre application, créer une entité, la modifier, la consulter ou que vous devez l'identifier de manière unique alors vous avez pour la plupart des cas une ressource.
\end{Quotation}



Les opérations se font sur le cookie, nous pouvons donc dire qu'il représente notre ressource. Pour le cas d'un site web, l'utilisation d'un cookie est pratique vue que les navigateurs le gèrent nativement (envoie à chaque requête, limitation à un seul domaine pour la sécurité, durée de validité, etc.).



Pour le cas d'une API, il est certes possible d'utiliser un cookie mais il existe une solution équivalente mais plus simple et plus courante: les tokens.



\begin{Information}
Donc \textit{se connecter} ou encore \textit{se déconnecter} se traduisent respectivement par créer un token d'authentification et supprimer son token d'authentification.
\end{Information}


Pour chaque requête, le token ainsi crée est rajouté en utilisant une entête HTTP comme pour les cookies.



Commençons d'abord par gérer la création des tokens.



\levelThreeTitle{Login et mot de passe pour les utilisateurs}


Avant de créer un token, nous devons mettre à jour notre modèle de données. Un utilisateur doit maintenant avoir un mot de passe et son \textit{adresse mail} sera son \textit{login}.
Pour la gestion de ce mot de passe, nous utiliserons \externalLink{les outils}{http://symfony.com/doc/current/cookbook/doctrine/registration\_form.html} que nous propose Symfony.



Le nouveau modèle utilisateur :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/User.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;

/**
* @ORM\Entity()
* @ORM\Table(name="users",
*      uniqueConstraints={@ORM\UniqueConstraint(name="users_email_unique",columns={"email"})}
* )
*/
class User
{
    //...
    
    /**
     * @ORM\Column(type="string")
     */
    protected $password;

    protected $plainPassword;

    // ... tous les getters et setters
}
\end{CodeBlock}



L'attribut \CodeInline{plainPassword} ne sera pas sauvegardé en base. Il nous permettra de
conserver le mot de passe de l'utilisateur en clair à sa création ou modification.



Comme toujours, n'oubliez pas de mettre à jour la base de données :



\begin{CodeBlock}{bash}
php bin/console doctrine:schema:update --dump-sql --force

ALTER TABLE users ADD password VARCHAR(255) NOT NULL;

Updating database schema...
Database schema updated successfully! "1" query was executed
\end{CodeBlock}



La création d'un utilisateur nécessite maintenant un léger travail supplémentaire. À la création, il faudra fournir un mot de passe en claire que nous hasherons avant de le sauvegarder en base.
Rajoutons donc les configurations de sécurité de Symfony :



\begin{CodeBlock}{yaml}
# To get started with security, check out the documentation:
# http://symfony.com/doc/current/book/security.html
security:

    # Ajout d'un encoder pour notre entité USer
    encoders:
        AppBundle\Entity\User:
            algorithm: bcrypt
            cost: 12
\end{CodeBlock}



Notre entité utilisateur doit implémenter l'interface \CodeInline{UserInterface} :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/User.php
<?php
namespace AppBundle\Entity;

use Symfony\Component\Security\Core\User\UserInterface;
use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;

/**
* @ORM\Entity()
* @ORM\Table(name="users",
*      uniqueConstraints={@ORM\UniqueConstraint(name="users_email_unique",columns={"email"})}
* )
*/
class User implements UserInterface
{
    // ...

    public function getPassword()
    {
        return $this->password;
    }
     
    public function setPassword($password)
    {
        $this->password = $password;
    }


    public function getRoles()
    {
        return [];
    }

    public function getSalt()
    {
        return null;
    }

    public function getUsername()
    {
        return $this->email;
    }

    public function eraseCredentials()
    {
        // Suppression des données sensibles
        $this->plainPassword = null;
    }
}
\end{CodeBlock}



Le formulaire de création d'utilisateur et l'action associée dans notre contrôleur vont être adaptés en conséquence :



\begin{CodeBlock}{php}
# src/AppBundle/Form/Type/UserType.php
<?php
namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Form\Extension\Core\Type\EmailType;

class UserType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('firstname');
        $builder->add('lastname');
        $builder->add('plainPassword'); // Rajout du mot de passe 
        $builder->add('email', EmailType::class);
    }

    // ...
}
\end{CodeBlock}



Pour le mot de passe, nous aurons juste quelques règles de validation basiques :



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml

# ...

AppBundle\Entity\User:
    constraints:
        - Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity: email
    properties:
        firstname:
            - NotBlank: ~
            - Type: string
        lastname:
            - NotBlank: ~
            - Type: string
        email:
            - NotBlank: ~
            - Email: ~
        plainPassword:
            - NotBlank: { groups: [New, FullUpdate] }
            - Type: string
            - Length:
                min: 4
                max: 50
# ...
\end{CodeBlock}



Le champ \CodeInline{plainPassword} est un champ un peu spécial. Les groupes nous permettrons d'activer sa contrainte \CodeInline{NotBlank} lorsque le client voudra créer ou mettre à jour tous les champs de l'utilisateur. Mais lors d'une mise à jour partielle (PATCH), si le champ est nul, il sera tout simplement ignoré.



\begin{Error}
Le mot de passe ne doit en aucun cas être sérialisé. Il ne doit pas être associé à un groupe de sérialisation.
\end{Error}


La création et la modification d'un utilisateur nécessite maintenant un hashage du mot de passe en clair, le service \CodeInline{password\_encoder} de Symfony fait ce travail pour nous en utilisant toutes les configurations que nous venons de mettre en place.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/UserController.php
<?php
namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\UserType;
use AppBundle\Entity\User;

class UserController extends Controller
{
    /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"user"})
     * @Rest\Post("/users")
     */
    public function postUsersAction(Request $request)
    {
        $user = new User();
        $form = $this->createForm(UserType::class, $user, ['validation_groups'=>['Default', 'New']]);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $encoder = $this->get('security.password_encoder');
            // le mot de passe en claire est encodé avant la sauvegarde
            $encoded = $encoder->encodePassword($user, $user->getPlainPassword());
            $user->setPassword($encoded);

            $em = $this->get('doctrine.orm.entity_manager');
            $em->persist($user);
            $em->flush();
            return $user;
        } else {
            return $form;
        }
    }

     /**
     * @Rest\View(serializerGroups={"user"})
     * @Rest\Put("/users/{id}")
     */
    public function updateUserAction(Request $request)
    {
        return $this->updateUser($request, true);
    }

    /**
     * @Rest\View(serializerGroups={"user"})
     * @Rest\Patch("/users/{id}")
     */
    public function patchUserAction(Request $request)
    {
        return $this->updateUser($request, false);
    }

    private function updateUser(Request $request, $clearMissing)
    {
        $user = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:User')
                ->find($request->get('id')); // L'identifiant en tant que paramètre n'est plus nécessaire
        /* @var $user User */

        if (empty($user)) {
            return $this->userNotFound();
        }

        if ($clearMissing) { // Si une mise à jour complète, le mot de passe doit être validé
            $options = ['validation_groups'=>['Default', 'FullUpdate']];
        } else {
            $options = []; // Le groupe de validation par défaut de Symfony est Default
        }

        $form = $this->createForm(UserType::class, $user, $options);

        $form->submit($request->request->all(), $clearMissing);

        if ($form->isValid()) {
            // Si l'utilisateur veut changer son mot de passe
            if (!empty($user->getPlainPassword())) {
                $encoder = $this->get('security.password_encoder');
                $encoded = $encoder->encodePassword($user, $user->getPlainPassword());
                $user->setPassword($encoded);
            }
            $em = $this->get('doctrine.orm.entity_manager');
            $em->merge($user);
            $em->flush();
            return $user;
        } else {
            return $form;
        }
    }

    private function userNotFound()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'User not found'], Response::HTTP_NOT_FOUND);
    }
}
\end{CodeBlock}



Le groupe de validation \CodeInline{Default} regroupe toutes les contraintes de validation qui ne sont dans aucun groupe. Il est créé automatiquement par Symfony. N'hésitez surtout pas à consulter \externalLink{la documentation}{http://symfony.com/doc/current/book/validation.html\#validation-groups} pour des informations plus détaillées avant de continuer.



Nous pouvons maintenant tester la création d'un utilisateur en fournissant un mot de passe.



\image{http://zestedesavoir.com/media/galleries/3183/024a94ff-cfe9-43d0-87f2-a51e9b0298c9.png}[Requête de création d'un utilisateur avec mot de passe]


L'utilisateur est créé et la réponse ne contient aucun mot de passe :



\begin{CodeBlock}{json}
{
  "id": 5,
  "firstname": "test",
  "lastname": "Pass",
  "email": "test@pass.fr",
  // ...
}
\end{CodeBlock}



\begin{Warning}
Toutes les modifications effectuées ici sont propres à Symfony. Si vous avez du mal à suivre, il est vivement (grandement) conseillé de consulter \externalLink{la documentation officielle}{http://symfony.com/doc/current/book/security.html} du framework.
\end{Warning}


\levelThreeTitle{Création d'un token}


Revenons maintenant à notre système d'authentification avec des tokens.
Un token aura les caractéristiques suivantes :



\begin{itemize}
\item une valeur : une suite de chaînes de caractères générées aléatoirement et \textit{unique} ;
\item une date de création : la date à la quelle le token a été créé. Cette date nous permettra plus tard de vérifier l'âge du token et donc sa validité du token ;
\item un utilisateur : une référence vers l'utilisateur qui a demandé la création de ce token. 
Comme pour toute ressource, nous avons besoin d'une URL pour l'identifier. Nous utiliserons \CodeInline{rest-api.local/auth-tokens}, \CodeInline{auth-tokens} étant juste le dimunitif de \textit{authentication tokens} i.e les tokens d'authentification.
\end{itemize}


Contrairement aux autres ressources, la requête de création d'un token est légérement différente. Le payload contiendra le login et le mot de passe de l'utilisateur et les informations qui décrivent le token seront générées par le serveur.



La réponse contiendra donc les informations ainsi créées.



\image{http://zestedesavoir.com/media/galleries/3183/56ec754f-6588-48bf-9654-2e4b99810135.png}[Cinématique de création de token]


L'implémentation va donc ressembler à tout ce que nous avons déjà fait.



Commençons par l'entité \CodeInline{AuthToken} :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/AuthToken.php
<?php
namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="auth_tokens",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="auth_tokens_value_unique", columns={"value"})}
 * )
 */
class AuthToken
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
    
    /**
     * @ORM\Column(type="string")
     */
    protected $value;
    
    /**
     * @ORM\Column(type="datetime")
     * @var \DateTime
     */
    protected $createdAt;

    /**
     * @ORM\ManyToOne(targetEntity="User")
     * @var User
     */
    protected $user;


    public function getId()
    {
        return $this->id;
    }
     
    public function setId($id)
    {
        $this->id = $id;
    }
     
    public function getValue()
    {
        return $this->value;
    }
     
    public function setValue($value)
    {
        $this->value = $value;
    }
     
    public function getCreatedAt()
    {
        return $this->createdAt;
    }
     
    public function setCreatedAt(\DateTime $createdAt)
    {
        $this->createdAt = $createdAt;
    }
     
    public function getUser()
    {
        return $this->user;
    }
     
    public function setUser(User $user)
    {
        $this->user = $user;
    }
}
\end{CodeBlock}



La mise à jour de la base de données avec Doctrine :



\begin{CodeBlock}{bash}
php bin/console doctrine:schema:update --dump-sql --force
#> CREATE TABLE auth_tokens (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, value VARCHAR(255) NOT NULL, created_at DATETIME NOT NULL, INDEX IDX_8AF9B66CA76ED395 (user_id), UNIQUE INDEX auth_tokens_value_unique (value), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;
#> ALTER TABLE auth_tokens ADD CONSTRAINT FK_8AF9B66CA76ED395 FOREIGN KEY (user_id) REFERENCES users (id);

#> Updating database schema...
#> Database schema updated successfully! "2" queries were executed
\end{CodeBlock}



Pour la gestion du login et du mot de passe de l'utilisateur, nous allons créer :



\begin{itemize}
\item une entité nommée \textbf{\textit{Credentials}} avec deux attributs : \CodeInline{login} et \CodeInline{password}. Cette entité n'aura aucune annotation Doctrine, elle pemettra juste de transporter ces informations ;
\item un formulaire nommé \textbf{\textit{CredentialsType}} pour valider que les champs de l'entité \CodeInline{Credentials} ne sont pas vides (\CodeInline{Not-Blank}).
\end{itemize}


L'entité ressemble donc à :



\begin{CodeBlock}{php}
# src/AppBundle/Entity/Credentials.php
<?php
namespace AppBundle\Entity;

class Credentials
{
    protected $login;

    protected $password;
 
    public function getLogin()
    {
        return $this->login;
    }
     
    public function setLogin($login)
    {
        $this->login = $login;
    }
     
    public function getPassword()
    {
        return $this->password;
    }
     
    public function setPassword($password)
    {
        $this->password = $password;
    }
}
\end{CodeBlock}



Le formulaire et les règles de validation associées :



\begin{CodeBlock}{php}
# src/AppBundle/Form/Type/CredentialsType.php
<?php
namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class CredentialsType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('login');
        $builder->add('password');
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Credentials',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml

# ...

AppBundle\Entity\Credentials:
    properties:
        login:
            - NotBlank: ~
            - Type: string
        password:
            - NotBlank: ~
            - Type: string
\end{CodeBlock}



Il ne faut pas oublier de configurer le sérialiseur pour afficher le token en utilisant un groupe prédéfini.



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serialization.yml
# ...

AppBundle\Entity\User:
    attributes:
        id:
            groups: ['user', 'preference', 'auth-token']
        firstname:
            groups: ['user', 'preference', 'auth-token']
        lastname:
            groups: ['user', 'preference', 'auth-token']
        email:
            groups: ['user', 'preference', 'auth-token']
        preferences:
            groups: ['user']

AppBundle\Entity\AuthToken:
    attributes:
        id:
            groups: ['auth-token']
        value:
            groups: ['auth-token']
        createdAt:
            groups: ['auth-token']
        user:
            groups: ['auth-token']
\end{CodeBlock}



Maintenant, il ne reste plus qu'à créer le contrôleur qui assure la gestion des tokens d'authentification.



\begin{CodeBlock}{php}
# src/AppBundle/Controller/AuthTokenController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\CredentialsType;
use AppBundle\Entity\AuthToken;
use AppBundle\Entity\Credentials;

class AuthTokenController extends Controller
{
    /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"auth-token"})
     * @Rest\Post("/auth-tokens")
     */
    public function postAuthTokensAction(Request $request)
    {
        $credentials = new Credentials();
        $form = $this->createForm(CredentialsType::class, $credentials);

        $form->submit($request->request->all());

        if (!$form->isValid()) {
            return $form;
        }

        $em = $this->get('doctrine.orm.entity_manager');

        $user = $em->getRepository('AppBundle:User')
            ->findOneByEmail($credentials->getLogin());

        if (!$user) { // L'utilisateur n'existe pas
            return $this->invalidCredentials();
        }

        $encoder = $this->get('security.password_encoder');
        $isPasswordValid = $encoder->isPasswordValid($user, $credentials->getPassword());
        
        if (!$isPasswordValid) { // Le mot de passe n'est pas correct
            return $this->invalidCredentials();
        }

        $authToken = new AuthToken();
        $authToken->setValue(base64_encode(random_bytes(50)));
        $authToken->setCreatedAt(new \DateTime('now'));
        $authToken->setUser($user);

        $em->persist($authToken);
        $em->flush();

        return $authToken;
    }

    private function invalidCredentials()
    {
        return \FOS\RestBundle\View\View::create(['message' => 'Invalid credentials'], Response::HTTP_BAD_REQUEST);
    }
}
\end{CodeBlock}



N'oublions pas de déclarer le nouveau contrôleur.



\begin{CodeBlock}{yaml}
# app/config/routing.yml
# ...

auth-tokens:
    type:     rest
    resource: AppBundle\Controller\AuthTokenController
\end{CodeBlock}



\begin{Information}
Pour des raisons de sécurité, nous évitons de donner des  détails sur les comptes existants, un même message - \CodeInline{Invalid Credentials} - est renvoyé lorsque le login n'existe pas ou lorsque le mot de passe n'est pas correct.
\end{Information}


Nous pouvons maintenant créer un token en utilisant le compte \CodeInline{test@pass.fr} créé plus tôt.



\begin{CodeBlock}{json}
{
    "login": "test@pass.fr",
    "password": "test"
}
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/655ceeba-e0cc-4155-8624-aa9e5b82b86a.png}[Requête de création d'un token d'authentification avec Postman]


La réponse contient un token que nous pourrons exploiter plus tard pour décliner notre identité.



\begin{CodeBlock}{json}
{
  "id": 3,
  "value": "MVgq3dT8QyWv3t+s7DLyvsquVbu+mOSPMdYX7VUQOEQcJGwaGD8ETa+zi9ReHPWYFKI=",
  "createdAt": "2016-04-08T17:49:00+00:00",
  "user": {
    "id": 5,
    "firstname": "test",
    "lastname": "Pass",
    "email": "test@pass.fr"
  }
}
\end{CodeBlock}



\horizontalLine



Nous disposons maintenant d'un système fonctionnel pour générer des tokens pour les utilisateurs. Ces tokens nous permettrons par la suite de vérifier l'identité des clients de l'API afin de la sécuriser.



\levelTwoTitle{Sécurisation de l'API 2/2}


Un client utilisant notre API est maintenant en mesure de créer des tokens d'authentification. Nous allons donc rajouter un système de sécurité afin d'imposer l'utilisation de ce token pour accéder à notre API REST. Au lieu d'envoyer le login et le mot de passe dans chaque requête, nous utiliserons le token associé au client.



\levelThreeTitle{Exploitons le token grâce à Symfony}


Vu que nous allons imposer l'utilisation du token dans toutes les requêtes, nous devons vérifier sa validité afin de nous assurer que le client de l'API est bien authentifié.



Pour nous assurer de ce bon fonctionnement, chaque requête doit contenir une entête \CodeInline{X-Auth-Token} qui contiendra notre token fraichement crée.



\begin{Information}
Le nom de notre entête ne vient pas du néant. De manière conventionnelle, lorsqu'une requête contient une entête n'appartenant pas aux spécifications HTTP, le nom débute par \textbf{X-}. Ensuite, le reste du nom reflète le contenu de l'entête, \textbf{Auth-Token} pour \textbf{Auth}entication \textbf{Token}.
\end{Information}


Nous avons beaucoup d'exemples dans notre API actuelle qui suivent ce modèle de nommage. Lorsque nous consultons les entêtes d'une réponse quelconque de notre API, nous pouvons voir \textbf{X-Debug-Token} (créé par Symfony en mode config dev) ou encore  \textbf{X-Powered-By} (créé par PHP).



\image{http://zestedesavoir.com/media/galleries/3183/53f1dab5-f254-4de2-b084-f0e57df0db94.png}[Entêtes personnalisées renvoyées par notre API]


Symfony dispose d'un mécanisme spécifique permettant de gérer les clés d'API. Il existe \externalLink{un cookbook}{http://symfony.com/doc/current/cookbook/security/api\_key\_authentication.html} décrivant de manière très succincte les mécanismes en jeu pour le mettre en place.



Pour résumer, à chaque requête de l'utilisateur, un listener est appelé afin de vérifier que la requête contient une entête nommée \CodeInline{X-Auth-Token}. Et si tel est le cas, son existence dans notre base de données et sa validité sont vérifiées.



\begin{Warning}
Pour une requête permettant de créer un token d'authentification, ce listener ne fait aucune action afin d'autoriser la requête.
\end{Warning}


\image{http://zestedesavoir.com/media/galleries/3183/2c5c7ce7-2be1-4df9-a98b-4225c7875d32.png}[Cinématique d'authentification en succès]


Pour simplifier notre implémentation, nous considérons qu'un token d'authentification est invalide si son ancienneté est supérieur à 12 heures. Vous pouvez cependant modifier ce comportement et définir les règles de validité que vous voulez.



\image{http://zestedesavoir.com/media/galleries/3183/9ac01d3e-2c75-46d1-aeff-11025e845a0f.png}[Cinématique d'authentification en erreur]


Comme pour tous les systèmes d'authentification de Symfony, nous avons besoin d'un fournisseur d'utilisateurs (\CodeInline{UserProvider}). Pour notre cas, il faut que notre fournisseur puisse charger un token en utilisant la valeur dans notre entête \CodeInline{X-Auth-Token}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Security/AuthTokenUserProvider.php

namespace AppBundle\Security;

use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Core\User\User;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Doctrine\ORM\EntityRepository;

class AuthTokenUserProvider implements UserProviderInterface
{
    protected $authTokenRepository;
    protected $userRepository;

    public function __construct(EntityRepository $authTokenRepository, EntityRepository $userRepository)
    {
        $this->authTokenRepository = $authTokenRepository;
        $this->userRepository = $userRepository;
    }

    public function getAuthToken($authTokenHeader)
    {
        return $this->authTokenRepository->findOneByValue($authTokenHeader);
    }

    public function loadUserByUsername($email)
    {
        return $this->userRepository->findByEmail($email);
    }

    public function refreshUser(UserInterface $user)
    {
        // Le systéme d'authentification est stateless, on ne doit donc jamais appeler la méthode refreshUser
        throw new UnsupportedUserException();
    }

    public function supportsClass($class)
    {
        return 'AppBundle\Entity\User' === $class;
    }
}
\end{CodeBlock}



Cette classe permettra de récupérer les utilisateurs en se basant sur le token d'authentification fourni.



Pour piloter le mécanisme d'authentification, nous devons créer une classe implémentant l'interface \CodeInline{SimplePreAuthenticatorInterface} de Symfony. C'est cette classe qui gère la cinématique d'authentification que nous avons décrite plus haut.



\begin{CodeBlock}{php}
# src/AppBundle/Security/AuthTokenAuthenticator.php
<?php
namespace AppBundle\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Security\Core\Authentication\Token\PreAuthenticatedToken;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Core\Exception\BadCredentialsException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationFailureHandlerInterface;
use Symfony\Component\Security\Http\Authentication\SimplePreAuthenticatorInterface;
use Symfony\Component\Security\Http\HttpUtils;

class AuthTokenAuthenticator implements SimplePreAuthenticatorInterface, AuthenticationFailureHandlerInterface
{
    /**
    * Durée de validité du token en secondes, 12 heures
    */
    const TOKEN_VALIDITY_DURATION = 12 * 3600;

    protected $httpUtils;

    public function __construct(HttpUtils $httpUtils)
    {
        $this->httpUtils = $httpUtils;
    }

    public function createToken(Request $request, $providerKey)
    {

        $targetUrl = '/auth-tokens';
        // Si la requête est une création de token, aucune vérification n'est effectuée
        if ($request->getMethod() === "POST" && $this->httpUtils->checkRequestPath($request, $targetUrl)) {
            return;
        }
      
        $authTokenHeader = $request->headers->get('X-Auth-Token');

        if (!$authTokenHeader) {
            throw new BadCredentialsException('X-Auth-Token header is required');
        }

        return new PreAuthenticatedToken(
            'anon.',
            $authTokenHeader,
            $providerKey
        );
    }

    public function authenticateToken(TokenInterface $token, UserProviderInterface $userProvider, $providerKey)
    {
        if (!$userProvider instanceof AuthTokenUserProvider) {
            throw new \InvalidArgumentException(
                sprintf(
                    'The user provider must be an instance of AuthTokenUserProvider (%s was given).',
                    get_class($userProvider)
                )
            );
        }

        $authTokenHeader = $token->getCredentials();
        $authToken = $userProvider->getAuthToken($authTokenHeader);

        if (!$authToken || !$this->isTokenValid($authToken)) {
            throw new BadCredentialsException('Invalid authentication token');
        }

        $user = $authToken->getUser();
        $pre = new PreAuthenticatedToken(
            $user,
            $authTokenHeader,
            $providerKey,
            $user->getRoles()
        );

        // Nos utilisateurs n'ont pas de role particulier, on doit donc forcer l'authentification du token
        $pre->setAuthenticated(true);

        return $pre;
    }

    public function supportsToken(TokenInterface $token, $providerKey)
    {
        return $token instanceof PreAuthenticatedToken && $token->getProviderKey() === $providerKey;
    }

    /**
    * Vérifie la validité du token
    */
    private function isTokenValid($authToken)
    {
        return (time() - $authToken->getCreatedAt()->getTimestamp()) < self::TOKEN_VALIDITY_DURATION;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception)
    {
        // Si les données d'identification ne sont pas correctes, une exception est levée
        throw $exception;
    }
}
\end{CodeBlock}



La configuration du service est classique :



\begin{CodeBlock}{yaml}
# app/config/services.yml

# Learn more about services, parameters and containers at
# http://symfony.com/doc/current/book/service_container.html
parameters:
#    parameter_name: value

services:
    auth_token_user_provider:
        class: AppBundle\Security\AuthTokenUserProvider
        arguments: ["@auth_token_repository", "@user_repository"]
        public:    false

    auth_token_repository:
        class:   Doctrine\ORM\EntityManager
        factory: ["@doctrine.orm.entity_manager", "getRepository"]
        arguments: ["AppBundle:AuthToken"]

    user_repository:
        class:   Doctrine\ORM\EntityManager
        factory: ["@doctrine.orm.entity_manager", "getRepository"]
        arguments: ["AppBundle:User"]

    auth_token_authenticator:
        class:     AppBundle\Security\AuthTokenAuthenticator
        arguments: ["@security.http_utils"]
        public:    false
\end{CodeBlock}



Nous devons maintenant activer le pare-feu (firewall) de Symfony et le configurer avec notre fournisseur d'utilisateurs et le listener que nous venons de créer.



\begin{CodeBlock}{yaml}
# app/config/security.yml

# To get started with security, check out the documentation:
# http://symfony.com/doc/current/book/security.html
security:

    # http://symfony.com/doc/current/book/security.html#where-do-users-come-from-user-providers
    providers:
        auth_token_user_provider:
            id: auth_token_user_provider

    firewalls:
        # disables authentication for assets and the profiler, adapt it according to your needs
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false

        main:
            pattern: ^/
            stateless: true
            simple_preauth:
                authenticator: auth_token_authenticator
            provider: auth_token_user_provider
            anonymous: ~

    encoders:
        AppBundle\Entity\User:
            algorithm: bcrypt
            cost: 12
\end{CodeBlock}



\begin{Warning}
Vous pouvez remarquer que le pare-feu (firewall) est configuré en mode \CodeInline{stateless}. À chaque requête, l'identité de l'utilisateur est revérifiée. La session n'est jamais utilisée.
\end{Warning}


Maintenant, lorsque nous essayons de lister les lieux sans mettre l'entête d'authentification, une exception est levée:



\image{http://zestedesavoir.com/media/galleries/3183/7e93fee1-4f3a-4bf9-a96b-fb9860e1ff5e.png}[Requête Postman pour lister les lieux sans token d'authentification]


\begin{CodeBlock}{json}
{
  "error": {
    "code": 500,
    "message": "Internal Server Error",
    "exception": [
      {
        "message": "X-Auth-Token header is required",
        "class": "Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException",
        "trace": [
            "..."
        ]
      }
    ]
  }
}
\end{CodeBlock}



Spoil ! Les codes de statut et les messages renvoyés pour ce cas de figure ne sont pas conformes aux principes REST. Nous verrons dans ce chapitre comment corriger le tir.



Pour le moment, l'exception \CodeInline{BadCredentialsException}, avec le message \CodeInline{X-Auth-Token header is required}, confirme bien que la vérification du token est effectuée.



En rajoutant le token que nous avions généré plus tôt, la réponse contient bien la liste des lieux de notre application.



Avec Postman, il faut accéder à l'onglet \keys{Headers} en dessous de l'URL pour ajouter des entêtes à notre requête.



\image{http://zestedesavoir.com/media/galleries/3183/b6d238c8-aed7-408f-ab98-4c64499c3da5.png}[Requête Postman pour lister les lieux avec un token d'authentification]


\begin{CodeBlock}{json}
[
  {
    "id": 1,
    "name": "Tour Eiffel",
    "address": "5 Avenue Anatole France, 75007 Paris",
    "prices": [
      {
        "id": 1,
        "type": "less_than_12",
        "value": 5.75
      }
    ],
    "themes": [
      {
        "id": 1,
        "name": "architecture",
        "value": 7
      },
      {
        "id": 2,
        "name": "history",
        "value": 6
      }
    ]
  },
  // ...
]
\end{CodeBlock}



Notre API est maintenant sécurisée !



Par contre, la gestion des exceptions n'est pas encore très élaborée. En plus, vous l'avez peut-être déjà remarqué mais le format des messages d'erreur n'est pas uniforme. Lorsque le formulaire est invalide ou une exception est levée, les réponses renvoyées ne sont pas identiques, un client de l'API aura donc du mal à gérer les réponses en erreur.



\levelThreeTitle{Gestion des erreurs avec FOSRestBundle}


Le bundle \textit{FOSRestBundle} met à notre disposition un ensemble de composants pour gérer différents aspects d'une API. Et vous vous en doutez donc, il existe un listener pour gérer de manière simple et efficace les exceptions.



À l'état actuel, les exceptions sont gérées par le listener du bundle \textit{Twig}. La première configuration à effectuer est de le remplacer par l'exception listener de \textit{FOSRestBundle}. Pour cela, il suffit de rajouter une ligne dans la configuration du bundle.



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...
fos_rest:
    routing_loader:
        include_format: false
    # ...
    exception:
        enabled: true
\end{CodeBlock}



En activant ce composant, la gestion des exceptions avec \textit{Twig} est automatiquement désactivée.
Rien qu'avec cette configuration, nous pouvons voir un changement dans la réponse lorsque l'entête \CodeInline{X-Auth-Token} n'est pas renseignée.



\begin{CodeBlock}{json}
{
  "code": 500,
  "message": "X-Auth-Token header is required"
}
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/4661e9d5-85b0-48fa-9844-dad0cf4b7198.png}[Code de statut de l'erreur interne]


Lorsque le token renseigné n'est pas valide, nous obtenons comme réponse :



\begin{CodeBlock}{json}
{
  "code": 500,
  "message": "Invalid authentication token"
}
\end{CodeBlock}



Les messages correspondent à ceux que nous avons défini dans les exceptions parce que l'application est en mode développement. En production, ces messages sont remplacés par \CodeInline{Internal Server Error}.
Pour s'en rendre compte, il suffit de lancer la même requête avec comme URL \CodeInline{rest-api.local/app.php/places} pour forcer la configuration en production.



\begin{CodeBlock}{json}
{
  "code": 500,
  "message": "Internal Server Error"
}
\end{CodeBlock}



Il peut arriver que nous voulions conserver les messages des exceptions même en production. Pour ce faire, il suffit de rajouter dans la configuration un système d'autorisation des exceptions concernées.



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...
fos_rest:
    routing_loader:
        include_format: false
    # ...
    exception:
        enabled: true
        messages:
            'Symfony\Component\Security\Core\Exception\BadCredentialsException': true
\end{CodeBlock}



Le tableau message contient comme clés les noms des exceptions à autoriser et la valeur vaut \CodeInline{true}.



En re-testant, la requête sur l'URL \CodeInline{rest-api.local/app.php/places} (n'oubliez pas de vider le cache avant de tester), le message est bien affiché :



\begin{CodeBlock}{json}
{
  "code": 500,
  "message": "Invalid authentication token"
}
\end{CodeBlock}



Nous venons de franchir un premier pas.



Mais comme nous l'avons déjà vu, le code \CodeInline{500} ne doit être utilisé que pour les erreurs internes du serveur.
Pour le cas d'une authentification qui a échoué, le protocole HTTP propose un code bien spécifique - \CodeInline{401  Unauthorized} - qui dit qu'une authentification est nécessaire pour accéder à notre ressource.



Encore une fois, \textit{FOSRestBundle} propose un système très simple. À l'instar du tableau \CodeInline{messages}, nous pouvons rajouter un tableau \CodeInline{codes} avec comme clés les exceptions et comme valeur les codes de statut associés.



Nous aurons donc comme configuration finale :



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...
fos_rest:
    routing_loader:
        include_format: false
    # ...
    exception:
        enabled: true
        messages:
            'Symfony\Component\Security\Core\Exception\BadCredentialsException': true
        codes:
            'Symfony\Component\Security\Core\Exception\BadCredentialsException': 401
\end{CodeBlock}



Encore une fois ce bundle, nous facilite grandement le travail et réduit considérablement le temps de développement.



Lorsque nous re-exécutons notre requête :



\image{http://zestedesavoir.com/media/galleries/3183/1bd072af-cfe5-4bdb-9044-374fee5efb04.png}[Requête Postman sans token d'autorisation]


La réponse contient le bon message et le code de statut est aussi correct :



\image{http://zestedesavoir.com/media/galleries/3183/5f64db92-7400-4f75-b8af-5891042b782a.png}[Code de statut de la réponse non autorisée]


\begin{CodeBlock}{json}
{
  "code": 401,
  "message": "X-Auth-Token header is required"
}
\end{CodeBlock}



\begin{Information}
L'attribut code dans la réponse est créé par \textit{FOSRestBundle} par soucis de clarté. La contrainte REST, elle, exige juste que le code HTTP de la réponse soit conforme.
\end{Information}


Vu que le bundle est conçu pour interagir avec Symfony, toutes les exceptions du framework qui implémentent l'interface \CodeInline{}Symfony\textbackslash{}Component\textbackslash{}HttpKernel\textbackslash{}Exception\textbackslash{}HttpExceptionInterface` peuvent être traitées automatiquement.



Si par exemple, nous utilisons l'exception \CodeInline{NotFoundHttpException}, le code de statut devient automatiquement \CodeInline{404}. En général, il est aussi utile d'autoriser tous les messages des exceptions de type \CodeInline{HttpException} pour faciliter la gestion des cas d'erreurs.



La configuration du bundle devient maintenant :



\begin{CodeBlock}{yaml}
# app/config/config.yml
# ...

fos_rest:
    routing_loader:
        include_format: false
    # ...
    exception:
        enabled: true
        messages:
            'Symfony\Component\HttpKernel\Exception\HttpException' : true
            'Symfony\Component\Security\Core\Exception\BadCredentialsException': true
        codes:
            'Symfony\Component\Security\Core\Exception\BadCredentialsException': 401
\end{CodeBlock}



Toutes les occurrences de \CodeInline{return \textbackslash{}FOS\textbackslash{}RestBundle\textbackslash{}View\textbackslash{}View::create(['message' => 'Place not found'], Response::HTTP\_NOT\_FOUND);} peuvent être remplacées par \CodeInline{throw new \textbackslash{}Symfony\textbackslash{}Component\textbackslash{}HttpKernel\textbackslash{}Exception\textbackslash{}NotFoundHttpException('Place not found');}.



Et de même \CodeInline{return \textbackslash{}FOS\textbackslash{}RestBundle\textbackslash{}View\textbackslash{}View::create(['message' => 'User not found'], Response::HTTP\_NOT\_FOUND);} peut être remplacé par \CodeInline{throw new \textbackslash{}Symfony\textbackslash{}Component\textbackslash{}HttpKernel\textbackslash{}Exception\textbackslash{}NotFoundHttpException('User not found');}.



Les réponses restent identiques mais les efforts fournis pour les produire sont réduits.



\image{http://zestedesavoir.com/media/galleries/3183/d241580b-6617-4146-aa82-59e8a2e17c39.png}[Récupération d'un utilisateur inexistant avec Postman]


\image{http://zestedesavoir.com/media/galleries/3183/691e124d-53d6-425c-bd22-a96ca3c6f483.png}[Code de statut de la réponse]


\levelThreeTitle{401 ou 403, quand faut-il utiliser ces codes de statut ?}


Les codes de statuts \CodeInline{401} et \CodeInline{403} sont souvent source de confusion. Ils sont tous les deux utiliser pour gérer les informations liées à la sécurité.



Le code \CodeInline{401} est utilisé pour signaler que \textbf{la requête nécessite une authentification}. Avec notre système de sécurité actuel, nous exigeons que toutes les requêtes - à part celle de création de token - aient une entête \CodeInline{X-Auth-Token} valide.
Donc si une requête ne remplit pas ces conditions, elle est considérée comme non autorisée d'où le code de statut \CodeInline{401}.
En général, c'est depuis \externalLink{le pare-feu de Symfony}{http://symfony.com/doc/current/components/security/firewall.html} que ce code de statut doit être renvoyé.



Par contre, le code \CodeInline{403} est utilisé pour signaler qu'\textbf{une requête est interdite}. La différence réside dans le fait que pour qualifier une requête comme étant interdite, nous devons d'abord identifier le client de l'API à l'origine de celle-ci. Le code \CodeInline{403} doit donc être utilisé si le client de l'API est bien identifié via l'entête \CodeInline{X-Auth-Token} mais ne dispose pas des privilèges nécessaires pour effectuer l'opération qu'il souhaite.



Si par exemple, nous disposons d'un appel API réservé uniquement aux administrateurs, si un client simple essaye d'effectuer cette requête, nous devrons renvoyer un code de statut \CodeInline{403}. Ce code de statut peut être utilisé au niveau des ACLs (Access Control List) ou \externalLink{des voteurs de Symfony}{http://symfony.com/doc/current/cookbook/security/voters.html}.



\begin{Information}
En résumé, le code de statut \CodeInline{401} permet de signaler au client qu'il doit décliner son identité et le code de statut \CodeInline{403} permet de notifier à un client déjà identifié qu'il ne dispose pas de droits suffisants.
\end{Information}


\levelThreeTitle{Suppression d'un token ou la déconnexion}


Pour en finir avec la partie sécurisation, il ne reste plus qu'à rajouter une méthode pour se déconnecter de notre API.
La déconnexion consiste juste à la suppression du token d'authentification.
Par contre, une petite précaution va s'imposer. Pour traiter la suppression d'un token, il faudra juste nous assurer que l'utilisateur veut supprimer son propre token et pas celui d'un autre.
À part cette modification, tous les autres mécanismes déjà vus rentrent en jeu.



Pour supprimer la ressource, il faudra donc une requête \CodeInline{DELETE} sur la ressource \CodeInline{rest-api.local/auth-tokens/\{id\}}. La réponse en cas de succès doit être vide avec comme code de statut: \CodeInline{204 No Content}.



\begin{CodeBlock}{php}
# src/AppBunle/Controller/AuthTokenController.php
<?php
namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\CredentialsType;
use AppBundle\Entity\AuthToken;
use AppBundle\Entity\Credentials;

class AuthTokenController extends Controller
{
    //...

    /**
     * @Rest\View(statusCode=Response::HTTP_NO_CONTENT)
     * @Rest\Delete("/auth-tokens/{id}")
     */
    public function removeAuthTokenAction(Request $request)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $authToken = $em->getRepository('AppBundle:AuthToken')
                    ->find($request->get('id'));
        /* @var $authToken AuthToken */

        $connectedUser = $this->get('security.token_storage')->getToken()->getUser();

        if ($authToken && $authToken->getUser()->getId() === $connectedUser->getId()) {
            $em->remove($authToken);
            $em->flush();
        } else {
            throw new \Symfony\Component\HttpKernel\Exception\BadRequestHttpException();
        }
    }

    // ...
}
\end{CodeBlock}



\image{http://zestedesavoir.com/media/galleries/3183/923f1b55-33bd-4aec-b0fc-bbd57b87bd5c.png}[Requête de suppression d'un token avec Postman]


Si tout se passe bien, la réponse lors d'une suppression est vide avec comme statut \CodeInline{204}. En cas d'erreur une réponse \CodeInline{400} est renvoyée au client.



\begin{CodeBlock}{json}
{
  "code": 400,
  "message": "Bad Request"
}
\end{CodeBlock}



\horizontalLine



Notre fameux tableau récapitulatif s'enrichit d'un nouveau code de statut et listing des entêtes HTTP utilisables:



\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Opération souhaitée & Verbe HTTP \\ \hline
\rowfont[l]{}
Lecture & GET \\ \hline
Création & POST \\ \hline
Suppression & DELETE \\ \hline
Modification complète (remplacement) & PUT \\ \hline
Modification partielle & PATCH \\ \hline
\end{longtabu}


\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Code statut & Signification \\ \hline
\rowfont[l]{}
200 & Tout s'est bien passé et la réponse a du contenu \\ \hline
204 & Tout s'est bien passé mais la réponse est vide \\ \hline
400 & Les données envoyées par le client sont invalides \\ \hline
\textit{401} & Une authentification est nécessaire pour accéder à la ressource \\ \hline
\textit{403} & Le client authentifié ne dispose pas des droits nécessaires \\ \hline
404 & La ressource demandée n'existe pas \\ \hline
500 & Une erreur interne a eu lieu sur le serveur \\ \hline
\end{longtabu}


\begin{longtabu} spread 0pt {|X[-1]|X[-1]|} \hline
\rowfont[c]{\bfseries}
Entête HTTP & Contenu \\ \hline
\rowfont[l]{}
Accept & Un ou plusieurs  média type souhaités﻿﻿ par le client \\ \hline
Content-Type & Le média type de la réponse ou de la requête \\ \hline
X-Auth-Token & Token d'authentification \\ \hline
\end{longtabu}


Un client de l'API peut maintenant se connecter et se déconnecter et toutes ses requêtes nécessitent une authentification. Notre API vient d'être sécurisée ! La durée de validité du token et les critères de validation de celui-ci sont purement arbitraires. Vous pouvez donc les changer à votre guise.



Pour les besoins de ce cours les requêtes se font via HTTP mais il faudra garder en tête que la meilleure des sécurités ne vaut rien si le protocole utilisé n'est pas sécurisé. Donc dans une API en production, il faut \textbf{systématiquement} utiliser le \textbf{HTTPS}.



\levelTwoTitle{Créer une ressource avec des relations}


Revenons un peu sur les relations entre les ressources.



À la création d'un lieu, nous ne pouvons pas renseigner les tarifs. Nous sommes donc obligés de créer d'abord un lieu avant de rajouter ses tarifs.



Même si ce fonctionnement pourrait convenir dans certains cas, il peut aussi s'avérer utile de créer un lieu et de lui associer des tarifs avec un seul appel API. On pourra ainsi optimiser l'API et réduire les interactions entre le client et le serveur.



Nous allons donc voir dans cette partie comment arriver à un tel résultat avec Symfony.



\levelThreeTitle{Rappel de l'existant}


Jusqu'à présent pour créer un lieu, il fallait juste renseigner le nom et l'adresse. Le payload pour la création d'un lieu ressemblait donc à :



\begin{CodeBlock}{json}
{
    "name": "Disneyland Paris",
    "address": "77777 Marne-la-Vallée"
}
\end{CodeBlock}



En réalité, pour supporter la création d'un lieu avec ses tarifs, les contraintes de REST ne rentrent pas en jeu. Nous pouvons adapter librement le payload afin de rajouter toutes les informations nécessaires pour supporter la création d'un lieu avec ses tarifs avec un seul appel.



\levelThreeTitle{Création d'un lieu avec des tarifs}


\levelFourTitle{Un peu de conception}


Vu que nous avons déjà une méthode pour créer des tarifs, nous allons utiliser le même payload pour la création d'un lieu pour garder une API cohérente. Le payload existant doit être maintenant :



\begin{CodeBlock}{json}
{
  "name": "Disneyland Paris",
  "address": "77777 Marne-la-Vallée",
  "prices": [
    {
      "type": "for_all",
      "value": 10.0
    },
    {
      "type": "less_than_12",
      "value": 5.75
    }
  ]
}
\end{CodeBlock}



L'attribut \CodeInline{prices} est un tableau qui contiendra la liste des prix que nous voulons rajouter à la création du lieu.



Les tarifs resteront optionnels ce qui nous permettra de créer des lieux avec ou sans. Nous allons sans plus attendre appliquer ces modifications à l'appel existant.



\levelFourTitle{Implémentation}


\levelFiveTitle{Mise à jour du formulaire}


La méthode pour créer un lieu reste inchangée. Nous devons juste changer le formulaire des lieux et le traitement associé.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Form/Type/PlaceType.php

namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CollectionType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class PlaceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('name');
        $builder->add('address');
        $builder->add('prices', CollectionType::class, [
            'entry_type' => PriceType::class,
            'allow_add' => true,
            'error_bubbling' => false,
        ]);
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Place',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



La configuration du formulaire est typique des formulaires Symfony avec une collection. \externalLink{La documentation officielle}{http://symfony.com/doc/current/cookbook/form/form\_collections.html} aborde le sujet d'une manière plus complète.



Les règles de validation pour les thèmes existent déjà. Pour les utiliser, nous devons modifier la validation de l'entité \textbf{\textit{Place}} en rajoutant la règle \CodeInline{Valid}. Avec cette annotation, nous disons à Symfony de valider l'attribut \CodeInline{prices} en utilisant les contraintes de validation de l'entité \textbf{\textit{Price}}.



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml
AppBundle\Entity\Place:
    constraints:
        - Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity: name
    properties:
        name:
            - NotBlank: ~
            - Type: string
        address:
            - NotBlank: ~
            - Type: string
        prices:
            - Valid: ~
\end{CodeBlock}



Notez qu'il n'y a pas d'assertions de type \CodeInline{NotBlank} puisque l'attribut \CodeInline{prices} est optionnel.



\levelFiveTitle{Traitement du formulaire}


Avec les modifications que nous venons d'apporter, nous pouvons déjà tester la création d'un lieu avec des prix. Mais avant de le faire, nous allons rapidement adapter le contrôleur pour gérer la sauvegarde des prix.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use FOS\RestBundle\Controller\Annotations as Rest; // alias pour toutes les annotations
use AppBundle\Form\Type\PlaceType;
use AppBundle\Entity\Place;

class PlaceController extends Controller
{

    // ...

     /**
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"place"})
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
        $place = new Place();
        $form = $this->createForm(PlaceType::class, $place);

        $form->submit($request->request->all());

        if ($form->isValid()) {
            $em = $this->get('doctrine.orm.entity_manager');
            foreach ($place->getPrices() as $price) {
                $price->setPlace($place);
                $em->persist($price);
            }
            $em->persist($place);
            $em->flush();
            return $place;
        } else {
            return $form;
        }
    }

    // ...
\end{CodeBlock}



\begin{Warning}
Comme vous l'avez sûrement remarqué, toute la logique de notre API est regroupée dans les contrôleurs. Ceci n'est pas une bonne pratique et l'utilisation d'un service dédié est vivement conseillée pour une application destinée à une mise en production.
\end{Warning}


L'entité \textbf{\textit{Place}} a été légèrement modifiée. L'attribut \CodeInline{prices} est maintenant initialisé avec une collection vide.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entity/Place.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="places",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="places_name_unique",columns={"name"})}
 * )
 */
class Place
{
    // ...

    /**
     * @ORM\OneToMany(targetEntity="Price", mappedBy="place")
     * @var Price[]
     */
    protected $prices;

    public function __construct()
    {
        $this->prices = new ArrayCollection();
        // ...
    }

   // ...
\end{CodeBlock}



En testant une création d'un lieu avec des prix :



\begin{CodeBlock}{json}
{
  "name": "Musée du Louvre",
  "address": "799, rue de Rivoli, 75001 Paris",
  "prices": [
    {
      "type": "less_than_12",
      "value": 6
    },
    {
      "type": "for_all",
      "value": 15
    }
  ]
}
\end{CodeBlock}



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/BhMdRw-pYrX9.png}[Requête de création d'un lieu avec des prix]


La réponse  est identique à ce que nous avons déjà eu mais les prix sont enregistrés en même temps.



\begin{CodeBlock}{json}
{
  "id": 9,
  "name": "Musée du Louvre",
  "address": "799, rue de Rivoli, 75001 Paris",
  "prices": [
    {
      "id": 6,
      "type": "less_than_12",
      "value": 6
    },
    {
      "id": 7,
      "type": "for_all",
      "value": 15
    }
  ],
  "themes": []
}
\end{CodeBlock}



Nous pouvons maintenant créer un lieu tout en rajoutant des prix et le principe peut même être élargi pour les thèmes des lieux et les préférences des utilisateurs.



\levelThreeTitle{Bonus : Une validation plus stricte}


\levelFourTitle{Création d'un lieu avec deux prix de même type}


Si nous essayons de créer un lieu avec des prix du même type, nous obtenons une erreur interne car il y a une contrainte d'unicité sur l'identifiant du lieu et le type du produit.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Entiy/Price.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity()
 * @ORM\Table(name="prices",
 *      uniqueConstraints={@ORM\UniqueConstraint(name="prices_type_place_unique", columns={"type", "place_id"})}
 * )
 */
class Price
{
    // ...
}
\end{CodeBlock}



Pour s'en convaincre, il suffit d'essayer de créer un nouveau lieu avec comme payload :



\begin{CodeBlock}{json}
{
    "name": "Arc de Triomphe",
    "address": " Place Charles de Gaulle, 75008 Paris",
    "prices": [
        {
            "type": "less_than_12",
            "value": 0.0
        },
        {
            "type": "less_than_12",
            "value": 0.0
        } 
    ]
}
\end{CodeBlock}



La réponse est sans appel :



\begin{CodeBlock}{json}
{
  "code": 500,
  "message": "An exception occurred while executing 'INSERT INTO prices (type, value, place_id) VALUES (?, ?, ?)' with params [\"less_than_12\", 0, 10]:\n\nSQLSTATE[23000]: Integrity constraint violation: 1062 Duplicata du champ 'less_than_12-10' pour la clef 'prices_type_place_unique'"
}
\end{CodeBlock}



Pour corriger le problème, nous allons créer une règle de validation personnalisée.



\levelFourTitle{Validation personnalisée avec Symfony}


\levelFiveTitle{Création de la contrainte}


La contrainte est la partie la plus simple à implémenter. Il suffit d'une classe pour la nommer et d'un message en cas d'erreur.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Form/Validator/Constraint/PriceTypeUnique.php

namespace AppBundle\Form\Validator\Constraint;

use Symfony\Component\Validator\Constraint;

/**
 * @Annotation
 */
class PriceTypeUnique extends Constraint
{
    public $message = 'A place cannot contain prices with same type';
}
\end{CodeBlock}



\levelFiveTitle{Création du validateur}


Une fois que nous avons une nouvelle contrainte, il reste à créer un validateur pour gérer cette contrainte.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Form/Validator/Constraint/PriceTypeUniqueValidator.php

namespace AppBundle\Form\Validator\Constraint;

use Symfony\Component\Validator\Constraint;
use Symfony\Component\Validator\ConstraintValidator;

class PriceTypeUniqueValidator extends ConstraintValidator
{
    public function validate($prices, Constraint $constraint)
    {
        if (!($prices instanceof \Doctrine\Common\Collections\ArrayCollection)) {
            return;
        }

        $pricesType = [];

        foreach ($prices as $price) {
            if (in_array($price->getType(), $pricesType)) {
                $this->context->buildViolation($constraint->message)
                    ->addViolation();
                return; // Si il y a un doublon, on arrête la recherche
            } else {
                // Sauvegarde des types de prix déjà présents
                $pricesType[] = $price->getType();
            }
        }
    }
}
\end{CodeBlock}



Le nom choisi n'est pas un hasard. Vu que la contrainte s'appelle \textbf{\textit{PriceTypeUnique}}, le validateur a été nommé  \textbf{\textit{PriceTypeUniqueValidator}} afin d'utiliser les conventions de nommage de Symfony. Ainsi notre contrainte est validée en utilisant le validateur que nous venons de créer.



\begin{Information}
Ce comportement par défaut peut être modifié en étendant la méthode \CodeInline{validatedBy} de la contrainte. \externalLink{La documentation officielle}{http://symfony.com/doc/current/cookbook/validation/custom\_constraint.html} de Symfony apporte plus d'informations à ce sujet.
\end{Information}


Pour utiliser notre nouvelle contrainte, nous allons modifier les règles de validation qui s'applique à un lieu :



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/validation.yml
AppBundle\Entity\Place:
    constraints:
        - Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity: name
    properties:
        name:
            - NotBlank: ~
            - Type: string
        address:
            - NotBlank: ~
            - Type: string
        prices:
            - Valid: ~
            - AppBundle\Form\Validator\Constraint\PriceTypeUnique: ~
\end{CodeBlock}



En testant à nouveau la création d'un lieu avec deux prix du même type, nous obtenons une belle erreur de validation avec un message clair.



\begin{CodeBlock}{json}
{
  "code": 400,
  "message": "Validation Failed",
  "errors": {
    "children": {
      "name": [],
      "address": [],
      "prices": {
        "errors": [
          "A place cannot contain prices with same type"
        ],
        "children": [
          {
            "children": {
              "type": [],
              "value": []
            }
          },
          {
            "children": {
              "type": [],
              "value": []
            }
          }
        ]
      }
    }
  }
}
\end{CodeBlock}



\horizontalLine



Comme vous avez pu le remarquer, la création d'une ressource en relation avec d'autres ressources ne relève pas trop de REST mais plutôt de la gestion des formulaires avec Symfony.



Ainsi, les connaissances que vous avez déjà pu acquérir pour la gestion des formulaires dans Symfony peuvent être exploitées pour mettre en place ces fonctionnalités.



Prendre en compte ce genre de détails d'implémentation permet de réduire le nombre d'appels API et donc améliorer les performances des applications qui doivent l'exploiter et l'expérience utilisateur par la même occasion.



\levelTwoTitle{Quand utiliser les query strings ?}


Jusqu'à présent les query strings ou paramètres d'URL ont été recalés dans tous les choix de conception que nous avons déjà faits.



Ces composants à part entière du protocole HTTP peuvent être exploités dans une API REST pour atteindre différents objectifs.



Dans cette partie, nous allons aborder quelques cas pratiques où les query strings peuvent être utilisés.



Tout au long de cette partie, le terme \textit{query strings} sera utilisé pour désigner les paramètres d'URL.



\levelThreeTitle{Pourquoi utiliser les query strings ?}


Le premier cas d'usage qui est assez courant lorsque nous utilisons ou nous développons une API est la pagination ou le filtrage des réponses que nous obtenons.



Nous pouvons actuellement lister tous les lieux ou tous les utilisateurs de notre application. Cette réponse peut rapidement poser des problèmes de performance si ces listes grossissent dans le temps.



\begin{Question}
Comment alors récupérer notre liste de lieux tout en réduisant/filtrant cette liste alors que nous avons un seul appel permettant de lister les lieux de notre application : \CodeInline{GET rest-api.local/places} ?
\end{Question}


La liste de lieux est une ressource avec un identifiant \CodeInline{places}. Pour récupérer cette même liste tout en conservant son identifiant nous ne pouvons pas modifier l'URL.



Par contre, les query string nous permettent de pallier à ce genre de problèmes.



\begin{Quotation}
The query component contains non-hierarchical data that, along with
   data in the path component (Section 3.3), serves \textbf{to identify a
   resource within the scope of the URI's scheme} and naming authority
   (if any).
\end{Quotation}



Source: \externalLink{RFC 3986}{https://tools.ietf.org/html/rfc3986\#section-3.4}



Donc au sein d'une même URL (ici \CodeInline{rest-api.local/places}), nous pouvons rajouter des query strings afin d'obtenir des réponses différentes mais qui représentent toutes une liste de lieux.



\levelThreeTitle{Gestion des query strings avec FOSRestBundle}


Avant d'aborder les cas pratiques, nous allons commencer par voir comment \textit{FOSRestBundle} nous permet de définir les query strings.



Le framework Symfony supporte de base les query strings mais \textit{FOSRestBundle} rajoute beaucoup de fonctionnalités comme :



\begin{itemize}
\item définir des règles de validation pour ce query string ;
\item définir une valeur par défaut ;
\item et beaucoup d'autres fonctionnalités.
\end{itemize}


\levelFourTitle{L'annotation QueryParam}


Pour accéder à toutes ces fonctionnalités, il suffit d'utiliser une annotation \CodeInline{FOS\textbackslash{}RestBundle\textbackslash{}Controller\textbackslash{}Annotations\textbackslash{}QueryParam} sur le ou les actions de nos contrôleurs.



\begin{Information}
Il est aussi possible d'utiliser cette annotation sur un contrôleur mais nous ne parlerons pas de ce cas d'usage.
\end{Information}


\begin{CodeBlock}{php}
<?php
/**
 * @QueryParam(
 *   name="",
 *   key=null,
 *   requirements="",
 *   incompatibles={},
 *   default=null,
 *   description="",
 *   strict=false,
 *   array=false,
 *   nullable=false
 * )
 */
\end{CodeBlock}



Nous aborderons les cas d'utilisation des attributs de cette annotation dans la suite.



\levelFourTitle{Le listener}


Pour dire à \textit{FOSRestBundle} de traiter cette annotation, nous devons activer un listener dédié appelé le \textit{Param Fetcher Listener}. 
Pour ce faire, nous allons modifier le fichier de configuration :



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...

fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
        formats:
            json: true
            xml: true
    format_listener:
        rules:
            - { path: '^/', priorities: ['json', 'xml'], fallback_format: 'json', prefer_extension: false }
    body_listener:
        enabled: true
    param_fetcher_listener:
        enabled: true
# ...
\end{CodeBlock}



Maintenant que le listener est activé, nous pouvons passer aux choses sérieuses.



\levelThreeTitle{Paginer et Trier les réponses}


\levelFourTitle{Paginer la liste de lieux}


Commençons par mettre en place une pagination pour la liste des lieux. Pour obtenir cette pagination, nous allons utiliser un principe simple.



Deux query strings vont permettre de choisir l'index du premier résultat souhaité (\CodeInline{offset}) et le nombre de résultats souhaités (\CodeInline{limit}).



Ces deux paramètres sont facultatifs mais doivent obligatoirement être des entiers positifs.



Pour implémenter ce fonctionnement, il suffit de rajouter deux annotations \CodeInline{QueryParam} dans l'action qui liste les lieux.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use FOS\RestBundle\Controller\Annotations\QueryParam;
// ...

class PlaceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     * @QueryParam(name="offset", requirements="\d+", default="", description="Index de début de la pagination")
     * @QueryParam(name="limit", requirements="\d+", default="", description="Index de fin de la pagination")
     */
    public function getPlacesAction(Request $request)
    {
        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */

        return $places;
    }
// ...
}
\end{CodeBlock}



Avec l'attribut \CodeInline{requirements}, nous utilisons une expression régulière pour valider les paramètres. Si les données ne sont pas valides alors le paramètre vaudra sa valeur par défaut (une chaîne vide pour notre cas). Si les paramètres ne sont pas renseignés, ils seront aussi vides.
Il faut aussi noter que nous pouvons utiliser n'importe quelle valeur par défaut. En effet, elle n'est pas validée par FOSRestBundle. C'est d'ailleurs pour cette raison que nous pouvons mettre dans notre exemple une chaîne vide comme valeur par défaut alors que notre expression régulière ne valide que les entiers.



\begin{Error}
L'expression régulière utilisée dans \CodeInline{requirements} est traité en rajoutant automatiquement un pattern du type \CodeInline{\#\textasciicircum{}notre\_regex\$\#xsu}. En mettant, \CodeInline{\textbackslash{}d+} nous validons donc avec \CodeInline{\#\textasciicircum{}\textbackslash{}d+\$\#xsu}.  Vous pouvez consulter \externalLink{la documentation de PHP}{http://php.net/manual/fr/reference.pcre.pattern.modifiers.php} pour voir l'utilité des options \CodeInline{x} (ignorer les caractères d'espacement), \CodeInline{s} (pour utiliser \CodeInline{.} comme métacaractère générique) et \CodeInline{u} (le masque et la chaîne d'entrée sont traitées comme des chaînes UTF-8.).
\end{Error}


Pour les traiter, nous avons plusieurs choix. Nous pouvons utiliser un attribut de l'objet \textit{Request} appelé \CodeInline{paramFetcher} que le \textit{Param Fetcher Listener} crée automatiquement. Ou encore, nous pouvons ajouter un paramètre à notre action qui doit être du type \CodeInline{FOS\textbackslash{}RestBundle\textbackslash{}Request\textbackslash{}ParamFetcher} .



Avec la cette dernière méthode, que nous allons utiliser, le \textit{Param Fetcher Listener} injecte automatiquement le param fetcher à notre place.



L'objet ainsi obtenu permet d'accéder aux différents query strings que nous avons déclarés.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use FOS\RestBundle\Controller\Annotations\QueryParam;
use FOS\RestBundle\Request\ParamFetcher;
// ...

class PlaceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     * @QueryParam(name="offset", requirements="\d+", default="", description="Index de début de la pagination")
     * @QueryParam(name="limit", requirements="\d+", default="", description="Nombre d'éléments à afficher")
     */
    public function getPlacesAction(Request $request, ParamFetcher $paramFetcher)
    {
        $offset = $paramFetcher->get('offset');
        $limit = $paramFetcher->get('limit');

        $places = $this->get('doctrine.orm.entity_manager')
                ->getRepository('AppBundle:Place')
                ->findAll();
        /* @var $places Place[] */

        return $places;
    }
// ...
}
\end{CodeBlock}



Avec le param fetcher, nous pouvons récupérer nos paramètres et les traiter à notre convenance. 
Pour gérer la pagination avec Doctrine, nous pouvons utiliser le query builder avec les paramètres \CodeInline{offset} et \CodeInline{limit}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use FOS\RestBundle\Controller\Annotations\QueryParam;
use FOS\RestBundle\Request\ParamFetcher;
// ...

class PlaceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     * @QueryParam(name="offset", requirements="\d+", default="", description="Index de début de la pagination")
     * @QueryParam(name="limit", requirements="\d+", default="", description="Nombre d'éléments à afficher")
     */
    public function getPlacesAction(Request $request, ParamFetcher $paramFetcher)
    {
        $offset = $paramFetcher->get('offset');
        $limit = $paramFetcher->get('limit');

        $qb = $this->get('doctrine.orm.entity_manager')->createQueryBuilder();
        $qb->select('p')
           ->from('AppBundle:Place', 'p');

        if ($offset != "") {
            $qb->setFirstResult($offset);
        }

        if ($limit != "") {
            $qb->setMaxResults($limit);
        }
    
        $places = $qb->getQuery()->getResult();

        return $places;
    }
// ...
}
\end{CodeBlock}



Nous pouvons maintenant tester plusieurs appels API :



\begin{itemize}
\item \CodeInline{GET rest-api.local/places?limit=5} permet de lister cinq lieux ;
\item \CodeInline{GET rest-api.local/places?offset=3} permet de lister tous les lieux en omettant les trois premiers lieux ;
\item \CodeInline{GET rest-api.local/places?offset=1\&limit=2} permet de lister deux lieux en omettant le premier lieu dans l'application.
\end{itemize}


En testant le dernier exemple avec Postman, nous avons :



\image{http://zestedesavoir.com/media/galleries/3183/7d9c831d-e3e7-41cc-a94a-ba606920a065.png}[Récupération des lieux avec une pagination]


\begin{CodeBlock}{json}
[
  {
    "id": 2,
    "name": "Mont-Saint-Michel",
    "address": "50170 Le Mont-Saint-Michel",
    "prices": [],
    "themes": [
      {
        "id": 3,
        "name": "history",
        "value": 3
      },
      {
        "id": 4,
        "name": "art",
        "value": 7
      }
    ]
  },
  {
    "id": 4,
    "name": "Disneyland Paris",
    "address": "77777 Marne-la-Vallée",
    "prices": [],
    "themes": []
  }
]
\end{CodeBlock}



\levelFourTitle{Trier la liste des lieux}


Pour pratiquer, nous allons rajouter un paramètre pour trier les lieux selon leur nom.



Le paramètre s'appellera \CodeInline{sort} et pourra avoir deux valeurs: \textit{asc} pour l'ordre croissant et \textit{desc} pour l'ordre décroissant.
La valeur par défaut sera \CodeInline{null}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use FOS\RestBundle\Controller\Annotations\QueryParam;
// ...

class PlaceController extends Controller
{

    /**
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     * @QueryParam(name="offset", requirements="\d+", default="", description="Index de début de la pagination")
     * @QueryParam(name="limit", requirements="\d+", default="", description="Nombre d'éléments à afficher")
     * @QueryParam(name="sort", requirements="(asc|desc)", nullable=true, description="Ordre de tri (basé sur le nom)")
     */
    public function getPlacesAction(Request $request, ParamFetcher $paramFetcher)
    {
        $offset = $paramFetcher->get('offset');
        $limit = $paramFetcher->get('limit');
        $sort = $paramFetcher->get('sort');

        $qb = $this->get('doctrine.orm.entity_manager')->createQueryBuilder();
        $qb->select('p')
           ->from('AppBundle:Place', 'p');

        if ($offset != "") {
            $qb->setFirstResult($offset);
        }

        if ($limit != "") {
            $qb->setMaxResults($limit);
        }

        if (in_array($sort, ['asc', 'desc'])) {
            $qb->orderBy('p.name', $sort);
        }
       
    
        $places = $qb->getQuery()->getResult();

        return $places;
    }
// ...
}
\end{CodeBlock}



La seule différence avec les deux autres query strings est que pour avoir une valeur par défaut à \CodeInline{null}, nous utilisons l'attribut \CodeInline{nullable}.



En testant l'appel précédant avec en plus un tri des noms par ordre décroissant :



\image{http://zestedesavoir.com/media/galleries/3183/5ce13b47-e433-4ae5-9c6b-811b7b3d56cf.png}[Récupération des lieux avec une pagination et un tri par ordre décroissant de nom]


La réponse change en :



\begin{CodeBlock}{json}
[
  {
    "id": 6,
    "name": "test",
    "address": "test",
    "prices": [],
    "themes": []
  },
  {
    "id": 9,
    "name": "Musée du Louvre",
    "address": "799, rue de Rivoli, 75001 Paris",
    "prices": [
      {
        "id": 6,
        "type": "less_than_12",
        "value": 6
      },
      {
        "id": 7,
        "type": "for_all",
        "value": 15
      }
    ],
    "themes": []
  }
]
\end{CodeBlock}



Il est aussi possible de configuer \textit{FOSRestBundle} pour injecter directement les query strings dans l'objet \CodeInline{Request}. Pour plus d'informations,vous pouvez consulter \externalLink{la documentation du bundle}{http://symfony.com/doc/current/bundles/FOSRestBundle/param\_fetcher\_listener.html}.



\horizontalLine



Les query strings permettent d'étendre facilement une API REST tout en respectant les contraintes que ce style d'architecture nous impose.



Nous venons de brosser une infime partie des fonctionnalités que les query strings peuvent apporter à une API.



D'ailleurs, il n'existe pas de limites réelles et vous pouvez laisser libre cours à votre imagination pour étoffer notre API.



De la même façon, le bundle \textit{FOSRestBundle} propose un ensemble de fonctionnalité grâce au \textit{Param Fetcher Listener} qui permettent de gérer les query strings d'une manière assez simple.



\externalLink{La documentation officielle}{http://symfony.com/doc/master/bundles/FOSRestBundle/param\_fetcher\_listener.html} est complète sur le sujet et pourra toujours vous servir de référence.



\levelTwoTitle{JMSSerializer : Une alternative au sérialiseur natif de Symfony}


Le sérialiseur natif de Symfony est disponible depuis les toutes premières versions du framework. Cependant, les fonctionnalités supportées par celui-ci étaient assez basique.



Par exemple, les groupes de sérialisation - permettant entre autres de gérer les références circulaires - n'ont été supportés qu'à partir de la version 2.7 \externalLink{sortie en 2015}{http://symfony.com/blog/symfony-2-7-0-released}. La sérialisation des dates PHP (\textit{DateTime} et \textit{DateTimeImmutable}) n'a été supporté qu'avec la version 3.1 \externalLink{sortie en 2016}{http://symfony.com/blog/symfony-3-1-0-released}.



Pour pallier à ce retard, un bundle a été développé pour la gestion de la sérialisation dans Symfony : \textit{JMSSerializerBundle}. Il permet d'intégrer la librairie \externalLink{JMSSerializer}{http://jmsyst.com/libs/serializer} et est très largement utilisé dans le cadre du développement d'une API avec Symfony.



\levelThreeTitle{Pourquoi utiliser JMSSerializerBundle ?}


Nous avons déjà eu l'occasion de voir le nom \textit{JMSSerializerBundle} dans les premières parties de ce cours.
Ce bundle permet d'inclure et de configurer la librairie PHP \externalLink{jms/serializer}{http://jmsyst.com/libs/serializer} dans Symfony.



Cette librairie présente beaucoup d'avantages :



\begin{itemize}
\item Elle est beaucoup plus mature que le sérialiseur de Symfony ;
\item De par son ancienneté, elle est supportée par beaucoup de bundles et facilite donc l'interopérabilité entre les bundles et/ou composants que nous pouvons utiliser dans notre API ;
\item Et pour finir, les ressources (documentation, cours etc.) sur cette librairie sont plus abondantes.
\end{itemize}


À l'installation de \textit{FOSRestBundle}, nous étions obligés d'utiliser la version \textit{2.0} afin de supporter pleinement le sérialiseur de Symfony. Mais avec \textit{JMSSerializerBundle}, nous pourrons profiter de toutes les fonctionnalités de \textit{jms/serializer} tout en utilisant une version de \textit{FOSRestBundle} inférieure à la \textit{2.0}.



\levelThreeTitle{Installation et configuration de JMSSerializerBundle}


\levelFourTitle{Installation de JMSSerializerBundle}


Comme pour tous les bundles de Symfony, il suffit de le télécharger avec \textit{Composer} et de l'activer.
Téléchargement du bundle :



\begin{CodeBlock}{bash}
composer require jms/serializer-bundle
# Using version ^1.1 for jms/serializer-bundle
./composer.json has been updated
\end{CodeBlock}



Activation du bundle :



\begin{CodeBlock}{php}
<?php
# app/AppKernel.php
use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = [
            // ...
            new JMS\SerializerBundle\JMSSerializerBundle(),
            new FOS\RestBundle\FOSRestBundle(),
            new AppBundle\AppBundle(),
        ];
        // ...
        return $bundles;
    }
    // ...
}
\end{CodeBlock}



\levelFourTitle{Configuration de JMSSerializerBundle}


La configuration par défaut de ce bundle suffit largement pour commencer à l'exploiter.
Mais pour notre cas, puisque nous avons déjà pas mal de fonctionnalités qui dépendent du sérialiseur, nous allons modifier sa configuration.



\levelFiveTitle{Gestion des dates PHP}


Comme pour le sérialiseur natif de Symfony (depuis la version 3.1), la sérialisation des dates dans php est supportée nativement par \textit{JMSSerializerBundle}. Nous pouvons, en plus, personnaliser ce comportement avec juste 4 lignes de configuration.



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...
jms_serializer:
    handlers:
        datetime:
            default_format: "Y-m-d\\TH:i:sP"
            default_timezone: "UTC"
\end{CodeBlock}



La valeur \CodeInline{"Y-m-d\textbackslash{}\textbackslash{}TH:i:sP"} désigne \externalLink{le format ISO 8601}{https://fr.wikipedia.org/wiki/ISO\_8601} pour les dates.



\begin{Information}
L'attribut \CodeInline{default\_format} prend en paramètre le même format que \externalLink{la fonction date de PHP}{http://php.net/manual/fr/function.date.php}.
\end{Information}


\levelFiveTitle{Une question de casse : CamelCase ou snake\_case ?}


Dans tous les exemples que nous avons pu voir, les attributs dans les requêtes et les réponses sont toutes en minuscules.
À part l'attribut \CodeInline{plainPassword} utilisé pour créer un utilisateur et le champ \CodeInline{createdAt} associé à un token d'authentification, toutes nos attributs sont en minuscule. Mais dans le cadre d'une API plus complète, la question de la casse va se poser.



La seule contrainte qu'il faudra garder en tête est \textbf{la cohérence}. Si nous décidons d'utiliser des noms d'attributs en camelCase ou en snake\_case, il faudra s'en tenir à ça pour tous les appels de l'API.



La configuration de tels paramètres est très simple aussi bien avec le sérialiseur de base de Symfony qu'avec le \textit{JMSSerializer}. Nous allons donc garder la configuration par défaut du sérialiseur de Symfony qui est de conserver le même nom que celui des attributs de nos objets.



\begin{CodeBlock}{yaml}
# app/config/config.yml

imports:
    - { resource: parameters.yml }
    - { resource: security.yml }
    - { resource: services.yml }

parameters:
    locale: en
    jms_serializer.camel_case_naming_strategy.class: JMS\Serializer\Naming\IdenticalPropertyNamingStrategy

# ...
\end{CodeBlock}



\levelFiveTitle{Désactivation du sérialiseur natif}


Maintenant que nous avons fini la configuration, il faut désactiver le sérialiseur natif de Symfony.



Vu qu'il n'est pas activé par défaut, nous pouvons retirer la configuration associée ou passer sa valeur à \CodeInline{false}.



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...

framework:
    # ...
    serializer:
        enabled: false
# ...
\end{CodeBlock}



\textit{FOSRestBundle} va maintenant utiliser directement le sérialiseur fournit par \textit{JMSSerializerBundle}.



\levelFourTitle{Sérialiser les attributs même s'ils sont nuls}


Le comportement par défaut de \textit{JMSSerializer} est d'ignorer tous les attributs nuls d'un objet. Ce fonctionnement peut entrainer des réponses avec des payloads partiels manquant certains attributs.
Pour éviter ce problème, \textit{FOSRestBundle} propose un paramètre de configuration pour forcer \textit{JMSSerializer} à sérialiser les attributs nuls.



\begin{CodeBlock}{yaml}
# app/config/config.yml

# ...

fos_rest:
    serializer:
        serialize_null:  true
\end{CodeBlock}



\levelThreeTitle{Impact sur l'existant}


\levelFourTitle{Tests de la configuration}


Pour tester notre configuration, nous allons lister les lieux dans notre application.



La réponse obtenue est :



\begin{CodeBlock}{json}
{
  "0": {},
  "1": {}
}
\end{CodeBlock}



Nous avons là une bonne et une mauvaise nouvelle. Le bundle est bien utilisé pour sérialiser la réponse mais les groupes de sérialisation, que nous avons définis, ne sont pas encore exploités.



\begin{Question}
Pourquoi la réponse n'est pas sérialisée correctement ?
\end{Question}


Le sérialiseur est pleinement supporté par \textit{FOSRestBundle}. Les configurations dans tous nos contrôleurs sont déjà compatibles.
Par contre, le fichier \textbf{\textit{src/AppBundle/Resources/config/serialization.yml}} décrivant les règles de sérialisation, est ignoré par \textit{JMSSerializerBundle}.



La configuration par défaut se base sur une convention simple. Pour un bundle, les fichiers décrivant la sérialisation doivent être dans le dossier \textbf{\textit{src/NomDuBundle/Resources/config/serializer/}}.



Le nom de chaque fichier contenant les règles de sérialisation d'une classe est obtenu en faisant deux opérations :



\begin{itemize}
\item le nom du bundle est retiré du namespace (espace de nom) de la classe ;
\item les séparateurs anti-slash (\CodeInline{\textbackslash{}}) sont remplacés par des points (\CodeInline{.}) ;
\item et enfin, l'extension yml ou xml est rajouté au nom ainsi obtenu.
\end{itemize}


Par exemple, pour la classe \CodeInline{NomDuBundle\textbackslash{}A\textbackslash{}B}, si nous voulons utiliser une configuration en YAML, nous devons avoir un fichier \textbf{\textit{src/NomDuBundle/Resources/config/serializer/A.B.yml}}.



\begin{Information}
\textit{JMSSerialiserBundle} supporte aussi les annotations et les fichiers XML pour la configuration des règles de sérialisation. D'ailleurs, si nous avions utilisé les annotations, le code fonctionnerait sans adaptation de notre part.
\end{Information}


\levelFourTitle{Mise à jour de nos règles de sérialisation}


Pour remettre notre API d'aplomb, nous allons créer les fichiers de configuration pour les classes utilisées.



Commençons par l'entité \CodeInline{Place}. La configuration pour cette classe devient :



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serializer/Entity.Place.yml
AppBundle\Entity\Place:
    exclusion_policy: none
    properties:
        id:
            groups: ['place', 'price', 'theme']
        name:
            groups: ['place', 'price', 'theme']
        address:
            groups: ['place', 'price', 'theme']
        prices:
            groups: ['place']
        themes:
            groups: ['place']
\end{CodeBlock}



Par défaut, aucune propriété de nos classes n'est affichée pendant la sérialisation. En mettant l'attribut \CodeInline{exclusion\_policy} à \CodeInline{none}, nous configurons le sérialiseur pour inclure par défaut toutes les propriétés de la classe. Nous pourrons bien sûr exclure certaines propriétés à la demande (\CodeInline{exclude: true}).



De même, il est aussi possible d'adopter la stratégie inverse à savoir exclure par défaut toutes les propriétés de nos classes et les ajouter à la demande (\CodeInline{expose: true}).



Il faut aussi noter que l'attribut \CodeInline{attributes} dans l'ancien fichier de configuration est remplacé par \CodeInline{properties}. Tout le reste est identique à notre ancien fichier de configuration.



La configuration des nouvelles classes devient maintenant :



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serializer/Entity.Price.yml
AppBundle\Entity\Price:
    exclusion_policy: none
    properties:
        id:
            groups: ['place', 'price']
        type:
            groups: ['place', 'price']
        value:
            groups: ['place', 'price']
        place:
            groups: ['price']
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serializer/Entity.Theme.yml
AppBundle\Entity\Theme:
    exclusion_policy: none
    properties:
        id:
            groups: ['place', 'theme']
        name:
            groups: ['place', 'theme']
        value:
            groups: ['place', 'theme']
        place:
            groups: ['theme']
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serializer/Entity.User.yml
AppBundle\Entity\User:
    exclusion_policy: none
    properties:
        id:
            groups: ['user', 'preference', 'auth-token']
        firstname:
            groups: ['user', 'preference', 'auth-token']
        lastname:
            groups: ['user', 'preference', 'auth-token']
        email:
            groups: ['user', 'preference', 'auth-token']
        preferences:
            groups: ['user']
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serializer/Entity.Preference.yml
AppBundle\Entity\Preference:
    exclusion_policy: none
    properties:
        id:
            groups: ['user', 'preference']
        name:
            groups: ['user', 'preference']
        value:
            groups: ['user', 'preference']
        user:
            groups: ['preference']
\end{CodeBlock}



\begin{CodeBlock}{yaml}
# src/AppBundle/Resources/config/serializer/Entity.AuthToken.yml
AppBundle\Entity\AuthToken:
    exclusion_policy: none
    properties:
        id:
            groups: ['auth-token']
        value:
            groups: ['auth-token']
        createdAt:
            groups: ['auth-token']
        user:
            groups: ['auth-token']
\end{CodeBlock}



\begin{Error}
N'oubliez pas de vider le cache pour éviter tout problème.
\end{Error}


En testant cette nouvelle configuration, la liste des lieux dans notre application redevient correcte.



\begin{CodeBlock}{json}
[
  {
    "id": 1,
    "name": "Tour Eiffel",
    "address": "5 Avenue Anatole France, 75007 Paris",
    "prices": [
      {
        "id": 1,
        "type": "less_than_12",
        "value": 5.75
      }
    ],
    "themes": [
      {
        "id": 1,
        "name": "architecture",
        "value": 7
      },
      {
        "id": 2,
        "name": "history",
        "value": 6
      }
    ]
  },
  {
    "id": 2,
    "name": "Mont-Saint-Michel",
    "address": "50170 Le Mont-Saint-Michel",
    "prices": [],
    "themes": [
      {
        "id": 3,
        "name": "history",
        "value": 3
      },
      {
        "id": 4,
        "name": "art",
        "value": 7
      }
    ]
  }
]
\end{CodeBlock}



Vous pouvez tester l'ensemble des appels que nous avons déjà mis en place. L'API se comporte exactement de la même façon.



\horizontalLine



L'intégration de \textit{JMSSerializerBundle} avec \textit{FOSRestBundle} est aussi simple qu'avec le sérialiseur natif de Symfony.
En effet, \textit{FOSRestBundle} nous offre une interface unique et s'adapte au sérialiseur mis à sa disposition.



En plus, le bundle \externalLink{\textit{JMSSerializerBundle}}{http://jmsyst.com/bundles/JMSSerializerBundle} supporte beaucoup de fonctionnalités que nous n'avons pas abordées (gestion des versions, propriétés virtuelles, etc.).



Vous avez pu remarquer que \textit{JMSSerializer} nécessite un peu plus de configuration que le sérialiseur natif de Symfony. Par contre, le travail fourni pour obtenir un résultat correct est très rapidement rentabilisé vu que \textit{JMSSerializerBundle} s’intègre facilement avec beaucoup d'autres bundles de Symfony.



Nous aurons d'ailleurs l'occasion d'exploiter ce bundle dans le chapitre sur la documentation.



\levelTwoTitle{La documentation avec OpenAPI (Swagger RESTFul API)}


\begin{Question}
Que serait une API s'il était impossible de comprendre son mode de fonctionnement ?
\end{Question}


Parler de documentation dans une API RESTful se rapproche beaucoup d'un oxymore. En effet, une API dite RESTFul devrait pouvoir être utilisée sans documentation.



Mais si vous vous souvenez bien, notre API n'implémente pas le niveau 3 du modèle de maturité de Richardson : HATEOAS qui permettrait de l'explorer automatiquement et d'interagir avec elle. Dès lors, pour faciliter son usage nous devons créer une documentation.



Elle permettra ainsi aux clients de notre API de comprendre son mode de fonctionnement et d'explorer rapidement les différentes fonctionnalités qu'elle expose.



Il existe un standard appelé \textit{OpenAPI}, anciennement connu sous le nom de \textit{Swagger RESTful API}, permettant d'avoir des spécifications simples pour une documentation exhaustive.



L'objectif de cette partie est d'avoir un aperçu de \textit{OpenAPI} et de voir comment mettre en place une documentation en implémentant ces spécifications.



\levelThreeTitle{Qu'est-ce que OpenAPI ?}


\textit{OpenAPI} désigne \externalLink{un ensemble de spécifications}{http://swagger.io/specification/} permettant de \textbf{décrire} et de \textbf{documenter} une API REST.



Le terme \textbf{décrire} n'est pas utilisé par hasard car implémenter ces spécifications permet entre autres :



\begin{itemize}
\item d'obtenir une documentation (\externalLink{Swagger UI}{http://swagger.io/swagger-ui/}) ;
\item et de générer des clients permettant d'interagir avec notre API (\externalLink{Swagger Codegen}{http://swagger.io/swagger-codegen/}).
\end{itemize}


Les spécifications permettent de créer un fichier JSON qui décrit l'ensemble des éléments d'une API (URL des ressources, code de statut des réponses, verbes HTTP utilisés, etc.). Par convention, ce fichier est souvent nommé \textbf{\textit{swagger.json}}.



Pour cette partie nous allons commencer par la pratique avant d'explorer la théorie autour de la documentation des API REST avec \textit{OpenAPI}.



\levelThreeTitle{Rédaction de la documentation}


\levelFourTitle{Quel outil pouvons-nous utiliser pour créer la documentation ?}


Bien que le résultat final du fichier \textit{OpenAPI} soit en JSON, il peut être rédigé aussi bien en JSON qu'en YAML. Nous préférerons d'ailleurs le YAML par la suite.



Pour créer ce fichier \textbf{\textit{swagger.json}}, il faut suivre les spécifications qui sont disponibles en ligne : \externalLink{Spécification \textit{OpenAPI} (Swagger)}{http://swagger.io/specification/}.



L'un des moyens les plus simples pour rédiger et tester les spécifications est d'utiliser le site \externalLink{Swagger Editor}{http://editor.swagger.io}. Ce site propose une prévisualisation de la documentation qui sera générée et des exemples de configuration (en YAML) qui permettent de mieux appréhender les spécifications d'\textit{OpenAPI}.



\levelFourTitle{Structure de base du fichier swagger.json}


Un fichier \textbf{\textit{swagger.json}} a trois attributs obligatoires :



\begin{itemize}
\item \CodeInline{swagger} : définit la version des spécifications utilisées ;
\item \CodeInline{info} : définit les métadonnées de notre API ;
\item et \CodeInline{paths} : définit les différentes URL et opérations disponibles dans l'API.
\end{itemize}


Le fichier de base ressemble donc a :



\begin{CodeBlock}{yaml}
swagger: '2.0' # obligatoire
info: # obligatoire
  title: Proposition de suggestions API    # obligatoire
  description: Proposer des idées de sortie à des utilisateurs en utilisant leurs préférences
  version: "1.0.0" # obligatoire

host: rest-api.local
schemes:
  - http
produces:
  - application/json
  - application/xml
consumes:
  - application/json
  - application/xml
  
paths: # obligatoire
\end{CodeBlock}



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/uJ6Q0q5uk2Wb.png}[Prévisualisation de la structure de base]


Les attributs \CodeInline{produces} et \CodeInline{consumes} permettent de décrire les type \abbr{MIME}{Multipurpose Internet Mail Extensions} des réponses renvoyées et des requêtes acceptées par notre API.
Il est possible d'utiliser du \externalLink{Markdown}{https://help.github.com/articles/basic-writing-and-formatting-syntax/} pour formater les différentes descriptions (attributs \CodeInline{description}) dans la documentation.



\begin{Information}
Tous les tests se feront en utilisant directement le site \externalLink{http://editor.swagger.io}{http://editor.swagger.io}. Le fichier \textbf{\textit{swagger.json}} définitif sera testé en local dans la dernière partie.
\end{Information}


\levelFourTitle{Déclarer une opération avec l'API}


\levelFiveTitle{Documentation de la méthode de connexion}


Pour commencer, nous allons essayer de rédiger la documentation de la méthode d'authentification à l'API.
Pour déclarer une opération, nous devons utiliser l'attribut \CodeInline{paths}.



\begin{CodeBlock}{yaml}
swagger: '2.0' # obligatoire
info: # obligatoire
  title: Proposition de suggestions API    # obligatoire
  description: Proposer des idées de sortie à des utilisateurs en utilisant leurs préférences
  version: "1.0.0" # obligatoire

host: rest-api.local
schemes:
  - http
produces:
  - application/json
  - application/xml
consumes:
  - application/json
  - application/xml
  
paths: # obligatoire
  /auth-tokens:
    post:
      summary: Authentifie un utilisateur
      description: Crée un token permettant à l'utilisateur d'accéder aux contenus protégés
      responses: # obligatoire
\end{CodeBlock}



Voici la base permettant de créer des opérations. Sous l'attribut \CodeInline{paths}, il faut définir l'URL de notre ressource et ensuite il faut déclarer les différents verbes HTTP qui sont utilisés sur celle-ci.
Actuellement, nous avons la méthode \CodeInline{POST} permettant de créer un token. Nous devons maintenant définir :



\begin{itemize}
\item le payload de la requête ;
\item la réponse en cas de succès ;
\item la réponse en cas d'erreur.
\end{itemize}


Toutes ces données sont déclarées en utilisant les spécifications de \externalLink{JSON Schema}{http://json-schema.org/}.



\begin{CodeBlock}{yaml}
# ...
paths: # obligatoire
  /auth-tokens:
    post:
      summary: Authentifie un utilisateur
      description: Crée un token permettant à l'utilisateur d'accéder aux contenus protégés
      parameters:
        - name: credentials  # obligatoire
          in: body  # obligatoire
          required: true
          description: Login et mot de passe de l'utilisateur
          schema:
            type: object
            required: [login, password]
            properties:
              login: 
                type: string
              password:
                type: string
            
            
      responses:
        200:
          description: Token créé  # obligatoire
          schema:
            type: object
            properties:
              id:
                type: integer
              value:
                type: string
              created_at:
                type: string
                format: date-time
              user:
                type: object
                properties:
                  id:
                    type: integer
                  email:
                    type: string
                    format: email
                  firstname:
                    type: string
                  lastname:
                    type: string
      
        400:
          description: Donnée invalide  # obligatoire
          schema:
            type: object
            required: [message]
            properties:
              code:
                type: integer
              message:
                type: string
              errors:
                type: object
                properties:
                  children:
                    type: object
                    properties:
                      login:
                        type: object
                        properties:
                          errors:
                            type: array
                            items:
                              type: string
                      password:
                        type: object
                        properties:
                          errors:
                            type: array
                            items:
                              type: string  
\end{CodeBlock}



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/9Hqj_dtgoDM4.png}[Documentation de la méthode de création d'un token]


Il est aussi possible de mieux organiser le fichier en rajoutant une entrée \CodeInline{definitions} qui permet de regrouper tous les schémas que nous avons déclarés. Ensuite, il suffira de faire référence à ces schémas en utilisant l'attribut \CodeInline{\$ref}.



\begin{CodeBlock}{yaml}
# ...
paths: # obligatoire
  /auth-tokens:
    post:
      summary: Authentifie un utilisateur
      description: Crée un token permettant à l'utilisateur d'accéder aux contenus protégés
      parameters:
        - name: credentials  # obligatoire
          in: body  # obligatoire
          required: true
          description: Login et mot de passe de l'utilisateur
          schema:
            $ref: "#/definitions/Credentials"
            
      responses:
        200:
          description: Token créé  # obligatoire
          schema:
            $ref: "#/definitions/AuthToken.auth-token"

        400:
          description: Donnée invalide  # obligatoire
          schema:
             $ref: "#/definitions/CredentialsTypeError" 

definitions:
  Credentials:
    type: object
    required: [login, password]
    properties:
      login: 
        type: string
      password:
        type: string
        
  AuthToken.auth-token:
    type: object
    required: [id, value, created_at, user]
    properties:
      id:
        type: integer
      value:
        type: string
        title: Token d'authentification
        description: Valeur à utiliser dans l'entête X-Auth-Token
      created_at:
        type: string
        format: date-time
      user:
        type: object
        properties:
          id:
            type: integer
          email:
            type: string
            format: email
          firstname:
            type: string
          lastname:
            type: string       
    
  CredentialsTypeError:
    type: object
    required: [message]
    properties:
      code:
        type: integer
      message:
        type: string
      errors:
        type: object
        properties:
          children:
            type: object
            properties:
              login:
                type: object
                properties:
                  errors:
                    type: array
                    items:
                      type: string
              password:
                type: object
                properties:
                  errors:
                    type: array
                    items:
                      type: string
\end{CodeBlock}



Avec ces modifications, le résultat obtenu est exactement identique.



\levelFiveTitle{Documentation de la méthode de déconnexion}


De la même façon pour documenter la suppression d'un token, nous devons rajouter une nouvelle URL. Mais cette fois-ci, elle doit être dynamique comme pour les routes Symfony.



\begin{CodeBlock}{yaml}
# ...
  
paths: # obligatoire
  /auth-tokens:
   # ...

  /auth-tokens/{id}:
    delete:
      summary: Déconnecte un utilisateur
      description: Supprime le token de l'utilisateur
      parameters:
        - $ref: "#/parameters/X-Auth-Token"
        - name: id  # obligatoire
          in: path  # obligatoire
          type: integer  # obligatoire si le paramètre dans in est différent de 'body'
          required: true
          description: Identifiant du token à supprimer
            
      responses:
        204:
          description: Token supprimé  # obligatoire

        400:
          description: Donnée invalide  # obligatoire
          schema:
             $ref: "#/definitions/GenericError" 


parameters:
  X-Auth-Token:
    name: X-Auth-Token  # obligatoire
    in: header  # obligatoire
    type: string  # obligatoire si le paramètre dans in est différent de 'body'
    required: true
    description: Valeur du token d'authentification


definitions:
  # ...                
  GenericError:
    type: object
    required: [code, message]
    properties:
      code: 
        type: string
      message:
        type: string
\end{CodeBlock}



À l'instar de la méthode de connexion, nous utilisons aussi le paramètre \CodeInline{in} pour désigner l'identifiant du token. Cet attribut peut valoir :



\begin{itemize}
\item \CodeInline{path} : le paramètre est extrait de l'URL de la ressource ;
\item \CodeInline{query} : le paramètre est un query string ;
\item \CodeInline{header} : le paramètre est une entête HTTP ;
\item \CodeInline{body} : le paramètre est dans le payload ;
\item \CodeInline{form} : le paramètre est dans le payload qui est encodé au format  \textit{application/x-www-form-urlencoded} ou \textit{multipart/form-data} (c'est le format utilisé par un formulaire classique).
\end{itemize}


L'entête HTTP \CodeInline{X-Auth-Token} est utilisée par plusieurs requêtes de notre API. En le déclarant dans l'attribut \CodeInline{parameters}, cela nous permet de le réutiliser dans les appels API qui nous intéressent.



\begin{Information}
Il existe deux attributs \CodeInline{securityDefinitions} et \CodeInline{security} permettant de configurer la méthode d'authentification sans passer par l'attribut \CodeInline{parameters}. Mais pour les besoins de cet exemple, nous ne les utiliserons pas.
\end{Information}


\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/AUDoqA00Lreb.png}[Documentation de la méthode de suppression d'un token]


Toutes les informations utilisées pour créer ce fichier sont issues \externalLink{des spécifications officielles d'\textit{OpenAPI}}{http://swagger.io/specification/}. Vous pourrez les consulter afin de voir l'ensemble des fonctionnalités qu'offrent \textit{OpenAPI}.



\levelThreeTitle{Installer et utiliser Swagger UI}


\textit{Swagger UI} est un logiciel basé sur les technologies du web (HTML, Javascript, CSS) permettant de générer une documentation en utilisant les spécifications d'\textit{OpenAPI}. Il fournit aussi un bac à sable permettant de tester les appels API directement depuis la documentation générée.



\levelFourTitle{Installation de Swagger UI}


Pour installer Swagger UI, il suffit de \externalLink{le télécharger depuis GitHub}{https://github.com/swagger-api/swagger-ui/tree/v2.1.4}. Ensuite, nous allons le décompresser dans un dossier nommé \textbf{\textit{swagger-ui}} dans le répertoire \textbf{\textit{web}}. Nous utiliserons la version v2.1.4.



\begin{Information}
Si vous utilisez \textit{git}, il suffit de se placer dans le dossier \textbf{\textit{web}} et de lancer :

\begin{CodeBlock}{bash}
git clone https://github.com/swagger-api/swagger-ui.git
git checkout v2.1.4
\end{CodeBlock}
\end{Information}


\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/cekV4YCL7Mir.png}[Arborescence après l'installation de Swagger UI]


Si l'installation s'est bien déroulée, en accédant à l'URL \externalLink{http://rest-api.local/swagger-ui/dist/index.html}{http://rest-api.local/swagger-ui/dist/index.html}, la page d'accueil de Swagger UI s'affiche.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/jJicGSvQ5RHq.png}[Page d'accueil de Swagger UI]


\levelFourTitle{Utiliser notre documentation}


Depuis l'interface de Swagger Editor, il est possible d'exporter notre documentation au format JSON. Le fichier \textbf{\textit{swagger.json}} ainsi obtenu ressemble à :



\begin{CodeBlock}{json}
{
    "swagger": "2.0",
    "info": {
        "title": "Proposition de suggestions API",
        "description": "Proposer des idées de sortie à des utilisateurs en utilisant leurs préférences",
        "version": "1.0.0"
    },
    "host": "rest-api.local",
    "schemes": [
        "http"
    ],
    "produces": [
        "application/json",
        "application/xml"
    ],
    "consumes": [
        "application/json",
        "application/xml"
    ],
    "paths": {
        // ...
    },
    "parameters": {
         // ...
    },
    "definitions": {
         // ...
    }
}
\end{CodeBlock}



Pour utiliser ce fichier \textbf{\textit{swagger.json}}, il faut commencer par l'enregistrer dans le dossier \textbf{\textit{web}}. Le fichier doit être disponible depuis un navigateur.
Ensuite, il faut éditer le fichier \textbf{\textit{web/swagger-ui/dist/indext.html}} et éditer les lignes 34 à 39.



\begin{CodeBlock}{javascript}
 /*var url = window.location.search.match(/url=([^&]+)/);
  if (url && url.length > 1) {
    url = decodeURIComponent(url[1]);
  } else {
    url = "http://petstore.swagger.io/v2/swagger.json";
  }*/
var url ="/swagger.json";
\end{CodeBlock}



En consultant l'URL, nous pouvons maintenant voir notre documentation et même tester les appels API depuis celui-ci.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/xWnGLzvl1ueH.png}[Documentation de notre API avec Swagger UI]


\horizontalLine



Après cette brève initiation à \textit{OpenAPI}, connu aussi sous le nom de \textit{Swagger RESTFul API}, vous avez pu remarquer que l’écosystème autour de cette technologie est assez riche.



Ces spécifications se basent sur un ensemble de standards reconnus comme \externalLink{JSON Schema}{http://json-schema.org/} qui facilitent grandement sa prise en main.



Le fichier \textbf{\textit{swagger.json}} ainsi obtenu peut être exploité par beaucoup d'outils qui permettent d'augmenter notre productivité (Génération de code client, génération de code serveur, interface de documentation avec bac à sable, etc.).



\levelTwoTitle{Automatiser la documentation avec NelmioApiDocBundle}


Bien que les outils de l'écosystème de \textit{OpenAPI (Swagger RESTFull API)} soient assez bien fournis, rédiger manuellement toute la documentation peut se montrer assez rapidement rébarbatif.



En plus, à cause de la séparation entre le code et la documentation, cette dernière risque de ne pas être mise à jour si le code évolue.



Nous allons donc voir comment automatiser la génération de la documentation dans Symfony avec le bundle \textit{NelmioApiDocBundle}.



Cette partie n'abordera pas toutes les fonctionnalités de ce bundle mais permettra d'avoir assez de bagages pour être autonome.



\levelThreeTitle{Installation de NelmioApiDocBundle}


La référence en matière de documentation d'une API avec Symfony est le bundle \textit{NelmioApiDocBundle}. Comme pour tous les bundles de Symfony, l'installation est particulièrement simple.
Avec \textit{Composer}, nous allons rajouter la dépendance :



\begin{CodeBlock}{bash}
composer require nelmio/api-doc-bundle
# Using version ^2.12 for nelmio/api-doc-bundle
./composer.json has been updated
\end{CodeBlock}



Nous pouvons maintenant activer le bundle :



\begin{CodeBlock}{php}
<?php
# app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = [
            // ...
            new Nelmio\ApiDocBundle\NelmioApiDocBundle(),
            new AppBundle\AppBundle(),
        ];

       // ...
        return $bundles;
    }
// ...
}
\end{CodeBlock}



\levelThreeTitle{L'annotation ApiDoc}


\levelFourTitle{Configuration}


Pour générer de la documentation, le bunble \textit{NelmioApiDocBundle} se base sur une fonctionnalité principale : l'annotation \CodeInline{ApiDoc}.



À son installation, ce bundle met à notre disposition cette annotation qui va nous permettre de \textbf{rédiger} notre documentation.



\begin{Information}
Il faut garder en tête que la documentation avec \textit{NelmioApiDocBundle} est grandement liée au code.
\end{Information}


Sans plus attendre, nous allons l'utiliser pour documenter l'appel qui liste les lieux de notre application.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class PlaceController extends Controller
{

    /**
     * @ApiDoc(
     *    description="Récupère la liste des lieux de l'application"
     * )
     *
     *
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     * @QueryParam(name="offset", requirements="\d+", default="", description="Index de début de la pagination")
     * @QueryParam(name="limit", requirements="\d+", default="", description="Nombre d'éléments à afficher")
     * @QueryParam(name="sort", requirements="(asc|desc)", nullable=true, description="Ordre de tri (basé sur le nom)")
     */
    public function getPlacesAction(Request $request, ParamFetcher $paramFetcher)
    {
        // ...

        return $places;
    }
// ...
}
\end{CodeBlock}



Avec juste cette annotation, il est possible de consulter la documentation de notre API. Mais avant d'y accéder, nous devons avoir une URL dédiée. Et pour ce faire, le bundle propose un fichier de routage qui permet de configurer cette URL.



\begin{CodeBlock}{yaml}
# app/config/routing.yml

# ...
nelmio-api-doc:
    resource: "@NelmioApiDocBundle/Resources/config/routing.yml"
    prefix:   /documentation
\end{CodeBlock}



Nous allons aussi rajouter une règle dans le pare-feu de Symfony afin d'autoriser l'accès à la documentation sans authentification.



\begin{CodeBlock}{yaml}
# app/config/secrity.yml
security:

# ...
    firewalls:
        # disables authentication for assets and the profiler, adapt it according to your needs
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false

        doc:
            pattern: ^/documentation
            security: false
# ...
\end{CodeBlock}



Notre documentation est maintenant accessible depuis l'URL \externalLink{http://rest-api.local/documentation}{http://rest-api.local/documentation}.



En y accédant depuis un navigateur, nous obtenons une page générée automatiquement :



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/2IO6Mn-R48MW.png}[Documentation générée par NelmioApiDocBundle]


Pour avoir une vue complète (comme sur l'image), il faut cliquer sur la méthode \CodeInline{GET /places} pour dérouler les détails concernant les filtres. La mise en page de la documentation est grandement inspiré de \textit{Swagger UI}.



\levelFourTitle{Intégration avec FOSRestBundle}


Le premier point qui devrait vous interpeller est la présence des filtres de \textit{FOSRestBundle} dans la documentation.
\textit{NelmioApiDocBundle} a été conçu pour interagir avec la plupart des bundles utilisés dans le cadre d'une API. 
Ainsi, les annotations de \textit{FOSRestBundle} sont utilisées pour compléter la documentation.



Bien sûr, si nous n'utilisons pas \textit{FOSRestBundle}, nous pouvons rajouter manuellement des filtres en utilisant l'attribut \CodeInline{filters} de l'annotation \CodeInline{ApiDoc}.



De la même façon, le verbe HTTP utilisé est \CodeInline{GET} avec une URL \CodeInline{/places}. Là aussi, les routes générées par Symfony sont utilisées par \textit{NelmioApiDocBundle}.



\levelFourTitle{Définir le type des réponses de l'API}


Notre documentation n'est pas encore complète. Le type des réponses renvoyées par notre API n'est pas encore documenté.



Pour ce faire, il existe un attribut nommé \CodeInline{output} qui prend comme paramètre le nom d'une classe ou encore une collection. Cet attribut supporte aussi les groupes de sérialisation que nous avons déjà définis.



Pour le cas des lieux, nous devons renvoyer une collection de lieux. La documentation s'écrit donc :



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;
// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class PlaceController extends Controller
{

    /**
     * @ApiDoc(
     *    description="Récupère la liste des lieux de l'application",
     *    output= { "class"=Place::class, "collection"=true, "groups"={"place"} }
     * )
     * @Rest\View(serializerGroups={"place"})
     * @Rest\Get("/places")
     * @QueryParam(name="offset", requirements="\d+", default="", description="Index de début de la pagination")
     * @QueryParam(name="limit", requirements="\d+", default="", description="Nombre d'éléments à afficher")
     * @QueryParam(name="sort", requirements="(asc|desc)", nullable=true, description="Ordre de tri (basé sur le nom)")
     */
    public function getPlacesAction(Request $request, ParamFetcher $paramFetcher)
    {
    // ...
    }
// ...
}
\end{CodeBlock}



La documentation devient :



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/M2wUkp9uUYX1.png}[Type de réponse pour la liste des lieux]


La documentation est complétée et les attributs ont exactement les bon types définis dans les annotations \textit{Doctrine}. Pour obtenir de telles informations, \textit{NelmioApiDocBundle} utilise le sérialiseur de \textit{JMSSerializerBundle}.



\begin{Error}
Par contre, si nous étions restés sur le sérialiseur natif de Symfony qui n'est pas encore supporté, nous n'aurions pas pu obtenir ces informations.
\end{Error}


Les descriptions de tous les attributs sont vides. Pour les renseigner, il suffit de rajouter dans les entités une description dans le bloc de \textit{PHPDoc}.



Pour l'entité \CodeInline{Place}, nous pouvons rajouter :



\begin{CodeBlock}{php}
<?php
    /**
     * Identifiant unique du lieu
     *
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    protected $id;
\end{CodeBlock}



La documentation générée devient alors :



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/EAt6uKJsY8qn.png}[Description de l'identifiant du lieu dans la documentation]


\levelFourTitle{Définir le type des payloads des requêtes}


De la même façon, pour définir la structure des payloads des requêtes, nous pouvons utiliser un attribut nommé \CodeInline{input} qui peut prendre en paramètre, entre autres, une classe qui implémente l'interface PHP \CodeInline{JsonSerializable} mais aussi un formulaire Symfony. Et cela tombe bien puisse que tous nos payloads se basent sur ces formulaires.



Pour tester le bon fonctionnement de cet attribut, nous allons rajouter de la documentation pour la méthode de création d'un lieu.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class PlaceController extends Controller
{
    // ...
     /**
     * @ApiDoc(
     *    description="Crée un lieu dans l'application",
     *    input={"class"=PlaceType::class, "name"=""}
     * )
     *
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"place"})
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
       // ...
    }
    // ...
}
\end{CodeBlock}



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/VLgqxeZVwvkn.png}[Documentation générée par NelmioApiDocBundle]


Pour rajouter des descriptions pour les différents attributs des formulaires, nous pouvons utiliser une option nommée \CodeInline{description} rajoutée aux formulaires Symfony par \textit{NelmioApiDocBundle}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Form/Type/PlaceType.php

namespace AppBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CollectionType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class PlaceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder->add('name', TextType::class, [
            'description' => "Nom du lieu"
        ]);
        $builder->add('address', TextType::class, [
            'description' => "Adresse complète du lieu"
        ]);
        $builder->add('prices', CollectionType::class, [
            'entry_type' => PriceType::class,
            'allow_add' => true,
            'error_bubbling' => false,
            'description' => "Liste des prix pratiqués"
        ]);
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => 'AppBundle\Entity\Place',
            'csrf_protection' => false
        ]);
    }
}
\end{CodeBlock}



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/wSHLovpCWYXw.png}[Documentation complétée avec les descriptions des attributs]


\levelFourTitle{Gérer plusieurs codes de statut}


En définissant l'attribut \CodeInline{output}, le code de statut associé par défaut est 200. Mais pour la création d'un lieu, nous devons avoir un code 201. Et de la même façon si le formulaire est invalide, nous voulons renvoyer une erreur 400 avec les messages de validation. Pour obtenir un tel résultat, \textit{NelmioApiDocBundle} met à notre disposition un attribut  \CodeInline{responseMap}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class PlaceController extends Controller
{
    // ...
     /**
     * @ApiDoc(
     *    description="Crée un lieu dans l'application",
     *    input={"class"=PlaceType::class, "name"=""},
     *    statusCodes = {
     *        201 = "Création avec succès",
     *        400 = "Formulaire invalide"
     *    },
     *    responseMap={
     *         201 = {"class"=Place::class, "groups"={"place"}},
     *         400 = { "class"=PlaceType::class, "form_errors"=true, "name" = ""}
     *    }
     * )
     *
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"place"})
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
       // ...
    }
    // ...
}
\end{CodeBlock}



Le paramètre \CodeInline{form\_errors} permet de spécifier le type de retour que nous voulons à savoir les erreurs de validation.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/jfXLjd-jFS8b.png}[Documentation de la création avec succès]


\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/KRK-owE_MsKK.png}[Documentation de la création avec des erreurs de validation]


Ici, nous avons bien deux réponses selon le code de statut mais pour la réponse lors d'un requête invalide, le format n'est pas correct (pas d'attribut \CodeInline{children}, l'attribut \CodeInline{status\_code} s'appelle \CodeInline{code}, etc.).



\levelThreeTitle{Étendre NelmioApiDocBundle}


\levelFourTitle{Pourquoi étendre le bundle ?}


Pour corriger les petits manquements de \textit{NelmioApiDocBundle}, nous allons étendre le code de celui-ci. L'objectif n'est pas d'apprendre le code source de ce bundle mais plutôt de maximiser son efficacité en l'adaptant à nos besoins.



\begin{Information}
Il est possible d'obtenir de la documentation en redéfinissant manuellement toutes ces informations manquantes. Mais l'intérêt réel de ce bundle réside dans le fait d'utiliser les composants déjà existants pour générer la documentation automatiquement. N'hésitez donc pas à consulter \externalLink{la documentation officielle}{https://github.com/nelmio/NelmioApiDocBundle} de NelmioApiDocBundle pour plus d'informations.
\end{Information}


\levelFourTitle{Correction du format de sortie des réponses en erreur}


Il n'y a pas de documentation sur comment étendre \textit{NelmioApiDocBundle}. Mais vu que ce bundle est open source, il suffit de relire avec attention son code pour comprendre son fonctionnement.



Il en ressort que pour traiter les informations disponibles dans les attributs \CodeInline{input} et \CodeInline{output} de l'annotation \CodeInline{ApiDoc}, le bundle utilise des parseurs.



Et \externalLink{la documentation officielle}{https://github.com/nelmio/NelmioApiDocBundle/blob/master/Resources/doc/configuration-in-depth.rst} nous explique comment en créer et comment l'utiliser.



Nous allons donc créer un parseur capable de générer les erreurs de validation au même format que \textit{FOSRestBundle}.



Ce code est grandement inspiré du parseur déjà existant (\externalLink{FormErrorsParser}{https://github.com/nelmio/NelmioApiDocBundle/blob/2.12.0/Parser/FormErrorsParser.php}).



\begin{CodeBlock}{php}
<?php
# src/Component/ApiDoc/Parser/FOSRestFormErrorsParser.php

namespace Component\ApiDoc\Parser;

use Nelmio\ApiDocBundle\DataTypes;
use Nelmio\ApiDocBundle\Parser\ParserInterface;
use Nelmio\ApiDocBundle\Parser\PostParserInterface;

class FOSRestFormErrorsParser implements ParserInterface, PostParserInterface
{
    
    public function supports(array $item)
    {
        return isset($item['fos_rest_form_errors']) && $item['fos_rest_form_errors'] === true;
    }

    public function parse(array $item)
    {
        return array();
    }


    public function postParse(array $item, array $parameters)
    {
        $params = [];

        // Il faut d'abord désactiver tous les anciens paramètres créer par d'autres parseurs avant de reformater
        foreach ($parameters as $key => $parameter) {
            $params[$key] = null;
        }

        $params['code'] = [
            'dataType' => 'integer',
            'actualType' => DataTypes::INTEGER,
            'subType' => null,
            'required' => false,
            'description' => 'The status code',
            'readonly' => true
        ];

        $params['message'] = [
            'dataType' => 'string',
            'actualType' => DataTypes::STRING,
            'subType' => null,
            'required' => true,
            'description' => 'The error message',
            'default' => 'Validation failed.',
        ];

        $params['errors'] = [
            'dataType' => 'errors',
            'actualType' => DataTypes::MODEL,
            'subType' => sprintf('%s.FormErrors', $item['class']),
            'required' => true,
            'description' => 'List of errors',
            'readonly' => true,
            'children' => [
                'children' => [
                    'dataType' => 'List of form fields',
                    'actualType' => DataTypes::MODEL,
                    'subType' => sprintf('%s.Children', $item['class']),
                    'required' => true,
                    'description' => 'Errors',
                    'readonly' => true,
                    'children' => []
                ]
            ]
        ];

        foreach ($parameters as $name => $parameter) {
            $params['errors']['children']['children']['children'][$name] = $this->doPostParse($parameter, $name, [$name], $item['class']);
        }
       
        return $params;
    }

    protected function doPostParse($parameter, $name, array $propertyPath, $type)
    {
        $data = [
            'dataType' => 'Form field',
            'actualType' => DataTypes::MODEL,
            'subType' => sprintf('%s.FieldErrors[%s]', $type, implode('.', $propertyPath)),
            'required' => true,
            'description' => 'Field name',
            'readonly' => true,
            'children' => [
                'errors'=> [
                    'dataType' => 'errors',
                    'actualType' => DataTypes::COLLECTION,
                    'subType' => 'string',
                    'required' => false,
                    'description' => 'List of field error messages',
                    'readonly' => true
                ]
            ]
        ];

        if ($parameter['actualType'] == DataTypes::COLLECTION) {
            $data['children']['children'] = [
                'dataType' => 'List of embedded forms fields',
                'actualType' => DataTypes::COLLECTION,
                'subType' => sprintf('%s.FormErrors', $parameter['subType']),
                'required' => true,
                'description' => 'Validation error messages',
                'readonly' => true,
                'children' =>  [
                    'children' => [
                        'dataType' => 'Embedded form field',
                        'actualType' => DataTypes::MODEL,
                        'subType' => sprintf('%s.Children', $parameter['subType']),
                        'required' => true,
                        'description' => 'List of errors',
                        'readonly' => true,
                        'children' => []
                    ]
                ]
            ];

            foreach ($parameter['children'] as $cName => $cParameter) {
                $cPropertyPath = array_merge($propertyPath, [$cName]);

                $data['children']['children']['children']['children']['children'][$cName] =   $this->doPostParse($cParameter, $cName, $cPropertyPath, $parameter['subType']);
            }

        }

        return $data;
    }
}
\end{CodeBlock}



Ce parseur doit toujours être utilisé avec \CodeInline{FormTypeParser} qui apporte l'ensemble des informations issues du formulaire Symfony. Pour l'activer, il faut utiliser l'attribut : \CodeInline{fos\_rest\_form\_errors} (voir la méthode \CodeInline{supports}).



Pour le déclarer en tant parseur prêt à l'emploi, nous devons créer un service avec le tag \CodeInline{nelmio\_api\_doc.extractor.parser}.



\begin{CodeBlock}{yaml}
# app/config/services.yml
services:
    # ...

    app_bundle.api_doc.fos_rest_form_errors_parser:
        class: Component\ApiDoc\Parser\FOSRestFormErrorsParser
        tags:
            - { name: nelmio_api_doc.extractor.parser, priority: 1 }
\end{CodeBlock}



\begin{Information}
Tous les parseurs natifs du bundle sont déclarés avec une priorité de 0. En utilisant une priorité de 1, nous nous assurons que notre parseur est toujours appelé en dernier.
\end{Information}


Pour utiliser notre parseur, nous allons ajuster l'annotation sur le contrôleur des lieux en utilisant l'attribut \CodeInline{fos\_rest\_form\_errors}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/PlaceController.php

namespace AppBundle\Controller;

// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class PlaceController extends Controller
{

    // ...

     /**
     * @ApiDoc(
     *    description="Crée un lieu dans l'application",
     *    input={"class"=PlaceType::class, "name"=""},
     *    statusCodes = {
     *        201 = "Création avec succès",
     *        400 = "Formulaire invalide"
     *    },
     *    responseMap={
     *         201 = {"class"=Place::class, "groups"={"place"}},
     *         400 = { "class"=PlaceType::class, "fos_rest_form_errors"=true, "name" = ""}
     *    }
     * )
     *
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"place"})
     * @Rest\Post("/places")
     */
    public function postPlacesAction(Request $request)
    {
        // ...
    }
    // ...
}
\end{CodeBlock}



La réponse pour un formulaire invalide est maintenant correctement formatée.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/CEiCPLv-DOw1.png}[Documentation de la réponse pour un formulaire invalide]


\levelThreeTitle{Le bac à sable}


Comme pour \textit{OpenAPI (Swagger RESTFul API)}, \textit{NelmioApiDocBundle} propose un bac à sable permettant de tester la documentation. Avant d'utiliser ce bac à sable, nous allons rajouter quelques informations de configuration.



\levelFourTitle{Configuration du bac à sable}


\externalLink{La documentation officielle}{https://github.com/nelmio/NelmioApiDocBundle/blob/master/Resources/doc/sandbox.rst} sur le bac à sable est concise et simple. Les paramètres disponibles sont d'ailleurs assez proches de ceux d'\textit{OpenAPI}.



Voyez donc par vous-même.



\begin{CodeBlock}{yaml}
# app/config/config.yml

nelmio_api_doc:
    sandbox:
        enabled:  true  # Juste pour la lisibilité car true est déjà la valeur par défaut
        endpoint: http://rest-api.local

        authentication:
            name: X-Auth-Token
            delivery: header

        accept_type: application/json   # valeur par défaut de l'entête Accept

        body_format:
            formats: [ json, xml ]                                 
            default_format: json                

        request_format:
            formats:                           
                json: application/json         
                xml: application/xml           

            method: accept_header     
            default_format: json    
\end{CodeBlock}



Cette configuration est assez explicite et se passe donc de commentaires. En accédant à la documentation avec l'URL \externalLink{http://rest-api.local/documentation}{http://rest-api.local/documentation}, nous obtenons :



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/I7JPcevRuU-O.png}[Bac à sable de NelmioApiDocBundle]


Le bac à sable est disponible en cliquant sur l'onglet \keys{Sandbox}.



\levelFourTitle{Documentation pour la création de token}


Avant de tester ce bac à sable, nous allons rajouter de la documentation pour la création de token d'authentification. Cela facilitera grandement nos tests.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/AuthTokenController.php

namespace AppBundle\Controller;

// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class AuthTokenController extends Controller
{
    /**
     * @ApiDoc(
     *    description="Crée un token d'authentification",
     *    input={ "class" = CredentialsType::class, "name"=""},
     *    statusCodes = {
     *        201 = "Création avec succès",
     *        400 = "Formulaire invalide"
     *    },
     *    responseMap={
     *         201 = {"class"=AuthToken::class, "groups"={"auth-token"}},
     *         400 = { "class"=CredentialsType::class, "fos_rest_form_errors"=true, "name" = ""}
     *    }
     * )
     *
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"auth-token"})
     * @Rest\Post("/auth-tokens")
     */
    public function postAuthTokensAction(Request $request)
    {
        //...
    }
//...
}
\end{CodeBlock}



Nous pouvons maintenant créer un token depuis le bac à sable.



\levelFourTitle{Tester le bac à sable}


Vu que toutes nos méthodes nécessites une authentification, il faut d'abord crée un token d'authentification. Ce token doit être renseigné dans le formulaire \CodeInline{api\_key}.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/v0DtTnHGwofT.png}[Token renseigné dans le formulaire]


Avec la configuration que nous avons mise en place, ce token sera envoyé automatiquement pour toutes nos requêtes.



Maintenant pour récupérer les lieux de l'application, il suffit de cliquer sur le bouton \keys{Try it!}.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/r7ExzOS1t3tC.png}[Récupération des lieux grâce au bac à sable]


\levelThreeTitle{Générer une documentation compatible OpenAPI}


Pour profiter des différents outils disponibles dans l’écosystème de \textit{Swagger}, \textit{NelmioApiDocBundle} propose d'exporter la configuration au format \textit{OpenAPI}.



Pour ce faire, il faut rajouter un attribut \CodeInline{resource} à nos annotations \CodeInline{ApiDoc}. Ensuite, il suffit d'utiliser la commande \CodeInline{php bin/console api:swagger:dump dossier\_de\_destination}.
Voici un exemple de configuration qui remplit ce contrat :



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Controller/AuthTokenController.php

namespace AppBundle\Controller;

// ...
use Nelmio\ApiDocBundle\Annotation\ApiDoc;
// ...

class AuthTokenController extends Controller
{
    /**
     * @ApiDoc(
     *    resource=true,
     *    description="Crée un token d'authentification",
     *    input={ "class" = CredentialsType::class, "name"=""},
     *    statusCodes = {
     *        201 = "Création avec succès",
     *        400 = "Formulaire invalide"
     *    },
     *    responseMap={
     *         201 = {"class"=AuthToken::class, "groups"={"auth-token"}},
     *         400 = { "class"=CredentialsType::class, "fos_rest_form_errors"=true, "name" = ""}
     *    }
     * )
     *
     * @Rest\View(statusCode=Response::HTTP_CREATED, serializerGroups={"auth-token"})
     * @Rest\Post("/auth-tokens")
     */
    public function postAuthTokensAction(Request $request)
    {
        // ...
    }

   // ...
}
\end{CodeBlock}



Les métadonnées concernant la documentation peuvent être modifiées en configurant le bundle.



\begin{CodeBlock}{yaml}
# app/config/config.yml
# ...
nelmio_api_doc:
    # ...
    swagger:
        api_base_path:        /
        swagger_version:      '1.2'
        api_version:          '1.0'
        info:
            title:                Rest API
            description:          'Proposition de sortie aux utilisateurs'
\end{CodeBlock}



\begin{Warning}
Avec la version 2.13.0, ce bundle génère un fichier \textbf{swagger.json} en utilisant \externalLink{la version 1.2 des spécifications d'\textit{OpenAPI}}{https://github.com/OAI/OpenAPI-Specification/blob/master/versions/1.2.md} alors qu'il existe une version 2.0. Le fichier généré ne sera donc pas à jour même si dans la configuration nous mettons 2.0 comme valeur de l'attribut \CodeInline{swagger\_version}.
\end{Warning}


En exécutant la commande :



\begin{CodeBlock}{bash}
php bin/console api:swagger:dump --pretty web/swagger
Dumping resource list to web/swagger/api-docs.json:  OK
Dump API declaration to web/swagger/auth-tokens.json:  OK
\end{CodeBlock}



Les fichiers ainsi générés dans le dossier \textbf{\textit{web/swagger}} peuvent être exploités par tous les outils compatibles avec \textit{OpenAPI}.



Pour les tester, il suffit d'éditer le fichier \textbf{\textit{web/swagger-ui/dist/indext.html}}  et de remplacer la ligne \CodeInline{var url ="/swagger.json";} par \CodeInline{var url ="/swagger/auth-tokens.json";}.



En accédant à l'URL \externalLink{http://rest-api.local/swagger-ui/dist/index.html}{http://rest-api.local/swagger-ui/dist/index.html}, la documentation générée s'affiche.



\image{/opt/zds/data/contents-public/creez-une-api-rest-avec-symfony-3__building/extra_contents/images/39gekpBYs_/XuVUY1QjawWl.png}[Documentation OpenAPI générée par NelmioApiDocBundle]


\horizontalLine



\textit{ApiDocBundle} supporte les différents bundles de Symfony et le tout permet d'avoir un ensemble harmonieux et facilite les développements.



L'un des problèmes les plus communs lorsque nous écrivons une documentation est de la maintenir à jour. Avec une documentation proche du code, il est maintenant très facile de la corriger en même temps que le code évolue.



En effet, un utilisant les annotations de \textit{FOSRestBundle}, les formulaires de Symfony et les fichiers de sérialisation de \textit{JMSSerializerBundle}, nous avons la garantie que la documentation est toujours à jour avec notre code.



Il ne reste plus qu'à tout mettre en production !



\levelTwoTitle{FAQ}


Dans cette section, nous allons aborder quelques points intéressants qui reviennent souvent dans les questions concernant ce cours.



Les points abordés n'ont pas de relation particulière et peuvent donc être lu dans n'importe quel ordre.



\levelThreeTitle{Comment générer des pages HTML depuis l'application Symfony 3 ?}


La configuration présentée durant ce cours implique que toute l'application ne génère que des réponses en JSON ou en XML. Cependant, il peut arriver qu'une même application puisse servir des réponses en JSON, en HTML voire en CSV.



Pour ce faire nous pouvons utiliser deux options que propose \textit{FOSRestBundle}.



\levelFourTitle{Utiliser plusieurs règles dans le \CodeInline{format\_listener}}


Dans notre fichier de configuration, nous avions :



\begin{CodeBlock}{yml}
fos_rest:
    serializer:
        serialize_null:   true

    routing_loader:
        include_format: false
    view:
        view_response_listener: true
        formats:
            json: true
            xml: true
    format_listener:
        rules:
            - { path: '^/', priorities: ['json', 'xml'], fallback_format: 'json', prefer_extension: false }
\end{CodeBlock}
\captionof{listing}{configuration du \CodeInline{format\_listener}}



Pour générer une page HTML, nous pouvons rajouter une nouvelle règle dans la clé \CodeInline{format\_listener.rules}. L'ordre de déclaration étant important, il faut toujours déclarer les règles les plus spécifiques en premier.



\begin{CodeBlock}{yml}
view:
        view_response_listener: true
        formats:
            json: true
            xml: true
        templating_formats:
            html: true
    format_listener:
        rules:
            - { path: '^/route/json', priorities: ['json'], fallback_format: 'json', prefer_extension: false }
            - { path: '^/route', priorities: ['html'], fallback_format: 'html', prefer_extension: false }
            - { path: '^/', priorities: ['json', 'xml'], fallback_format: 'json', prefer_extension: false }
\end{CodeBlock}
\captionof{listing}{Une nouvelle route pour créer du HTML}



Avec cette configuration, toutes les URLs commençant par \CodeInline{/route/json} renverront du JSON. Par contre, si l'URL commence par \CodeInline{/route} (mais sans la partie \CodeInline{/json}, \CodeInline{/route/other} par exemple) les réponses seront en HTML.



Si nous avions inversé ces deux règles, toutes les URLs \CodeInline{/route/json} renverraient aussi du HTML car l'expression régulière \CodeInline{\textasciicircum{}/route} englobe aussi \CodeInline{\textasciicircum{}/route/json}.



\begin{Information}
Comme pour les formats JSON et XML, la génération de réponse au format HTML est déjà supporté par défaut. Mais en rajoutant la clé \CodeInline{templating\_formats.html}, la configuration est plus lisible. De plus, nous utilisons \CodeInline{templating\_formats} au lieu de \CodeInline{formats} car pour les pages HTML, nous aurons besoin d'un \textit{template} pour les afficher.
\end{Information}


Nous pouvons rajouter autant de règles que nous voulons mais cela peut rapidement montrer ses limites. Nous avons ainsi la possibilité d'utiliser un autre système plus efficace pour isoler la partie API et la partie IHM\textsuperscript{\ref{footnote:2}} de son application.



\levelFourTitle{Configurer le \CodeInline{zone\_listener}}


Il existe un \textit{listener} de \textit{FOSRestBundle} que nous n'avons pas abordé qui permet d'isoler la partie API d'une application de manière très simple : le \CodeInline{zone\_listener}.



Le \CodeInline{zone\_listener} est un \textit{listener} qui nous permet de désactiver toutes les fonctionnalités de \textit{FOSRestBundle} pour un ensemble d'URLs.



Ajoutons d'abord un préfixe \CodeInline{/api} à toutes les routes de notre API. La déclaration des routes pourrait ressembler à :



\begin{CodeBlock}{yaml}
places:
    type:     rest
    resource: AppBundle\Controller\PlaceController
    prefix: /api

prices:
    type:     rest
    resource: AppBundle\Controller\Place\PriceController
    prefix: /api
...
\end{CodeBlock}
\captionof{listing}{Ajout d'un préfixe}



Tous les appels d'API restent identiques mais sont maintenant préfixés.



La configuration de \textit{FOSRestBundle} devient maintenant :



\begin{CodeBlock}{yaml}
# src/app/config/config.yml
fos_rest:
    routing_loader:
        include_format: false
    view:
        view_response_listener: true
    zone:
        - { path: ^/api }
    format_listener:
        rules:
            - { path: '^/api', priorities: ['json'], fallback_format: 'json' }
\end{CodeBlock}
\captionof{listing}{Configuration du \CodeInline{zone\_listener}}



La partie \CodeInline{zone} permet d'activer le bundle que pour les routes commençants par \CodeInline{/api}. Ainsi, toute requête en dehors de cette \textit{zone} sera gérée nativement par Symfony. Nous pouvons ainsi faire cohabiter notre API et une IHM complète sans soucis.



En utilisant ce système de zone, il ne faut pas oublier de reconfigurer toute la partie liée au pare-feu de Symfony et à notre système de sécurité pour prendre en compte le préfixe.



La configuration finale serait donc :



\begin{CodeBlock}{yml}
# app/config/security.yml
security:
    firewalls:
        main:
            pattern: ^/api
            stateless: true
            simple_preauth:
                authenticator: auth_token_authenticator
            provider: auth_token_user_provider
            anonymous: ~
\end{CodeBlock}



La clé \CodeInline{pattern} prend en compte le préfixe.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Security/AuthTokenAuthenticator.php
public function createToken(Request $request, $providerKey)
{
    $targetUrl = '/api/auth-tokens';
    // Si la requête est une création de token, aucune vérification n'est effectué
    if ($request->getMethod() === "POST" && $this->httpUtils->checkRequestPath($request, $targetUrl)) {
        return;
    }
  // ...
}
// ...
}
\end{CodeBlock}
\captionof{listing}{Prise en compte du pattern dans nos contrôleurs}



L'URL dans \CodeInline{targetUrl} contient maintenant notre préfixe \CodeInline{/api}.



Il est quand même utile de souligner qu'il est préférable d'utiliser une application à part pour générer ses pages HTML et avoir une application dédiée pour son API. L’intérêt de REST est d'avoir une architecture orientée service et donc de séparer les différents composants.



\footnotetext[2]{\label{footnote:2} Interface Homme Machine, dans notre cas la page qui s'affiche dans le navigateur.}

\levelThreeTitle{Comment autoriser l'accès à certaines urls avec notre système de sécurité ?}


Comme vous l'avez sans doute remarqué, une fois le système de sécurité est activé, seule la requête de création de token est autorisée. Mais dans les faits, il est assez courant d'avoir plusieurs appels d'API accessible sans authentification.



\begin{Question}
Par exemple, comment autoriser les utilisateurs à s'inscrire ?
\end{Question}


Actuellement cela est impossible mais nous pouvons corriger le tir très facilement.



Pour rappel, l'authentification est géré par la classe \CodeInline{AuthTokenAuthenticator} dont voici un extrait du code :



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Security/AuthTokenAuthenticator.php

namespace AppBundle\Security;

// ...

class AuthTokenAuthenticator implements SimplePreAuthenticatorInterface, AuthenticationFailureHandlerInterface
{
    /**
    * Durée de validité du token en secondes, 12 heures
    */
    const TOKEN_VALIDITY_DURATION = 12 * 3600;

    protected $httpUtils;

    public function __construct(HttpUtils $httpUtils)
    {
        $this->httpUtils = $httpUtils;
    }

    public function createToken(Request $request, $providerKey)
    {
        $targetUrl = '/auth-tokens';
        // Si la requête est une création de token, aucune vérification n'est effectué
        if ($request->getMethod() === "POST" && $this->httpUtils->checkRequestPath($request, $targetUrl)) {
            return;
        }
      
        $authTokenHeader = $request->headers->get('X-Auth-Token');

        if (!$authTokenHeader) {
            throw new BadCredentialsException('X-Auth-Token header is required');
        }

        return new PreAuthenticatedToken(
            'anon.',
            $authTokenHeader,
            $providerKey
        );
    }
    // ...
}
\end{CodeBlock}
\captionof{listing}{Le nouvel Authenticator}



Pour vérifier si une requête a été faite sur une certaine URL, la méthode \CodeInline{checkRequestPath} peut utiliser une route comme nous l'avons spécifié dans l'extrait de code ci-dessus, mais aussi le nom d'une route.



Le code peut donc être simplifié en utilisant directement le nom pour la route \CodeInline{auth-tokens} : \textit{post\_auth\_tokens}.



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Security/AuthTokenAuthenticator.php

namespace AppBundle\Security;

// ...

class AuthTokenAuthenticator implements SimplePreAuthenticatorInterface, AuthenticationFailureHandlerInterface
{
    /**
    * Durée de validité du token en secondes, 12 heures
    */
    const TOKEN_VALIDITY_DURATION = 12 * 3600;

    protected $httpUtils;

    public function __construct(HttpUtils $httpUtils)
    {
        $this->httpUtils = $httpUtils;
    }

    public function createToken(Request $request, $providerKey)
    {
        $targetUrl = 'post_auth_tokens';
        // Si la requête est une création de token, aucune vérification n'est effectué
        if ($request->getMethod() === "POST" && $this->httpUtils->checkRequestPath($request, $targetUrl)) {
            return;
        }
      
        $authTokenHeader = $request->headers->get('X-Auth-Token');

        if (!$authTokenHeader) {
            throw new BadCredentialsException('X-Auth-Token header is required');
        }

        return new PreAuthenticatedToken(
            'anon.',
            $authTokenHeader,
            $providerKey
        );
    }
    // ...
}
\end{CodeBlock}



Pour obtenir la liste des routes, nous pouvons utiliser la commande \CodeInline{php bin/console debug:router}.



\begin{CodeBlock}{txt}
 get_places                 GET      ANY      ANY    /places
 get_place                  GET      ANY      ANY    /places/{id}
 post_places                POST     ANY      ANY    /places
 remove_place               DELETE   ANY      ANY    /places/{id}
 update_place               PUT      ANY      ANY    /places/{id}
 patch_place                PATCH    ANY      ANY    /places/{id}
 get_prices                 GET      ANY      ANY    /places/{id}/prices
 post_prices                POST     ANY      ANY    /places/{id}/prices
 get_themes                 GET      ANY      ANY    /places/{id}/themes
 post_themes                POST     ANY      ANY    /places/{id}/themes
 get_users                  GET      ANY      ANY    /users
 get_user                   GET      ANY      ANY    /users/{id}
 post_users                 POST     ANY      ANY    /users
 remove_user                DELETE   ANY      ANY    /users/{id}
 update_user                PUT      ANY      ANY    /users/{id}
 patch_user                 PATCH    ANY      ANY    /users/{id}
 get_user_suggestions       GET      ANY      ANY    /users/{id}/suggestions
 post_auth_tokens           POST     ANY      ANY    /auth-tokens
 remove_auth_token          DELETE   ANY      ANY    /auth-tokens/{id}
 get_preferences            GET      ANY      ANY    /users/{id}/preferences
 post_preferences           POST     ANY      ANY    /users/{id}/preferences
\end{CodeBlock}



Avec le système de nommage de \textit{FOSRestBundle}, nous avons des noms simples et \textbf{surtout qui décrivent aussi le verbe HTTP associé} à la route. Dés lors pour autoriser une action, nous pouvons nous baser uniquement sur le nom de la route correspondante (le verbe HTTP est vérifiée indirectement).



Ainsi pour autoriser la création d'utilisateurs et de tokens d'authentification, nous pouvons simplement utiliser respectivement les routes : \textit{post\_users} et \textit{post\_auth\_tokens}.



Le code peut devenir :



\begin{CodeBlock}{php}
<?php
# src/AppBundle/Security/AuthTokenAuthenticator.php

namespace AppBundle\Security;

// ...

class AuthTokenAuthenticator implements SimplePreAuthenticatorInterface, AuthenticationFailureHandlerInterface
{
    /**
    * Durée de validité du token en secondes, 12 heures
    */
    const TOKEN_VALIDITY_DURATION = 12 * 3600;

    public function __construct()
    {
    }

    public function createToken(Request $request, $providerKey)
    {
        $autorisedPaths = [
            'post_users', // Création d'un utilisateur (inscription)
            'post_auth_tokens' // Création d'un token (connexion)
        ];

        $currentRoute = $request->attributes->get('_route');
        
        if (in_array($currentRoute, $autorisedPaths)) {
            return;
        }
      
        $authTokenHeader = $request->headers->get('X-Auth-Token');

        if (!$authTokenHeader) {
            throw new BadCredentialsException('X-Auth-Token header is required');
        }

        return new PreAuthenticatedToken(
            'anon.',
            $authTokenHeader,
            $providerKey
        );
    }
    // ...
}
\end{CodeBlock}



Le service \CodeInline{HttpUtils} étant maintenant inutile, nous pouvons même le retirer de la configuration des services.



\begin{CodeBlock}{yml}
# app/config/services.yml

auth_token_authenticator:
    class:     AppBundle\Security\AuthTokenAuthenticator
    # arguments: ["@security.http_utils"] # à supprimer ou à commenter
    public:    false
\end{CodeBlock}
\captionof{listing}{Désactivation du service HTTPUtils}



Bien sur, libre à vous de gérer la liste de routes autorisées comme bon vous semble (en injectant un paramètre configurable dans le service, en ayant une liste dans une variable statique, etc.).



\horizontalLine



Nous avons pu voir tout au long de ce cours que les contraintes REST permettent de mettre en place une API uniforme et facile à prendre en main. La mise en œuvre de ces contraintes offre un ensemble d'avantages et le framework Symfony dispose d'outils suffisamment matures pour aider dans les développements.



Ce cours bien qu'étant assez long n'aborde pas tous les concepts de REST ni toutes les fonctionnalités qu'apportent \textit{FOSRestBundle} et les différents bundles utilisés. Son objectif est de présenter de manière succincte l'essentiel des notions à comprendre pour pouvoir développer une API RESTFul et l'améliorer en toute autonomie.



Le style d'architecture REST ne s'occupe pas des détails d'implémentations mais plutôt du rôle de chaque composant de notre application.



N'hésitez surtout pas enrichir l'API et à explorer les documentations officielles des différents outils abordés pour mieux cerner tout ce qu'ils peuvent vous apporter.


\end{document}