
Vu que nous allons imposer l'utilisation du token dans toutes les requêtes, nous devons vérifier sa validité afin de nous assurer que le client de l'API est bien authentifié.

Pour nous assurer de ce bon fonctionnement, chaque requête doit contenir une entête `X-Auth-Token` qui contiendra notre token fraichement crée.

[[information]]
|Le nom de notre entête ne vient pas du néant. De manière conventionnelle, lorsqu'une requête contient une entête n'appartenant pas aux spécifications HTTP, le nom débute par **X-**. Ensuite, le reste du nom reflète le contenu de l'entête, **Auth-Token** pour **Auth**entication **Token**.

Nous avons beaucoup d'exemples dans notre API actuelle qui suivent ce modèle de nommage. Lorsque nous consultons les entêtes d'une réponse quelconque de notre API, nous pouvons voir **X-Debug-Token** (créé par Symfony en mode config dev) ou encore  **X-Powered-By** (créé par PHP).

![Entêtes personnalisées renvoyées par notre API](http://zestedesavoir.com/media/galleries/3183/53f1dab5-f254-4de2-b084-f0e57df0db94.png)

Symfony dispose d'un mécanisme spécifique permettant de gérer les clés d'API. Il existe [un cookbook](http://symfony.com/doc/current/cookbook/security/api_key_authentication.html) décrivant de manière très succincte les mécanismes en jeu pour le mettre en place.

Pour résumer, à chaque requête de l'utilisateur, un listener est appelé afin de vérifier que la requête contient une entête nommée `X-Auth-Token`. Et si tel est le cas, son existence dans notre base de données et sa validité sont vérifiées.

[[attention]]
|Pour une requête permettant de créer un token d'authentification, ce listener ne fait aucune action afin d'autoriser la requête.

![Cinématique d'authentification en succès](http://zestedesavoir.com/media/galleries/3183/2c5c7ce7-2be1-4df9-a98b-4225c7875d32.png)

Pour simplifier notre implémentation, nous considérons qu'un token d'authentification est invalide si son ancienneté est supérieur à 12 heures. Vous pouvez cependant modifier ce comportement et définir les règles de validité que vous voulez.

![Cinématique d'authentification en erreur](http://zestedesavoir.com/media/galleries/3183/9ac01d3e-2c75-46d1-aeff-11025e845a0f.png)

Comme pour tous les systèmes d'authentification de Symfony, nous avons besoin d'un fournisseur d'utilisateurs (`UserProvider`). Pour notre cas, il faut que notre fournisseur puisse charger un token en utilisant la valeur dans notre entête `X-Auth-Token`.
```php
<?php
# src/AppBundle/Security/AuthTokenUserProvider.php

namespace AppBundle\Security;

use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Core\User\User;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Doctrine\ORM\EntityRepository;

class AuthTokenUserProvider implements UserProviderInterface
{
    protected $authTokenRepository;
    protected $userRepository;

    public function __construct(EntityRepository $authTokenRepository, EntityRepository $userRepository)
    {
        $this->authTokenRepository = $authTokenRepository;
        $this->userRepository = $userRepository;
    }

    public function getAuthToken($authTokenHeader)
    {
        return $this->authTokenRepository->findOneByValue($authTokenHeader);
    }

    public function loadUserByUsername($email)
    {
        return $this->userRepository->findByEmail($email);
    }

    public function refreshUser(UserInterface $user)
    {
        // Le systéme d'authentification est stateless, on ne doit donc jamais appeler la méthode refreshUser
        throw new UnsupportedUserException();
    }

    public function supportsClass($class)
    {
        return 'AppBundle\Entity\User' === $class;
    }
}
```


Cette classe permettra de récupérer les utilisateurs en se basant sur le token d'authentification fourni.

Pour piloter le mécanisme d'authentification, nous devons créer une classe implémentant l'interface `SimplePreAuthenticatorInterface` de Symfony. C'est cette classe qui gère la cinématique d'authentification que nous avons décrite plus haut.

```php
# src/AppBundle/Security/AuthTokenAuthenticator.php
<?php
namespace AppBundle\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Security\Core\Authentication\Token\PreAuthenticatedToken;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Core\Exception\BadCredentialsException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationFailureHandlerInterface;
use Symfony\Component\Security\Http\Authentication\SimplePreAuthenticatorInterface;
use Symfony\Component\Security\Http\HttpUtils;

class AuthTokenAuthenticator implements SimplePreAuthenticatorInterface, AuthenticationFailureHandlerInterface
{
    /**
    * Durée de validité du token en secondes, 12 heures
    */
    const TOKEN_VALIDITY_DURATION = 12 * 3600;

    protected $httpUtils;

    public function __construct(HttpUtils $httpUtils)
    {
        $this->httpUtils = $httpUtils;
    }

    public function createToken(Request $request, $providerKey)
    {

        $targetUrl = '/auth-tokens';
        // Si la requête est une création de token, aucune vérification n'est effectuée
        if ($request->getMethod() === "POST" && $this->httpUtils->checkRequestPath($request, $targetUrl)) {
            return;
        }
      
        $authTokenHeader = $request->headers->get('X-Auth-Token');

        if (!$authTokenHeader) {
            throw new BadCredentialsException('X-Auth-Token header is required');
        }

        return new PreAuthenticatedToken(
            'anon.',
            $authTokenHeader,
            $providerKey
        );
    }

    public function authenticateToken(TokenInterface $token, UserProviderInterface $userProvider, $providerKey)
    {
        if (!$userProvider instanceof AuthTokenUserProvider) {
            throw new \InvalidArgumentException(
                sprintf(
                    'The user provider must be an instance of AuthTokenUserProvider (%s was given).',
                    get_class($userProvider)
                )
            );
        }

        $authTokenHeader = $token->getCredentials();
        $authToken = $userProvider->getAuthToken($authTokenHeader);

        if (!$authToken || !$this->isTokenValid($authToken)) {
            throw new BadCredentialsException('Invalid authentication token');
        }

        $user = $authToken->getUser();
        $pre = new PreAuthenticatedToken(
            $user,
            $authTokenHeader,
            $providerKey,
            $user->getRoles()
        );

        // Nos utilisateurs n'ont pas de role particulier, on doit donc forcer l'authentification du token
        $pre->setAuthenticated(true);

        return $pre;
    }

    public function supportsToken(TokenInterface $token, $providerKey)
    {
        return $token instanceof PreAuthenticatedToken && $token->getProviderKey() === $providerKey;
    }

    /**
    * Vérifie la validité du token
    */
    private function isTokenValid($authToken)
    {
        return (time() - $authToken->getCreatedAt()->getTimestamp()) < self::TOKEN_VALIDITY_DURATION;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception)
    {
        // Si les données d'identification ne sont pas correctes, une exception est levée
        throw $exception;
    }
}
```


La configuration du service est classique :

```yaml
# app/config/services.yml

# Learn more about services, parameters and containers at
# http://symfony.com/doc/current/book/service_container.html
parameters:
#    parameter_name: value

services:
    auth_token_user_provider:
        class: AppBundle\Security\AuthTokenUserProvider
        arguments: ["@auth_token_repository", "@user_repository"]
        public:    false

    auth_token_repository:
        class:   Doctrine\ORM\EntityManager
        factory: ["@doctrine.orm.entity_manager", "getRepository"]
        arguments: ["AppBundle:AuthToken"]

    user_repository:
        class:   Doctrine\ORM\EntityManager
        factory: ["@doctrine.orm.entity_manager", "getRepository"]
        arguments: ["AppBundle:User"]

    auth_token_authenticator:
        class:     AppBundle\Security\AuthTokenAuthenticator
        arguments: ["@security.http_utils"]
        public:    false

```

Nous devons maintenant activer le pare-feu (firewall) de Symfony et le configurer avec notre fournisseur d'utilisateurs et le listener que nous venons de créer.

```yaml
# app/config/security.yml

# To get started with security, check out the documentation:
# http://symfony.com/doc/current/book/security.html
security:

    # http://symfony.com/doc/current/book/security.html#where-do-users-come-from-user-providers
    providers:
        auth_token_user_provider:
            id: auth_token_user_provider

    firewalls:
        # disables authentication for assets and the profiler, adapt it according to your needs
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false

        main:
            pattern: ^/
            stateless: true
            simple_preauth:
                authenticator: auth_token_authenticator
            provider: auth_token_user_provider
            anonymous: ~

    encoders:
        AppBundle\Entity\User:
            algorithm: bcrypt
            cost: 12
```

[[attention]]
|Vous pouvez remarquer que le pare-feu (firewall) est configuré en mode `stateless`. À chaque requête, l'identité de l'utilisateur est revérifiée. La session n'est jamais utilisée.


Maintenant, lorsque nous essayons de lister les lieux sans mettre l'entête d'authentification, une exception est levée:

![Requête Postman pour lister les lieux sans token d'authentification](http://zestedesavoir.com/media/galleries/3183/7e93fee1-4f3a-4bf9-a96b-fb9860e1ff5e.png)

```json
{
  "error": {
    "code": 500,
    "message": "Internal Server Error",
    "exception": [
      {
        "message": "X-Auth-Token header is required",
        "class": "Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException",
        "trace": [
            "..."
        ]
      }
    ]
  }
}
```

Spoil ! Les codes de statut et les messages renvoyés pour ce cas de figure ne sont pas conformes aux principes REST. Nous verrons dans ce chapitre comment corriger le tir.

Pour le moment, l'exception `BadCredentialsException`, avec le message `X-Auth-Token header is required`, confirme bien que la vérification du token est effectuée.

En rajoutant le token que nous avions généré plus tôt, la réponse contient bien la liste des lieux de notre application.

Avec Postman, il faut accéder à l'onglet ||Headers|| en dessous de l'URL pour ajouter des entêtes à notre requête.

![Requête Postman pour lister les lieux avec un token d'authentification](http://zestedesavoir.com/media/galleries/3183/b6d238c8-aed7-408f-ab98-4c64499c3da5.png)

```json
[
  {
    "id": 1,
    "name": "Tour Eiffel",
    "address": "5 Avenue Anatole France, 75007 Paris",
    "prices": [
      {
        "id": 1,
        "type": "less_than_12",
        "value": 5.75
      }
    ],
    "themes": [
      {
        "id": 1,
        "name": "architecture",
        "value": 7
      },
      {
        "id": 2,
        "name": "history",
        "value": 6
      }
    ]
  },
  // ...
]
```

Notre API est maintenant sécurisée !

Par contre, la gestion des exceptions n'est pas encore très élaborée. En plus, vous l'avez peut-être déjà remarqué mais le format des messages d'erreur n'est pas uniforme. Lorsque le formulaire est invalide ou une exception est levée, les réponses renvoyées ne sont pas identiques, un client de l'API aura donc du mal à gérer les réponses en erreur.
